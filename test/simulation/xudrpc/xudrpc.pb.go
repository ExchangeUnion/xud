// Code generated by protoc-gen-go. DO NOT EDIT.
// source: xudrpc.proto

/*
Package xudrpc is a generated protocol buffer package.

It is generated from these files:
	xudrpc.proto

It has these top-level messages:
	CreateNodeRequest
	CreateNodeResponse
	UnlockNodeRequest
	UnlockNodeResponse
	Currency
	AddCurrencyResponse
	AddPairRequest
	AddPairResponse
	BanRequest
	BanResponse
	Chain
	Balance
	GetBalanceRequest
	GetBalanceResponse
	OpenChannelRequest
	OpenChannelResponse
	ConnectRequest
	ConnectResponse
	SwapFailure
	GetInfoRequest
	GetInfoResponse
	GetNodeInfoRequest
	GetNodeInfoResponse
	ListOrdersRequest
	ListOrdersResponse
	ListCurrenciesRequest
	ListCurrenciesResponse
	ListPairsRequest
	ListPairsResponse
	ListPeersRequest
	ListPeersResponse
	ListTradesRequest
	ListTradesResponse
	Channels
	LndInfo
	Order
	Trade
	OrderUpdate
	OrderRemoval
	Orders
	OrdersCount
	Peer
	PlaceOrderRequest
	PlaceOrderResponse
	PlaceOrderEvent
	RaidenInfo
	RemoveCurrencyRequest
	RemoveCurrencyResponse
	RemoveOrderRequest
	RemoveOrderResponse
	RemovePairRequest
	RemovePairResponse
	DiscoverNodesRequest
	DiscoverNodesResponse
	ShutdownRequest
	ShutdownResponse
	SubscribeOrdersRequest
	SubscribeSwapsRequest
	SwapSuccess
	UnbanRequest
	UnbanResponse
*/
package xudrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OrderSide int32

const (
	OrderSide_BUY  OrderSide = 0
	OrderSide_SELL OrderSide = 1
)

var OrderSide_name = map[int32]string{
	0: "BUY",
	1: "SELL",
}
var OrderSide_value = map[string]int32{
	"BUY":  0,
	"SELL": 1,
}

func (x OrderSide) String() string {
	return proto.EnumName(OrderSide_name, int32(x))
}
func (OrderSide) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Currency_SwapClient int32

const (
	Currency_LND    Currency_SwapClient = 0
	Currency_RAIDEN Currency_SwapClient = 1
)

var Currency_SwapClient_name = map[int32]string{
	0: "LND",
	1: "RAIDEN",
}
var Currency_SwapClient_value = map[string]int32{
	"LND":    0,
	"RAIDEN": 1,
}

func (x Currency_SwapClient) String() string {
	return proto.EnumName(Currency_SwapClient_name, int32(x))
}
func (Currency_SwapClient) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type SwapSuccess_Role int32

const (
	SwapSuccess_TAKER SwapSuccess_Role = 0
	SwapSuccess_MAKER SwapSuccess_Role = 1
)

var SwapSuccess_Role_name = map[int32]string{
	0: "TAKER",
	1: "MAKER",
}
var SwapSuccess_Role_value = map[string]int32{
	"TAKER": 0,
	"MAKER": 1,
}

func (x SwapSuccess_Role) String() string {
	return proto.EnumName(SwapSuccess_Role_name, int32(x))
}
func (SwapSuccess_Role) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{58, 0} }

type CreateNodeRequest struct {
	// The password in utf-8 with which to encrypt the new xud node key as well
	// as any uninitialized underlying wallets.
	Password string `protobuf:"bytes,1,opt,name=password" json:"password,omitempty"`
}

func (m *CreateNodeRequest) Reset()                    { *m = CreateNodeRequest{} }
func (m *CreateNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateNodeRequest) ProtoMessage()               {}
func (*CreateNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CreateNodeRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type CreateNodeResponse struct {
	// The 24 word mnemonic to recover the xud identity key and underlying wallets
	SeedMnemonic []string `protobuf:"bytes,1,rep,name=seed_mnemonic,json=seedMnemonic" json:"seed_mnemonic,omitempty"`
	// The list of lnd clients that were initialized.
	InitializedLnds []string `protobuf:"bytes,2,rep,name=initialized_lnds,json=initializedLnds" json:"initialized_lnds,omitempty"`
	// Whether raiden was initialized.
	InitializedRaiden bool `protobuf:"varint,3,opt,name=initialized_raiden,json=initializedRaiden" json:"initialized_raiden,omitempty"`
}

func (m *CreateNodeResponse) Reset()                    { *m = CreateNodeResponse{} }
func (m *CreateNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateNodeResponse) ProtoMessage()               {}
func (*CreateNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CreateNodeResponse) GetSeedMnemonic() []string {
	if m != nil {
		return m.SeedMnemonic
	}
	return nil
}

func (m *CreateNodeResponse) GetInitializedLnds() []string {
	if m != nil {
		return m.InitializedLnds
	}
	return nil
}

func (m *CreateNodeResponse) GetInitializedRaiden() bool {
	if m != nil {
		return m.InitializedRaiden
	}
	return false
}

type UnlockNodeRequest struct {
	// The password in utf-8 with which to unlock an existing xud node key as
	// well as underlying client wallets such as lnd.
	Password string `protobuf:"bytes,1,opt,name=password" json:"password,omitempty"`
}

func (m *UnlockNodeRequest) Reset()                    { *m = UnlockNodeRequest{} }
func (m *UnlockNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*UnlockNodeRequest) ProtoMessage()               {}
func (*UnlockNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UnlockNodeRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type UnlockNodeResponse struct {
	// The list of lnd clients that were unlocked.
	UnlockedLnds []string `protobuf:"bytes,1,rep,name=unlocked_lnds,json=unlockedLnds" json:"unlocked_lnds,omitempty"`
	// Whether raiden was unlocked.
	UnlockedRaiden bool `protobuf:"varint,2,opt,name=unlocked_raiden,json=unlockedRaiden" json:"unlocked_raiden,omitempty"`
}

func (m *UnlockNodeResponse) Reset()                    { *m = UnlockNodeResponse{} }
func (m *UnlockNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*UnlockNodeResponse) ProtoMessage()               {}
func (*UnlockNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UnlockNodeResponse) GetUnlockedLnds() []string {
	if m != nil {
		return m.UnlockedLnds
	}
	return nil
}

func (m *UnlockNodeResponse) GetUnlockedRaiden() bool {
	if m != nil {
		return m.UnlockedRaiden
	}
	return false
}

type Currency struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
	// The payment channel network client to use for executing swaps.
	SwapClient Currency_SwapClient `protobuf:"varint,2,opt,name=swap_client,enum=xudrpc.Currency_SwapClient" json:"swap_client,omitempty"`
	// The contract address for layered tokens such as ERC20.
	TokenAddress string `protobuf:"bytes,3,opt,name=token_address" json:"token_address,omitempty"`
	// The number of places to the right of the decimal point of the smallest subunit of the currency.
	// For example, BTC, LTC, and others where the smallest subunits (satoshis) are 0.00000001 full
	// units (bitcoins) have 8 decimal places. ETH has 18. This can be thought of as the base 10
	// exponent of the smallest subunit expressed as a positive integer. A default value of 8 is
	// used if unspecified.
	DecimalPlaces uint32 `protobuf:"varint,4,opt,name=decimal_places" json:"decimal_places,omitempty"`
}

func (m *Currency) Reset()                    { *m = Currency{} }
func (m *Currency) String() string            { return proto.CompactTextString(m) }
func (*Currency) ProtoMessage()               {}
func (*Currency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Currency) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Currency) GetSwapClient() Currency_SwapClient {
	if m != nil {
		return m.SwapClient
	}
	return Currency_LND
}

func (m *Currency) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *Currency) GetDecimalPlaces() uint32 {
	if m != nil {
		return m.DecimalPlaces
	}
	return 0
}

type AddCurrencyResponse struct {
}

func (m *AddCurrencyResponse) Reset()                    { *m = AddCurrencyResponse{} }
func (m *AddCurrencyResponse) String() string            { return proto.CompactTextString(m) }
func (*AddCurrencyResponse) ProtoMessage()               {}
func (*AddCurrencyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type AddPairRequest struct {
	// The base currency that is bought and sold for this trading pair.
	BaseCurrency string `protobuf:"bytes,1,opt,name=base_currency" json:"base_currency,omitempty"`
	// The currency used to quote a price for the base currency.
	QuoteCurrency string `protobuf:"bytes,2,opt,name=quote_currency" json:"quote_currency,omitempty"`
}

func (m *AddPairRequest) Reset()                    { *m = AddPairRequest{} }
func (m *AddPairRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPairRequest) ProtoMessage()               {}
func (*AddPairRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *AddPairRequest) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *AddPairRequest) GetQuoteCurrency() string {
	if m != nil {
		return m.QuoteCurrency
	}
	return ""
}

type AddPairResponse struct {
}

func (m *AddPairResponse) Reset()                    { *m = AddPairResponse{} }
func (m *AddPairResponse) String() string            { return proto.CompactTextString(m) }
func (*AddPairResponse) ProtoMessage()               {}
func (*AddPairResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type BanRequest struct {
	// The node pub key of the node to ban.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
}

func (m *BanRequest) Reset()                    { *m = BanRequest{} }
func (m *BanRequest) String() string            { return proto.CompactTextString(m) }
func (*BanRequest) ProtoMessage()               {}
func (*BanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type BanResponse struct {
}

func (m *BanResponse) Reset()                    { *m = BanResponse{} }
func (m *BanResponse) String() string            { return proto.CompactTextString(m) }
func (*BanResponse) ProtoMessage()               {}
func (*BanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type Chain struct {
	// The blockchain the swap client is on (eg bitcoin, litecoin)
	Chain string `protobuf:"bytes,1,opt,name=chain" json:"chain,omitempty"`
	// The network the swap client is on (eg regtest, testnet, mainnet)
	Network string `protobuf:"bytes,2,opt,name=network" json:"network,omitempty"`
}

func (m *Chain) Reset()                    { *m = Chain{} }
func (m *Chain) String() string            { return proto.CompactTextString(m) }
func (*Chain) ProtoMessage()               {}
func (*Chain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Chain) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *Chain) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

type Balance struct {
	// Total balance denominated in satoshis.
	Balance uint64 `protobuf:"varint,1,opt,name=balance" json:"balance,omitempty"`
	// Sum of pending channel balances denominated in satoshis.
	PendingOpenBalance uint64 `protobuf:"varint,2,opt,name=pending_open_balance" json:"pending_open_balance,omitempty"`
}

func (m *Balance) Reset()                    { *m = Balance{} }
func (m *Balance) String() string            { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()               {}
func (*Balance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Balance) GetBalance() uint64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Balance) GetPendingOpenBalance() uint64 {
	if m != nil {
		return m.PendingOpenBalance
	}
	return 0
}

type GetBalanceRequest struct {
	// The ticker symbol of the currency to query for, if unspecified then balances for all supported
	// currencies are queried.
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
}

func (m *GetBalanceRequest) Reset()                    { *m = GetBalanceRequest{} }
func (m *GetBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBalanceRequest) ProtoMessage()               {}
func (*GetBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetBalanceRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type GetBalanceResponse struct {
	// A map between currency ticker symbols and their balances.
	Balances map[string]*Balance `protobuf:"bytes,1,rep,name=balances,json=orders" json:"balances,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetBalanceResponse) Reset()                    { *m = GetBalanceResponse{} }
func (m *GetBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBalanceResponse) ProtoMessage()               {}
func (*GetBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetBalanceResponse) GetBalances() map[string]*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type OpenChannelRequest struct {
	// The node pub key of the peer with which to open channel with.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key,json=peer_pub_key" json:"node_pub_key,omitempty"`
	// The ticker symbol of the currency to open the channel for.
	Currency string `protobuf:"bytes,2,opt,name=currency" json:"currency,omitempty"`
	// The amount of the channel denominated in satoshis.
	Amount int64 `protobuf:"varint,3,opt,name=amount" json:"amount,omitempty"`
}

func (m *OpenChannelRequest) Reset()                    { *m = OpenChannelRequest{} }
func (m *OpenChannelRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenChannelRequest) ProtoMessage()               {}
func (*OpenChannelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *OpenChannelRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *OpenChannelRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *OpenChannelRequest) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type OpenChannelResponse struct {
}

func (m *OpenChannelResponse) Reset()                    { *m = OpenChannelResponse{} }
func (m *OpenChannelResponse) String() string            { return proto.CompactTextString(m) }
func (*OpenChannelResponse) ProtoMessage()               {}
func (*OpenChannelResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type ConnectRequest struct {
	// The uri of the node to connect to in "[nodePubKey]@[host]:[port]" format.
	NodeUri string `protobuf:"bytes,1,opt,name=node_uri" json:"node_uri,omitempty"`
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ConnectRequest) GetNodeUri() string {
	if m != nil {
		return m.NodeUri
	}
	return ""
}

type ConnectResponse struct {
}

func (m *ConnectResponse) Reset()                    { *m = ConnectResponse{} }
func (m *ConnectResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectResponse) ProtoMessage()               {}
func (*ConnectResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type SwapFailure struct {
	// The global UUID for the order that failed the swap.
	OrderId string `protobuf:"bytes,1,opt,name=order_id" json:"order_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id" json:"pair_id,omitempty"`
	// The order quantity that was attempted to be swapped.
	Quantity uint64 `protobuf:"varint,3,opt,name=quantity" json:"quantity,omitempty"`
	// The node pub key of the peer that we attempted to swap with.
	PeerPubKey string `protobuf:"bytes,4,opt,name=peer_pub_key" json:"peer_pub_key,omitempty"`
	// The reason why the swap failed.
	FailureReason string `protobuf:"bytes,5,opt,name=failure_reason" json:"failure_reason,omitempty"`
}

func (m *SwapFailure) Reset()                    { *m = SwapFailure{} }
func (m *SwapFailure) String() string            { return proto.CompactTextString(m) }
func (*SwapFailure) ProtoMessage()               {}
func (*SwapFailure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *SwapFailure) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapFailure) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapFailure) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *SwapFailure) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *SwapFailure) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type GetInfoResponse struct {
	// The version of this instance of xud.
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The node pub key of this node.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// A list of uris that can be used to connect to this node. These are shared with peers.
	Uris []string `protobuf:"bytes,3,rep,name=uris" json:"uris,omitempty"`
	// The number of currently connected peers.
	NumPeers uint32 `protobuf:"varint,4,opt,name=num_peers" json:"num_peers,omitempty"`
	// The number of supported trading pairs.
	NumPairs uint32 `protobuf:"varint,5,opt,name=num_pairs" json:"num_pairs,omitempty"`
	// The number of active, standing orders in the order book.
	Orders *OrdersCount        `protobuf:"bytes,6,opt,name=orders" json:"orders,omitempty"`
	Lnd    map[string]*LndInfo `protobuf:"bytes,7,rep,name=lnd" json:"lnd,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Raiden *RaidenInfo         `protobuf:"bytes,8,opt,name=raiden" json:"raiden,omitempty"`
	// The alias of this instance of xud.
	Alias string `protobuf:"bytes,9,opt,name=alias" json:"alias,omitempty"`
	// The network of this node.
	Network           string   `protobuf:"bytes,10,opt,name=network" json:"network,omitempty"`
	PendingSwapHashes []string `protobuf:"bytes,11,rep,name=pending_swap_hashes" json:"pending_swap_hashes,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GetInfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetInfoResponse) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *GetInfoResponse) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *GetInfoResponse) GetNumPeers() uint32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *GetInfoResponse) GetNumPairs() uint32 {
	if m != nil {
		return m.NumPairs
	}
	return 0
}

func (m *GetInfoResponse) GetOrders() *OrdersCount {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *GetInfoResponse) GetLnd() map[string]*LndInfo {
	if m != nil {
		return m.Lnd
	}
	return nil
}

func (m *GetInfoResponse) GetRaiden() *RaidenInfo {
	if m != nil {
		return m.Raiden
	}
	return nil
}

func (m *GetInfoResponse) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *GetInfoResponse) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *GetInfoResponse) GetPendingSwapHashes() []string {
	if m != nil {
		return m.PendingSwapHashes
	}
	return nil
}

type GetNodeInfoRequest struct {
	// The node pub key of the node for which to get information.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
}

func (m *GetNodeInfoRequest) Reset()                    { *m = GetNodeInfoRequest{} }
func (m *GetNodeInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNodeInfoRequest) ProtoMessage()               {}
func (*GetNodeInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetNodeInfoRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type GetNodeInfoResponse struct {
	// The node's reputation score. Points are subtracted for unexpected or potentially malicious
	// behavior. Points are added when swaps are successfully executed.
	ReputationScore int32 `protobuf:"zigzag32,1,opt,name=reputationScore,json=reputation" json:"reputationScore,omitempty"`
	// Whether the node is currently banned.
	Banned bool `protobuf:"varint,2,opt,name=banned" json:"banned,omitempty"`
}

func (m *GetNodeInfoResponse) Reset()                    { *m = GetNodeInfoResponse{} }
func (m *GetNodeInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNodeInfoResponse) ProtoMessage()               {}
func (*GetNodeInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *GetNodeInfoResponse) GetReputationScore() int32 {
	if m != nil {
		return m.ReputationScore
	}
	return 0
}

func (m *GetNodeInfoResponse) GetBanned() bool {
	if m != nil {
		return m.Banned
	}
	return false
}

type ListOrdersRequest struct {
	// The trading pair for which to retrieve orders.
	PairId string `protobuf:"bytes,1,opt,name=pair_id" json:"pair_id,omitempty"`
	// Whether own orders should be included in result or not.
	IncludeOwnOrders bool `protobuf:"varint,2,opt,name=include_own_orders" json:"include_own_orders,omitempty"`
	// The maximum number of orders to return from each side of the order book.
	Limit uint32 `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *ListOrdersRequest) Reset()                    { *m = ListOrdersRequest{} }
func (m *ListOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListOrdersRequest) ProtoMessage()               {}
func (*ListOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ListOrdersRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *ListOrdersRequest) GetIncludeOwnOrders() bool {
	if m != nil {
		return m.IncludeOwnOrders
	}
	return false
}

func (m *ListOrdersRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ListOrdersResponse struct {
	// A map between pair ids and their buy and sell orders.
	Orders map[string]*Orders `protobuf:"bytes,1,rep,name=orders" json:"orders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListOrdersResponse) Reset()                    { *m = ListOrdersResponse{} }
func (m *ListOrdersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOrdersResponse) ProtoMessage()               {}
func (*ListOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ListOrdersResponse) GetOrders() map[string]*Orders {
	if m != nil {
		return m.Orders
	}
	return nil
}

type ListCurrenciesRequest struct {
}

func (m *ListCurrenciesRequest) Reset()                    { *m = ListCurrenciesRequest{} }
func (m *ListCurrenciesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListCurrenciesRequest) ProtoMessage()               {}
func (*ListCurrenciesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

type ListCurrenciesResponse struct {
	// The list of available currencies in the orderbook.
	Currencies []*Currency `protobuf:"bytes,1,rep,name=currencies" json:"currencies,omitempty"`
}

func (m *ListCurrenciesResponse) Reset()                    { *m = ListCurrenciesResponse{} }
func (m *ListCurrenciesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListCurrenciesResponse) ProtoMessage()               {}
func (*ListCurrenciesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ListCurrenciesResponse) GetCurrencies() []*Currency {
	if m != nil {
		return m.Currencies
	}
	return nil
}

type ListPairsRequest struct {
}

func (m *ListPairsRequest) Reset()                    { *m = ListPairsRequest{} }
func (m *ListPairsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPairsRequest) ProtoMessage()               {}
func (*ListPairsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

type ListPairsResponse struct {
	// The list of supported trading pair tickers in formats like "LTC/BTC".
	Pairs []string `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *ListPairsResponse) Reset()                    { *m = ListPairsResponse{} }
func (m *ListPairsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPairsResponse) ProtoMessage()               {}
func (*ListPairsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ListPairsResponse) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type ListPeersRequest struct {
}

func (m *ListPeersRequest) Reset()                    { *m = ListPeersRequest{} }
func (m *ListPeersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPeersRequest) ProtoMessage()               {}
func (*ListPeersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

type ListPeersResponse struct {
	// The list of connected peers.
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *ListPeersResponse) Reset()                    { *m = ListPeersResponse{} }
func (m *ListPeersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPeersResponse) ProtoMessage()               {}
func (*ListPeersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *ListPeersResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type ListTradesRequest struct {
	// The maximum number of trades to return
	Limit int32 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
}

func (m *ListTradesRequest) Reset()                    { *m = ListTradesRequest{} }
func (m *ListTradesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTradesRequest) ProtoMessage()               {}
func (*ListTradesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *ListTradesRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ListTradesResponse struct {
	Trades []*Trade `protobuf:"bytes,1,rep,name=trades" json:"trades,omitempty"`
}

func (m *ListTradesResponse) Reset()                    { *m = ListTradesResponse{} }
func (m *ListTradesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTradesResponse) ProtoMessage()               {}
func (*ListTradesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *ListTradesResponse) GetTrades() []*Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

type Channels struct {
	// The number of active/online channels for this lnd instance that can be used for swaps.
	Active uint32 `protobuf:"varint,1,opt,name=active" json:"active,omitempty"`
	// The number of inactive/offline channels for this lnd instance.
	Inactive uint32 `protobuf:"varint,2,opt,name=inactive" json:"inactive,omitempty"`
	// The number of channels that are pending on-chain confirmation before they can be used.
	Pending uint32 `protobuf:"varint,3,opt,name=pending" json:"pending,omitempty"`
	// The number of channels that have been closed.
	Closed uint32 `protobuf:"varint,4,opt,name=closed" json:"closed,omitempty"`
}

func (m *Channels) Reset()                    { *m = Channels{} }
func (m *Channels) String() string            { return proto.CompactTextString(m) }
func (*Channels) ProtoMessage()               {}
func (*Channels) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *Channels) GetActive() uint32 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *Channels) GetInactive() uint32 {
	if m != nil {
		return m.Inactive
	}
	return 0
}

func (m *Channels) GetPending() uint32 {
	if m != nil {
		return m.Pending
	}
	return 0
}

func (m *Channels) GetClosed() uint32 {
	if m != nil {
		return m.Closed
	}
	return 0
}

type LndInfo struct {
	Status      string    `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Channels    *Channels `protobuf:"bytes,2,opt,name=channels" json:"channels,omitempty"`
	Chains      []*Chain  `protobuf:"bytes,3,rep,name=chains" json:"chains,omitempty"`
	Blockheight uint32    `protobuf:"varint,4,opt,name=blockheight" json:"blockheight,omitempty"`
	Uris        []string  `protobuf:"bytes,5,rep,name=uris" json:"uris,omitempty"`
	Version     string    `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
	Alias       string    `protobuf:"bytes,7,opt,name=alias" json:"alias,omitempty"`
}

func (m *LndInfo) Reset()                    { *m = LndInfo{} }
func (m *LndInfo) String() string            { return proto.CompactTextString(m) }
func (*LndInfo) ProtoMessage()               {}
func (*LndInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *LndInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *LndInfo) GetChannels() *Channels {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *LndInfo) GetChains() []*Chain {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *LndInfo) GetBlockheight() uint32 {
	if m != nil {
		return m.Blockheight
	}
	return 0
}

func (m *LndInfo) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *LndInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LndInfo) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type Order struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that this order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// A UUID for this order.
	Id string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// Types that are valid to be assigned to OwnOrPeer:
	//	*Order_PeerPubKey
	//	*Order_LocalId
	OwnOrPeer isOrder_OwnOrPeer `protobuf_oneof:"own_or_peer"`
	// The epoch time when this order was created.
	CreatedAt uint64 `protobuf:"varint,7,opt,name=created_at" json:"created_at,omitempty"`
	// Whether this order is a buy or sell
	Side OrderSide `protobuf:"varint,8,opt,name=side,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// Whether this order is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,9,opt,name=is_own_order" json:"is_own_order,omitempty"`
	// The quantity on hold pending swap execution.
	Hold uint64 `protobuf:"varint,10,opt,name=hold" json:"hold,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

type isOrder_OwnOrPeer interface{ isOrder_OwnOrPeer() }

type Order_PeerPubKey struct {
	PeerPubKey string `protobuf:"bytes,5,opt,name=peer_pub_key,oneof"`
}
type Order_LocalId struct {
	LocalId string `protobuf:"bytes,6,opt,name=local_id,oneof"`
}

func (*Order_PeerPubKey) isOrder_OwnOrPeer() {}
func (*Order_LocalId) isOrder_OwnOrPeer()    {}

func (m *Order) GetOwnOrPeer() isOrder_OwnOrPeer {
	if m != nil {
		return m.OwnOrPeer
	}
	return nil
}

func (m *Order) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Order) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *Order) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Order) GetPeerPubKey() string {
	if x, ok := m.GetOwnOrPeer().(*Order_PeerPubKey); ok {
		return x.PeerPubKey
	}
	return ""
}

func (m *Order) GetLocalId() string {
	if x, ok := m.GetOwnOrPeer().(*Order_LocalId); ok {
		return x.LocalId
	}
	return ""
}

func (m *Order) GetCreatedAt() uint64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

func (m *Order) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

func (m *Order) GetHold() uint64 {
	if m != nil {
		return m.Hold
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Order) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Order_OneofMarshaler, _Order_OneofUnmarshaler, _Order_OneofSizer, []interface{}{
		(*Order_PeerPubKey)(nil),
		(*Order_LocalId)(nil),
	}
}

func _Order_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Order)
	// own_or_peer
	switch x := m.OwnOrPeer.(type) {
	case *Order_PeerPubKey:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PeerPubKey)
	case *Order_LocalId:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LocalId)
	case nil:
	default:
		return fmt.Errorf("Order.OwnOrPeer has unexpected type %T", x)
	}
	return nil
}

func _Order_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Order)
	switch tag {
	case 5: // own_or_peer.peer_pub_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OwnOrPeer = &Order_PeerPubKey{x}
		return true, err
	case 6: // own_or_peer.local_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OwnOrPeer = &Order_LocalId{x}
		return true, err
	default:
		return false, nil
	}
}

func _Order_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Order)
	// own_or_peer
	switch x := m.OwnOrPeer.(type) {
	case *Order_PeerPubKey:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PeerPubKey)))
		n += len(x.PeerPubKey)
	case *Order_LocalId:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LocalId)))
		n += len(x.LocalId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Trade struct {
	// The maker order involved in this trade.
	MakerOrder *Order `protobuf:"bytes,1,opt,name=maker_order" json:"maker_order,omitempty"`
	// The taker order involved in this trade.
	TakerOrder *Order `protobuf:"bytes,2,opt,name=taker_order,json=taker_order_id" json:"taker_order,omitempty"`
	// The payment hash involved in this trade.
	RHash string `protobuf:"bytes,3,opt,name=r_hash" json:"r_hash,omitempty"`
	// The quantity transacted in this trade.
	Quantity int64 `protobuf:"varint,4,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair for this trade.
	PairId string `protobuf:"bytes,5,opt,name=pair_id" json:"pair_id,omitempty"`
}

func (m *Trade) Reset()                    { *m = Trade{} }
func (m *Trade) String() string            { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()               {}
func (*Trade) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *Trade) GetMakerOrder() *Order {
	if m != nil {
		return m.MakerOrder
	}
	return nil
}

func (m *Trade) GetTakerOrder() *Order {
	if m != nil {
		return m.TakerOrder
	}
	return nil
}

func (m *Trade) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *Trade) GetQuantity() int64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Trade) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type OrderUpdate struct {
	// Types that are valid to be assigned to OrderUpdate:
	//	*OrderUpdate_Order
	//	*OrderUpdate_OrderRemoval
	OrderUpdate isOrderUpdate_OrderUpdate `protobuf_oneof:"order_update"`
}

func (m *OrderUpdate) Reset()                    { *m = OrderUpdate{} }
func (m *OrderUpdate) String() string            { return proto.CompactTextString(m) }
func (*OrderUpdate) ProtoMessage()               {}
func (*OrderUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

type isOrderUpdate_OrderUpdate interface{ isOrderUpdate_OrderUpdate() }

type OrderUpdate_Order struct {
	Order *Order `protobuf:"bytes,1,opt,name=order,oneof"`
}
type OrderUpdate_OrderRemoval struct {
	OrderRemoval *OrderRemoval `protobuf:"bytes,2,opt,name=order_removal,oneof"`
}

func (*OrderUpdate_Order) isOrderUpdate_OrderUpdate()        {}
func (*OrderUpdate_OrderRemoval) isOrderUpdate_OrderUpdate() {}

func (m *OrderUpdate) GetOrderUpdate() isOrderUpdate_OrderUpdate {
	if m != nil {
		return m.OrderUpdate
	}
	return nil
}

func (m *OrderUpdate) GetOrder() *Order {
	if x, ok := m.GetOrderUpdate().(*OrderUpdate_Order); ok {
		return x.Order
	}
	return nil
}

func (m *OrderUpdate) GetOrderRemoval() *OrderRemoval {
	if x, ok := m.GetOrderUpdate().(*OrderUpdate_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OrderUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OrderUpdate_OneofMarshaler, _OrderUpdate_OneofUnmarshaler, _OrderUpdate_OneofSizer, []interface{}{
		(*OrderUpdate_Order)(nil),
		(*OrderUpdate_OrderRemoval)(nil),
	}
}

func _OrderUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OrderUpdate)
	// order_update
	switch x := m.OrderUpdate.(type) {
	case *OrderUpdate_Order:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Order); err != nil {
			return err
		}
	case *OrderUpdate_OrderRemoval:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderRemoval); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OrderUpdate.OrderUpdate has unexpected type %T", x)
	}
	return nil
}

func _OrderUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OrderUpdate)
	switch tag {
	case 1: // order_update.order
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Order)
		err := b.DecodeMessage(msg)
		m.OrderUpdate = &OrderUpdate_Order{msg}
		return true, err
	case 2: // order_update.order_removal
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderRemoval)
		err := b.DecodeMessage(msg)
		m.OrderUpdate = &OrderUpdate_OrderRemoval{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OrderUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OrderUpdate)
	// order_update
	switch x := m.OrderUpdate.(type) {
	case *OrderUpdate_Order:
		s := proto.Size(x.Order)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OrderUpdate_OrderRemoval:
		s := proto.Size(x.OrderRemoval)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OrderRemoval struct {
	// The quantity removed from the order.
	Quantity uint64 `protobuf:"varint,1,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id" json:"pair_id,omitempty"`
	// The global UUID for the order.
	OrderId string `protobuf:"bytes,3,opt,name=order_id" json:"order_id,omitempty"`
	// The local id for the order, if applicable.
	LocalId string `protobuf:"bytes,4,opt,name=local_id" json:"local_id,omitempty"`
	// Whether the order being removed is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,5,opt,name=is_own_order" json:"is_own_order,omitempty"`
}

func (m *OrderRemoval) Reset()                    { *m = OrderRemoval{} }
func (m *OrderRemoval) String() string            { return proto.CompactTextString(m) }
func (*OrderRemoval) ProtoMessage()               {}
func (*OrderRemoval) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *OrderRemoval) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *OrderRemoval) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *OrderRemoval) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderRemoval) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *OrderRemoval) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

type Orders struct {
	// A list of buy orders sorted by descending price.
	BuyOrders []*Order `protobuf:"bytes,1,rep,name=buy_orders" json:"buy_orders,omitempty"`
	// A list of sell orders sorted by ascending price.
	SellOrders []*Order `protobuf:"bytes,2,rep,name=sell_orders" json:"sell_orders,omitempty"`
}

func (m *Orders) Reset()                    { *m = Orders{} }
func (m *Orders) String() string            { return proto.CompactTextString(m) }
func (*Orders) ProtoMessage()               {}
func (*Orders) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *Orders) GetBuyOrders() []*Order {
	if m != nil {
		return m.BuyOrders
	}
	return nil
}

func (m *Orders) GetSellOrders() []*Order {
	if m != nil {
		return m.SellOrders
	}
	return nil
}

type OrdersCount struct {
	// The number of orders belonging to remote xud nodes.
	Peer uint32 `protobuf:"varint,1,opt,name=peer" json:"peer,omitempty"`
	// The number of orders belonging to our local xud node.
	Own uint32 `protobuf:"varint,2,opt,name=own" json:"own,omitempty"`
}

func (m *OrdersCount) Reset()                    { *m = OrdersCount{} }
func (m *OrdersCount) String() string            { return proto.CompactTextString(m) }
func (*OrdersCount) ProtoMessage()               {}
func (*OrdersCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *OrdersCount) GetPeer() uint32 {
	if m != nil {
		return m.Peer
	}
	return 0
}

func (m *OrdersCount) GetOwn() uint32 {
	if m != nil {
		return m.Own
	}
	return 0
}

type Peer struct {
	// The socket address with host and port for this peer.
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The node pub key to uniquely identify this peer.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// A map of ticker symbols to lnd pub keys for this peer
	LndPubKeys map[string]string `protobuf:"bytes,3,rep,name=lnd_pub_keys" json:"lnd_pub_keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Indicates whether this peer was connected inbound.
	Inbound bool `protobuf:"varint,4,opt,name=inbound" json:"inbound,omitempty"`
	// A list of trading pair tickers supported by this peer.
	Pairs []string `protobuf:"bytes,5,rep,name=pairs" json:"pairs,omitempty"`
	// The version of xud being used by the peer.
	XudVersion string `protobuf:"bytes,6,opt,name=xud_version" json:"xud_version,omitempty"`
	// The time in seconds that we have been connected to this peer.
	SecondsConnected uint32 `protobuf:"varint,7,opt,name=seconds_connected" json:"seconds_connected,omitempty"`
	// The raiden address for this peer
	RaidenAddress string `protobuf:"bytes,8,opt,name=raiden_address" json:"raiden_address,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *Peer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Peer) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *Peer) GetLndPubKeys() map[string]string {
	if m != nil {
		return m.LndPubKeys
	}
	return nil
}

func (m *Peer) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *Peer) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *Peer) GetXudVersion() string {
	if m != nil {
		return m.XudVersion
	}
	return ""
}

func (m *Peer) GetSecondsConnected() uint32 {
	if m != nil {
		return m.SecondsConnected
	}
	return 0
}

func (m *Peer) GetRaidenAddress() string {
	if m != nil {
		return m.RaidenAddress
	}
	return ""
}

type PlaceOrderRequest struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order denominated in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The local id to assign to the order.
	OrderId string `protobuf:"bytes,4,opt,name=order_id" json:"order_id,omitempty"`
	// Whether the order is a buy or sell.
	Side OrderSide `protobuf:"varint,5,opt,name=side,enum=xudrpc.OrderSide" json:"side,omitempty"`
}

func (m *PlaceOrderRequest) Reset()                    { *m = PlaceOrderRequest{} }
func (m *PlaceOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderRequest) ProtoMessage()               {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *PlaceOrderRequest) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *PlaceOrderRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *PlaceOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *PlaceOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *PlaceOrderRequest) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

type PlaceOrderResponse struct {
	// A list of own orders (or portions thereof) that matched the newly placed order.
	InternalMatches []*Order `protobuf:"bytes,1,rep,name=internal_matches" json:"internal_matches,omitempty"`
	// A list of successful swaps of peer orders that matched the newly placed order.
	SwapSuccesses []*SwapSuccess `protobuf:"bytes,2,rep,name=swap_successes" json:"swap_successes,omitempty"`
	// The remaining portion of the order, after matches, that enters the order book.
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order" json:"remaining_order,omitempty"`
	// A list of swap attempts that failed.
	SwapFailures []*SwapFailure `protobuf:"bytes,4,rep,name=swap_failures" json:"swap_failures,omitempty"`
}

func (m *PlaceOrderResponse) Reset()                    { *m = PlaceOrderResponse{} }
func (m *PlaceOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderResponse) ProtoMessage()               {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *PlaceOrderResponse) GetInternalMatches() []*Order {
	if m != nil {
		return m.InternalMatches
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapSuccesses() []*SwapSuccess {
	if m != nil {
		return m.SwapSuccesses
	}
	return nil
}

func (m *PlaceOrderResponse) GetRemainingOrder() *Order {
	if m != nil {
		return m.RemainingOrder
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapFailures() []*SwapFailure {
	if m != nil {
		return m.SwapFailures
	}
	return nil
}

type PlaceOrderEvent struct {
	// Types that are valid to be assigned to Event:
	//	*PlaceOrderEvent_InternalMatch
	//	*PlaceOrderEvent_SwapSuccess
	//	*PlaceOrderEvent_RemainingOrder
	//	*PlaceOrderEvent_SwapFailure
	Event isPlaceOrderEvent_Event `protobuf_oneof:"event"`
}

func (m *PlaceOrderEvent) Reset()                    { *m = PlaceOrderEvent{} }
func (m *PlaceOrderEvent) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderEvent) ProtoMessage()               {}
func (*PlaceOrderEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

type isPlaceOrderEvent_Event interface{ isPlaceOrderEvent_Event() }

type PlaceOrderEvent_InternalMatch struct {
	InternalMatch *Order `protobuf:"bytes,1,opt,name=internal_match,oneof"`
}
type PlaceOrderEvent_SwapSuccess struct {
	SwapSuccess *SwapSuccess `protobuf:"bytes,2,opt,name=swap_success,oneof"`
}
type PlaceOrderEvent_RemainingOrder struct {
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order,oneof"`
}
type PlaceOrderEvent_SwapFailure struct {
	SwapFailure *SwapFailure `protobuf:"bytes,4,opt,name=swap_failure,oneof"`
}

func (*PlaceOrderEvent_InternalMatch) isPlaceOrderEvent_Event()  {}
func (*PlaceOrderEvent_SwapSuccess) isPlaceOrderEvent_Event()    {}
func (*PlaceOrderEvent_RemainingOrder) isPlaceOrderEvent_Event() {}
func (*PlaceOrderEvent_SwapFailure) isPlaceOrderEvent_Event()    {}

func (m *PlaceOrderEvent) GetEvent() isPlaceOrderEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *PlaceOrderEvent) GetInternalMatch() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_InternalMatch); ok {
		return x.InternalMatch
	}
	return nil
}

func (m *PlaceOrderEvent) GetSwapSuccess() *SwapSuccess {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_SwapSuccess); ok {
		return x.SwapSuccess
	}
	return nil
}

func (m *PlaceOrderEvent) GetRemainingOrder() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_RemainingOrder); ok {
		return x.RemainingOrder
	}
	return nil
}

func (m *PlaceOrderEvent) GetSwapFailure() *SwapFailure {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_SwapFailure); ok {
		return x.SwapFailure
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PlaceOrderEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PlaceOrderEvent_OneofMarshaler, _PlaceOrderEvent_OneofUnmarshaler, _PlaceOrderEvent_OneofSizer, []interface{}{
		(*PlaceOrderEvent_InternalMatch)(nil),
		(*PlaceOrderEvent_SwapSuccess)(nil),
		(*PlaceOrderEvent_RemainingOrder)(nil),
		(*PlaceOrderEvent_SwapFailure)(nil),
	}
}

func _PlaceOrderEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PlaceOrderEvent)
	// event
	switch x := m.Event.(type) {
	case *PlaceOrderEvent_InternalMatch:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InternalMatch); err != nil {
			return err
		}
	case *PlaceOrderEvent_SwapSuccess:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SwapSuccess); err != nil {
			return err
		}
	case *PlaceOrderEvent_RemainingOrder:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemainingOrder); err != nil {
			return err
		}
	case *PlaceOrderEvent_SwapFailure:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SwapFailure); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PlaceOrderEvent.Event has unexpected type %T", x)
	}
	return nil
}

func _PlaceOrderEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PlaceOrderEvent)
	switch tag {
	case 1: // event.internal_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Order)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_InternalMatch{msg}
		return true, err
	case 2: // event.swap_success
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SwapSuccess)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_SwapSuccess{msg}
		return true, err
	case 3: // event.remaining_order
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Order)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_RemainingOrder{msg}
		return true, err
	case 4: // event.swap_failure
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SwapFailure)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_SwapFailure{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PlaceOrderEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PlaceOrderEvent)
	// event
	switch x := m.Event.(type) {
	case *PlaceOrderEvent_InternalMatch:
		s := proto.Size(x.InternalMatch)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_SwapSuccess:
		s := proto.Size(x.SwapSuccess)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_RemainingOrder:
		s := proto.Size(x.RemainingOrder)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_SwapFailure:
		s := proto.Size(x.SwapFailure)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RaidenInfo struct {
	Status   string    `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Address  string    `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	Channels *Channels `protobuf:"bytes,3,opt,name=channels" json:"channels,omitempty"`
	Version  string    `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	Chain    string    `protobuf:"bytes,5,opt,name=chain" json:"chain,omitempty"`
}

func (m *RaidenInfo) Reset()                    { *m = RaidenInfo{} }
func (m *RaidenInfo) String() string            { return proto.CompactTextString(m) }
func (*RaidenInfo) ProtoMessage()               {}
func (*RaidenInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *RaidenInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *RaidenInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaidenInfo) GetChannels() *Channels {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *RaidenInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RaidenInfo) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

type RemoveCurrencyRequest struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
}

func (m *RemoveCurrencyRequest) Reset()                    { *m = RemoveCurrencyRequest{} }
func (m *RemoveCurrencyRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveCurrencyRequest) ProtoMessage()               {}
func (*RemoveCurrencyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *RemoveCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type RemoveCurrencyResponse struct {
}

func (m *RemoveCurrencyResponse) Reset()                    { *m = RemoveCurrencyResponse{} }
func (m *RemoveCurrencyResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveCurrencyResponse) ProtoMessage()               {}
func (*RemoveCurrencyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

type RemoveOrderRequest struct {
	// The local id of the order to remove.
	OrderId string `protobuf:"bytes,1,opt,name=order_id" json:"order_id,omitempty"`
	// The quantity to remove from the order denominated in satoshis.
	// If zero or unspecified then the entire order is removed.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity" json:"quantity,omitempty"`
}

func (m *RemoveOrderRequest) Reset()                    { *m = RemoveOrderRequest{} }
func (m *RemoveOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveOrderRequest) ProtoMessage()               {}
func (*RemoveOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *RemoveOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *RemoveOrderRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type RemoveOrderResponse struct {
	// Any portion of the order that was on hold due to ongoing swaps at the time of the request
	// and could not be removed until after the swaps finish.
	QuantityOnHold uint64 `protobuf:"varint,1,opt,name=quantity_on_hold,json=hold" json:"quantity_on_hold,omitempty"`
}

func (m *RemoveOrderResponse) Reset()                    { *m = RemoveOrderResponse{} }
func (m *RemoveOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveOrderResponse) ProtoMessage()               {}
func (*RemoveOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *RemoveOrderResponse) GetQuantityOnHold() uint64 {
	if m != nil {
		return m.QuantityOnHold
	}
	return 0
}

type RemovePairRequest struct {
	// The trading pair ticker to remove in a format such as "LTC/BTC".
	PairId string `protobuf:"bytes,1,opt,name=pair_id" json:"pair_id,omitempty"`
}

func (m *RemovePairRequest) Reset()                    { *m = RemovePairRequest{} }
func (m *RemovePairRequest) String() string            { return proto.CompactTextString(m) }
func (*RemovePairRequest) ProtoMessage()               {}
func (*RemovePairRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *RemovePairRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type RemovePairResponse struct {
}

func (m *RemovePairResponse) Reset()                    { *m = RemovePairResponse{} }
func (m *RemovePairResponse) String() string            { return proto.CompactTextString(m) }
func (*RemovePairResponse) ProtoMessage()               {}
func (*RemovePairResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

type DiscoverNodesRequest struct {
	// The node pub key of the peer to discover nodes from.
	PeerPubKey string `protobuf:"bytes,1,opt,name=peer_pub_key" json:"peer_pub_key,omitempty"`
}

func (m *DiscoverNodesRequest) Reset()                    { *m = DiscoverNodesRequest{} }
func (m *DiscoverNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*DiscoverNodesRequest) ProtoMessage()               {}
func (*DiscoverNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *DiscoverNodesRequest) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

type DiscoverNodesResponse struct {
	NumNodes uint32 `protobuf:"varint,1,opt,name=num_nodes" json:"num_nodes,omitempty"`
}

func (m *DiscoverNodesResponse) Reset()                    { *m = DiscoverNodesResponse{} }
func (m *DiscoverNodesResponse) String() string            { return proto.CompactTextString(m) }
func (*DiscoverNodesResponse) ProtoMessage()               {}
func (*DiscoverNodesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *DiscoverNodesResponse) GetNumNodes() uint32 {
	if m != nil {
		return m.NumNodes
	}
	return 0
}

type ShutdownRequest struct {
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

type ShutdownResponse struct {
}

func (m *ShutdownResponse) Reset()                    { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()               {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

type SubscribeOrdersRequest struct {
	// Whether to transmit all existing active orders upon establishing the stream.
	Existing bool `protobuf:"varint,1,opt,name=existing" json:"existing,omitempty"`
}

func (m *SubscribeOrdersRequest) Reset()                    { *m = SubscribeOrdersRequest{} }
func (m *SubscribeOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeOrdersRequest) ProtoMessage()               {}
func (*SubscribeOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *SubscribeOrdersRequest) GetExisting() bool {
	if m != nil {
		return m.Existing
	}
	return false
}

type SubscribeSwapsRequest struct {
	// Whether to include the results for swaps initiated via the PlaceOrder calls.
	// These swap results are also returned in the responses for the respective calls.
	IncludeTaker bool `protobuf:"varint,1,opt,name=include_taker" json:"include_taker,omitempty"`
}

func (m *SubscribeSwapsRequest) Reset()                    { *m = SubscribeSwapsRequest{} }
func (m *SubscribeSwapsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeSwapsRequest) ProtoMessage()               {}
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *SubscribeSwapsRequest) GetIncludeTaker() bool {
	if m != nil {
		return m.IncludeTaker
	}
	return false
}

type SwapSuccess struct {
	// The global UUID for the order that was swapped.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	// The local id for the order that was swapped.
	LocalId string `protobuf:"bytes,2,opt,name=local_id" json:"local_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The order quantity that was swapped.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity" json:"quantity,omitempty"`
	// The hex-encoded payment hash for the swap.
	RHash string `protobuf:"bytes,5,opt,name=r_hash" json:"r_hash,omitempty"`
	// The amount received denominated in satoshis.
	AmountReceived uint64 `protobuf:"varint,8,opt,name=amount_received" json:"amount_received,omitempty"`
	// The amount sent denominated in satoshis.
	AmountSent uint64 `protobuf:"varint,9,opt,name=amount_sent" json:"amount_sent,omitempty"`
	// The node pub key of the peer that executed this order.
	PeerPubKey string `protobuf:"bytes,10,opt,name=peer_pub_key" json:"peer_pub_key,omitempty"`
	// Our role in the swap, either MAKER or TAKER.
	Role SwapSuccess_Role `protobuf:"varint,11,opt,name=role,enum=xudrpc.SwapSuccess_Role" json:"role,omitempty"`
	// The ticker symbol of the currency received.
	CurrencyReceived string `protobuf:"bytes,12,opt,name=currency_received" json:"currency_received,omitempty"`
	// The ticker symbol of the currency sent.
	CurrencySent string `protobuf:"bytes,13,opt,name=currency_sent" json:"currency_sent,omitempty"`
	// The hex-encoded preimage.
	RPreimage string `protobuf:"bytes,14,opt,name=r_preimage" json:"r_preimage,omitempty"`
	// The price used for the swap.
	Price float64 `protobuf:"fixed64,15,opt,name=price" json:"price,omitempty"`
}

func (m *SwapSuccess) Reset()                    { *m = SwapSuccess{} }
func (m *SwapSuccess) String() string            { return proto.CompactTextString(m) }
func (*SwapSuccess) ProtoMessage()               {}
func (*SwapSuccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *SwapSuccess) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapSuccess) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *SwapSuccess) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapSuccess) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *SwapSuccess) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *SwapSuccess) GetAmountReceived() uint64 {
	if m != nil {
		return m.AmountReceived
	}
	return 0
}

func (m *SwapSuccess) GetAmountSent() uint64 {
	if m != nil {
		return m.AmountSent
	}
	return 0
}

func (m *SwapSuccess) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *SwapSuccess) GetRole() SwapSuccess_Role {
	if m != nil {
		return m.Role
	}
	return SwapSuccess_TAKER
}

func (m *SwapSuccess) GetCurrencyReceived() string {
	if m != nil {
		return m.CurrencyReceived
	}
	return ""
}

func (m *SwapSuccess) GetCurrencySent() string {
	if m != nil {
		return m.CurrencySent
	}
	return ""
}

func (m *SwapSuccess) GetRPreimage() string {
	if m != nil {
		return m.RPreimage
	}
	return ""
}

func (m *SwapSuccess) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type UnbanRequest struct {
	// The node pub key of the peer to unban.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// Whether to attempt to connect to the peer after it is unbanned.
	Reconnect bool `protobuf:"varint,2,opt,name=reconnect" json:"reconnect,omitempty"`
}

func (m *UnbanRequest) Reset()                    { *m = UnbanRequest{} }
func (m *UnbanRequest) String() string            { return proto.CompactTextString(m) }
func (*UnbanRequest) ProtoMessage()               {}
func (*UnbanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *UnbanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *UnbanRequest) GetReconnect() bool {
	if m != nil {
		return m.Reconnect
	}
	return false
}

type UnbanResponse struct {
}

func (m *UnbanResponse) Reset()                    { *m = UnbanResponse{} }
func (m *UnbanResponse) String() string            { return proto.CompactTextString(m) }
func (*UnbanResponse) ProtoMessage()               {}
func (*UnbanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func init() {
	proto.RegisterType((*CreateNodeRequest)(nil), "xudrpc.CreateNodeRequest")
	proto.RegisterType((*CreateNodeResponse)(nil), "xudrpc.CreateNodeResponse")
	proto.RegisterType((*UnlockNodeRequest)(nil), "xudrpc.UnlockNodeRequest")
	proto.RegisterType((*UnlockNodeResponse)(nil), "xudrpc.UnlockNodeResponse")
	proto.RegisterType((*Currency)(nil), "xudrpc.Currency")
	proto.RegisterType((*AddCurrencyResponse)(nil), "xudrpc.AddCurrencyResponse")
	proto.RegisterType((*AddPairRequest)(nil), "xudrpc.AddPairRequest")
	proto.RegisterType((*AddPairResponse)(nil), "xudrpc.AddPairResponse")
	proto.RegisterType((*BanRequest)(nil), "xudrpc.BanRequest")
	proto.RegisterType((*BanResponse)(nil), "xudrpc.BanResponse")
	proto.RegisterType((*Chain)(nil), "xudrpc.Chain")
	proto.RegisterType((*Balance)(nil), "xudrpc.Balance")
	proto.RegisterType((*GetBalanceRequest)(nil), "xudrpc.GetBalanceRequest")
	proto.RegisterType((*GetBalanceResponse)(nil), "xudrpc.GetBalanceResponse")
	proto.RegisterType((*OpenChannelRequest)(nil), "xudrpc.OpenChannelRequest")
	proto.RegisterType((*OpenChannelResponse)(nil), "xudrpc.OpenChannelResponse")
	proto.RegisterType((*ConnectRequest)(nil), "xudrpc.ConnectRequest")
	proto.RegisterType((*ConnectResponse)(nil), "xudrpc.ConnectResponse")
	proto.RegisterType((*SwapFailure)(nil), "xudrpc.SwapFailure")
	proto.RegisterType((*GetInfoRequest)(nil), "xudrpc.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "xudrpc.GetInfoResponse")
	proto.RegisterType((*GetNodeInfoRequest)(nil), "xudrpc.GetNodeInfoRequest")
	proto.RegisterType((*GetNodeInfoResponse)(nil), "xudrpc.GetNodeInfoResponse")
	proto.RegisterType((*ListOrdersRequest)(nil), "xudrpc.ListOrdersRequest")
	proto.RegisterType((*ListOrdersResponse)(nil), "xudrpc.ListOrdersResponse")
	proto.RegisterType((*ListCurrenciesRequest)(nil), "xudrpc.ListCurrenciesRequest")
	proto.RegisterType((*ListCurrenciesResponse)(nil), "xudrpc.ListCurrenciesResponse")
	proto.RegisterType((*ListPairsRequest)(nil), "xudrpc.ListPairsRequest")
	proto.RegisterType((*ListPairsResponse)(nil), "xudrpc.ListPairsResponse")
	proto.RegisterType((*ListPeersRequest)(nil), "xudrpc.ListPeersRequest")
	proto.RegisterType((*ListPeersResponse)(nil), "xudrpc.ListPeersResponse")
	proto.RegisterType((*ListTradesRequest)(nil), "xudrpc.ListTradesRequest")
	proto.RegisterType((*ListTradesResponse)(nil), "xudrpc.ListTradesResponse")
	proto.RegisterType((*Channels)(nil), "xudrpc.Channels")
	proto.RegisterType((*LndInfo)(nil), "xudrpc.LndInfo")
	proto.RegisterType((*Order)(nil), "xudrpc.Order")
	proto.RegisterType((*Trade)(nil), "xudrpc.Trade")
	proto.RegisterType((*OrderUpdate)(nil), "xudrpc.OrderUpdate")
	proto.RegisterType((*OrderRemoval)(nil), "xudrpc.OrderRemoval")
	proto.RegisterType((*Orders)(nil), "xudrpc.Orders")
	proto.RegisterType((*OrdersCount)(nil), "xudrpc.OrdersCount")
	proto.RegisterType((*Peer)(nil), "xudrpc.Peer")
	proto.RegisterType((*PlaceOrderRequest)(nil), "xudrpc.PlaceOrderRequest")
	proto.RegisterType((*PlaceOrderResponse)(nil), "xudrpc.PlaceOrderResponse")
	proto.RegisterType((*PlaceOrderEvent)(nil), "xudrpc.PlaceOrderEvent")
	proto.RegisterType((*RaidenInfo)(nil), "xudrpc.RaidenInfo")
	proto.RegisterType((*RemoveCurrencyRequest)(nil), "xudrpc.RemoveCurrencyRequest")
	proto.RegisterType((*RemoveCurrencyResponse)(nil), "xudrpc.RemoveCurrencyResponse")
	proto.RegisterType((*RemoveOrderRequest)(nil), "xudrpc.RemoveOrderRequest")
	proto.RegisterType((*RemoveOrderResponse)(nil), "xudrpc.RemoveOrderResponse")
	proto.RegisterType((*RemovePairRequest)(nil), "xudrpc.RemovePairRequest")
	proto.RegisterType((*RemovePairResponse)(nil), "xudrpc.RemovePairResponse")
	proto.RegisterType((*DiscoverNodesRequest)(nil), "xudrpc.DiscoverNodesRequest")
	proto.RegisterType((*DiscoverNodesResponse)(nil), "xudrpc.DiscoverNodesResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "xudrpc.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "xudrpc.ShutdownResponse")
	proto.RegisterType((*SubscribeOrdersRequest)(nil), "xudrpc.SubscribeOrdersRequest")
	proto.RegisterType((*SubscribeSwapsRequest)(nil), "xudrpc.SubscribeSwapsRequest")
	proto.RegisterType((*SwapSuccess)(nil), "xudrpc.SwapSuccess")
	proto.RegisterType((*UnbanRequest)(nil), "xudrpc.UnbanRequest")
	proto.RegisterType((*UnbanResponse)(nil), "xudrpc.UnbanResponse")
	proto.RegisterEnum("xudrpc.OrderSide", OrderSide_name, OrderSide_value)
	proto.RegisterEnum("xudrpc.Currency_SwapClient", Currency_SwapClient_name, Currency_SwapClient_value)
	proto.RegisterEnum("xudrpc.SwapSuccess_Role", SwapSuccess_Role_name, SwapSuccess_Role_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for XudInit service

type XudInitClient interface {
	// Creates an xud identity node key and underlying wallets. The node key and
	// wallets are derived from a single seed and encrypted using a single
	// password provided as a parameter to the call.
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error)
	// Unlocks and decrypts the xud node key and any underlying wallets.
	UnlockNode(ctx context.Context, in *UnlockNodeRequest, opts ...grpc.CallOption) (*UnlockNodeResponse, error)
}

type xudInitClient struct {
	cc *grpc.ClientConn
}

func NewXudInitClient(cc *grpc.ClientConn) XudInitClient {
	return &xudInitClient{cc}
}

func (c *xudInitClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error) {
	out := new(CreateNodeResponse)
	err := grpc.Invoke(ctx, "/xudrpc.XudInit/CreateNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudInitClient) UnlockNode(ctx context.Context, in *UnlockNodeRequest, opts ...grpc.CallOption) (*UnlockNodeResponse, error) {
	out := new(UnlockNodeResponse)
	err := grpc.Invoke(ctx, "/xudrpc.XudInit/UnlockNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XudInit service

type XudInitServer interface {
	// Creates an xud identity node key and underlying wallets. The node key and
	// wallets are derived from a single seed and encrypted using a single
	// password provided as a parameter to the call.
	CreateNode(context.Context, *CreateNodeRequest) (*CreateNodeResponse, error)
	// Unlocks and decrypts the xud node key and any underlying wallets.
	UnlockNode(context.Context, *UnlockNodeRequest) (*UnlockNodeResponse, error)
}

func RegisterXudInitServer(s *grpc.Server, srv XudInitServer) {
	s.RegisterService(&_XudInit_serviceDesc, srv)
}

func _XudInit_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/CreateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).CreateNode(ctx, req.(*CreateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XudInit_UnlockNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).UnlockNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/UnlockNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).UnlockNode(ctx, req.(*UnlockNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _XudInit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.XudInit",
	HandlerType: (*XudInitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNode",
			Handler:    _XudInit_CreateNode_Handler,
		},
		{
			MethodName: "UnlockNode",
			Handler:    _XudInit_UnlockNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "xudrpc.proto",
}

// Client API for Xud service

type XudClient interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	AddCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error)
	// Gets the total balance available across all payment channels and wallets for one or all currencies.
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	// Opens a payment channel to a peer with the given node pub key for the specified amount and currency.
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error)
	// Gets general information about this node.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// Gets general information about a node.
	GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error)
	// The synchronous non-streaming version of PlaceOrder.
	PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error)
	// Discover nodes from a specific peer and apply new connections
	DiscoverNodes(ctx context.Context, in *DiscoverNodesRequest, opts ...grpc.CallOption) (*DiscoverNodesResponse, error)
	// Begin gracefully shutting down xud.
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Subscribes to orders being added to and removed from the order book. This call allows the client
	// to maintain an up-to-date view of the order book. For example, an exchange that wants to show
	// its users a real time view of the orders available to them would subscribe to this streaming
	// call to be alerted as new orders are added and expired orders are removed.
	SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeOrdersClient, error)
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error)
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error)
}

type xudClient struct {
	cc *grpc.ClientConn
}

func NewXudClient(cc *grpc.ClientConn) XudClient {
	return &xudClient{cc}
}

func (c *xudClient) AddCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*AddCurrencyResponse, error) {
	out := new(AddCurrencyResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/AddCurrency", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error) {
	out := new(AddPairResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/AddPair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error) {
	out := new(RemoveOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemoveOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	out := new(GetBalanceResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error) {
	out := new(OpenChannelResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/OpenChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error) {
	out := new(BanResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Ban", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error) {
	out := new(UnbanResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Unban", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error) {
	out := new(GetNodeInfoResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetNodeInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error) {
	out := new(ListCurrenciesResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListCurrencies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error) {
	out := new(ListPairsResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListPairs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error) {
	out := new(ListTradesResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListTrades", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[0], c.cc, "/xudrpc.Xud/PlaceOrder", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudPlaceOrderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_PlaceOrderClient interface {
	Recv() (*PlaceOrderEvent, error)
	grpc.ClientStream
}

type xudPlaceOrderClient struct {
	grpc.ClientStream
}

func (x *xudPlaceOrderClient) Recv() (*PlaceOrderEvent, error) {
	m := new(PlaceOrderEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/PlaceOrderSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error) {
	out := new(RemoveCurrencyResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemoveCurrency", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error) {
	out := new(RemovePairResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemovePair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) DiscoverNodes(ctx context.Context, in *DiscoverNodesRequest, opts ...grpc.CallOption) (*DiscoverNodesResponse, error) {
	out := new(DiscoverNodesResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/DiscoverNodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeOrdersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[1], c.cc, "/xudrpc.Xud/SubscribeOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeOrdersClient interface {
	Recv() (*OrderUpdate, error)
	grpc.ClientStream
}

type xudSubscribeOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeOrdersClient) Recv() (*OrderUpdate, error) {
	m := new(OrderUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[2], c.cc, "/xudrpc.Xud/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapsClient interface {
	Recv() (*SwapSuccess, error)
	grpc.ClientStream
}

type xudSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapsClient) Recv() (*SwapSuccess, error) {
	m := new(SwapSuccess)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[3], c.cc, "/xudrpc.Xud/SubscribeSwapFailures", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapFailuresClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapFailuresClient interface {
	Recv() (*SwapFailure, error)
	grpc.ClientStream
}

type xudSubscribeSwapFailuresClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapFailuresClient) Recv() (*SwapFailure, error) {
	m := new(SwapFailure)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Xud service

type XudServer interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	AddCurrency(context.Context, *Currency) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	AddPair(context.Context, *AddPairRequest) (*AddPairResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	RemoveOrder(context.Context, *RemoveOrderRequest) (*RemoveOrderResponse, error)
	// Gets the total balance available across all payment channels and wallets for one or all currencies.
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	// Opens a payment channel to a peer with the given node pub key for the specified amount and currency.
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	Ban(context.Context, *BanRequest) (*BanResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	Unban(context.Context, *UnbanRequest) (*UnbanResponse, error)
	// Gets general information about this node.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// Gets general information about a node.
	GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	ListCurrencies(context.Context, *ListCurrenciesRequest) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	ListPairs(context.Context, *ListPairsRequest) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	ListTrades(context.Context, *ListTradesRequest) (*ListTradesResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(*PlaceOrderRequest, Xud_PlaceOrderServer) error
	// The synchronous non-streaming version of PlaceOrder.
	PlaceOrderSync(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	RemoveCurrency(context.Context, *RemoveCurrencyRequest) (*RemoveCurrencyResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	RemovePair(context.Context, *RemovePairRequest) (*RemovePairResponse, error)
	// Discover nodes from a specific peer and apply new connections
	DiscoverNodes(context.Context, *DiscoverNodesRequest) (*DiscoverNodesResponse, error)
	// Begin gracefully shutting down xud.
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Subscribes to orders being added to and removed from the order book. This call allows the client
	// to maintain an up-to-date view of the order book. For example, an exchange that wants to show
	// its users a real time view of the orders available to them would subscribe to this streaming
	// call to be alerted as new orders are added and expired orders are removed.
	SubscribeOrders(*SubscribeOrdersRequest, Xud_SubscribeOrdersServer) error
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(*SubscribeSwapsRequest, Xud_SubscribeSwapsServer) error
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(*SubscribeSwapsRequest, Xud_SubscribeSwapFailuresServer) error
}

func RegisterXudServer(s *grpc.Server, srv XudServer) {
	s.RegisterService(&_Xud_serviceDesc, srv)
}

func _Xud_AddCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Currency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddCurrency(ctx, req.(*Currency))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_AddPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddPair(ctx, req.(*AddPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveOrder(ctx, req.(*RemoveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Ban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Ban(ctx, req.(*BanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Unban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Unban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Unban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Unban(ctx, req.(*UnbanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetNodeInfo(ctx, req.(*GetNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCurrenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListCurrencies(ctx, req.(*ListCurrenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPairs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPairs(ctx, req.(*ListPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListTrades(ctx, req.(*ListTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_PlaceOrder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlaceOrderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).PlaceOrder(m, &xudPlaceOrderServer{stream})
}

type Xud_PlaceOrderServer interface {
	Send(*PlaceOrderEvent) error
	grpc.ServerStream
}

type xudPlaceOrderServer struct {
	grpc.ServerStream
}

func (x *xudPlaceOrderServer) Send(m *PlaceOrderEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_PlaceOrderSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).PlaceOrderSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/PlaceOrderSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).PlaceOrderSync(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveCurrency(ctx, req.(*RemoveCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemovePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemovePair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemovePair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemovePair(ctx, req.(*RemovePairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_DiscoverNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).DiscoverNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/DiscoverNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).DiscoverNodes(ctx, req.(*DiscoverNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_SubscribeOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeOrders(m, &xudSubscribeOrdersServer{stream})
}

type Xud_SubscribeOrdersServer interface {
	Send(*OrderUpdate) error
	grpc.ServerStream
}

type xudSubscribeOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeOrdersServer) Send(m *OrderUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwaps(m, &xudSubscribeSwapsServer{stream})
}

type Xud_SubscribeSwapsServer interface {
	Send(*SwapSuccess) error
	grpc.ServerStream
}

type xudSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapsServer) Send(m *SwapSuccess) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwapFailures_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwapFailures(m, &xudSubscribeSwapFailuresServer{stream})
}

type Xud_SubscribeSwapFailuresServer interface {
	Send(*SwapFailure) error
	grpc.ServerStream
}

type xudSubscribeSwapFailuresServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapFailuresServer) Send(m *SwapFailure) error {
	return x.ServerStream.SendMsg(m)
}

var _Xud_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.Xud",
	HandlerType: (*XudServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCurrency",
			Handler:    _Xud_AddCurrency_Handler,
		},
		{
			MethodName: "AddPair",
			Handler:    _Xud_AddPair_Handler,
		},
		{
			MethodName: "RemoveOrder",
			Handler:    _Xud_RemoveOrder_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _Xud_GetBalance_Handler,
		},
		{
			MethodName: "OpenChannel",
			Handler:    _Xud_OpenChannel_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Xud_Connect_Handler,
		},
		{
			MethodName: "Ban",
			Handler:    _Xud_Ban_Handler,
		},
		{
			MethodName: "Unban",
			Handler:    _Xud_Unban_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Xud_GetInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Xud_GetNodeInfo_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Xud_ListOrders_Handler,
		},
		{
			MethodName: "ListCurrencies",
			Handler:    _Xud_ListCurrencies_Handler,
		},
		{
			MethodName: "ListPairs",
			Handler:    _Xud_ListPairs_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Xud_ListPeers_Handler,
		},
		{
			MethodName: "ListTrades",
			Handler:    _Xud_ListTrades_Handler,
		},
		{
			MethodName: "PlaceOrderSync",
			Handler:    _Xud_PlaceOrderSync_Handler,
		},
		{
			MethodName: "RemoveCurrency",
			Handler:    _Xud_RemoveCurrency_Handler,
		},
		{
			MethodName: "RemovePair",
			Handler:    _Xud_RemovePair_Handler,
		},
		{
			MethodName: "DiscoverNodes",
			Handler:    _Xud_DiscoverNodes_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Xud_Shutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PlaceOrder",
			Handler:       _Xud_PlaceOrder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeOrders",
			Handler:       _Xud_SubscribeOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Xud_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwapFailures",
			Handler:       _Xud_SubscribeSwapFailures_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "xudrpc.proto",
}

func init() { proto.RegisterFile("xudrpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2947 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x1a, 0x4b, 0x73, 0x1c, 0x47,
	0x59, 0xb3, 0x0f, 0xed, 0xea, 0x5b, 0xed, 0xab, 0xf5, 0xf0, 0x7a, 0xe3, 0xb8, 0x9c, 0xc6, 0x09,
	0x4e, 0x70, 0x64, 0xa3, 0x90, 0x72, 0x9c, 0x10, 0x0a, 0x4b, 0x31, 0xb1, 0x13, 0x25, 0x71, 0x8d,
	0x62, 0x62, 0xaa, 0x20, 0x53, 0xb3, 0x33, 0x1d, 0x6b, 0xf0, 0xa8, 0x67, 0x33, 0x0f, 0x29, 0xe2,
	0x44, 0xa5, 0xf8, 0x07, 0x39, 0x70, 0xa1, 0x0a, 0x8a, 0x03, 0x17, 0xce, 0x5c, 0xf8, 0x01, 0xfc,
	0x01, 0xaa, 0x80, 0x03, 0x47, 0xae, 0xfc, 0x07, 0xaa, 0x5f, 0xd3, 0xdd, 0x33, 0x23, 0xc7, 0xae,
	0xe2, 0x36, 0xfd, 0xf5, 0xd7, 0xdf, 0xa3, 0xbf, 0x67, 0x7f, 0xbb, 0xb0, 0xfe, 0x55, 0x11, 0xa6,
	0xcb, 0x60, 0x67, 0x99, 0x26, 0x79, 0x82, 0x56, 0xc5, 0x6a, 0x3e, 0xf5, 0x29, 0x4d, 0x72, 0x3f,
	0x8f, 0x12, 0x9a, 0x89, 0x2d, 0x7c, 0x03, 0xa6, 0xfb, 0x29, 0xf1, 0x73, 0xf2, 0x71, 0x12, 0x12,
	0x97, 0x7c, 0x59, 0x90, 0x2c, 0x47, 0x73, 0xe8, 0x2f, 0xfd, 0x2c, 0x3b, 0x4d, 0xd2, 0x70, 0xe6,
	0x5c, 0x71, 0xae, 0xad, 0xb9, 0xe5, 0x1a, 0x7f, 0xe3, 0x00, 0x32, 0x4f, 0x64, 0xcb, 0x84, 0x66,
	0x04, 0x7d, 0x07, 0x86, 0x19, 0x21, 0xa1, 0x77, 0x4c, 0xc9, 0x71, 0x42, 0xa3, 0x60, 0xe6, 0x5c,
	0x69, 0x5f, 0x5b, 0x73, 0xd7, 0x19, 0xf0, 0x23, 0x09, 0x43, 0xaf, 0xc2, 0x24, 0xa2, 0x51, 0x1e,
	0xf9, 0x71, 0xf4, 0x2b, 0x12, 0x7a, 0x31, 0x0d, 0xb3, 0x59, 0x8b, 0xe3, 0x8d, 0x0d, 0xf8, 0x01,
	0x0d, 0x33, 0xf4, 0x3a, 0x20, 0x13, 0x35, 0xf5, 0xa3, 0x90, 0xd0, 0x59, 0xfb, 0x8a, 0x73, 0xad,
	0xef, 0x4e, 0x8d, 0x1d, 0x97, 0x6f, 0x30, 0x35, 0x1e, 0xd2, 0x38, 0x09, 0x9e, 0x3c, 0xab, 0x1a,
	0x0b, 0x40, 0xe6, 0x01, 0xad, 0x45, 0xc1, 0xa1, 0x4a, 0x3a, 0xa9, 0x85, 0x02, 0x72, 0xd1, 0xbe,
	0x0b, 0xe3, 0x12, 0x49, 0xca, 0xd5, 0xe2, 0x72, 0x8d, 0x14, 0x58, 0x0a, 0xf5, 0x0f, 0x07, 0xfa,
	0xfb, 0x45, 0x9a, 0x12, 0x1a, 0x9c, 0x31, 0x61, 0x02, 0xf9, 0xad, 0x84, 0x51, 0x6b, 0xf4, 0x2e,
	0x0c, 0xb2, 0x53, 0x7f, 0xe9, 0x05, 0x71, 0x44, 0x68, 0xce, 0xa9, 0x8d, 0x76, 0x5f, 0xd8, 0x91,
	0x36, 0x54, 0x24, 0x76, 0x0e, 0x4f, 0xfd, 0xe5, 0x3e, 0x47, 0x71, 0x4d, 0x7c, 0x74, 0x15, 0x86,
	0x79, 0xf2, 0x84, 0x50, 0xcf, 0x0f, 0xc3, 0x94, 0x64, 0x19, 0xbf, 0xa6, 0x35, 0xd7, 0x06, 0xa2,
	0x57, 0x60, 0x14, 0x92, 0x20, 0x3a, 0xf6, 0x63, 0x6f, 0x19, 0xfb, 0x01, 0xc9, 0x66, 0x9d, 0x2b,
	0xce, 0xb5, 0xa1, 0x5b, 0x81, 0xe2, 0x97, 0x00, 0x34, 0x23, 0xd4, 0x83, 0xf6, 0xc1, 0xc7, 0xef,
	0x4d, 0x56, 0x10, 0xc0, 0xaa, 0x7b, 0xe7, 0xfe, 0x7b, 0x77, 0x3f, 0x9e, 0x38, 0x78, 0x0b, 0x36,
	0xee, 0x84, 0xa1, 0x92, 0x4b, 0xdd, 0x1e, 0xfe, 0x1c, 0x46, 0x77, 0xc2, 0xf0, 0x81, 0x1f, 0xa5,
	0xca, 0x02, 0x57, 0x61, 0xb8, 0xf0, 0x33, 0xe2, 0x55, 0x34, 0xb7, 0x81, 0x4c, 0xb2, 0x2f, 0x8b,
	0x24, 0x37, 0xd0, 0x5a, 0x1c, 0xad, 0x02, 0xc5, 0x53, 0x18, 0x97, 0xf4, 0x25, 0xcb, 0x9b, 0x00,
	0x7b, 0x3e, 0x55, 0xec, 0x30, 0xac, 0xd3, 0x24, 0x24, 0xde, 0xb2, 0x58, 0x78, 0x4f, 0x88, 0xe2,
	0x66, 0xc1, 0xf0, 0x10, 0x06, 0xfc, 0x84, 0x24, 0x70, 0x0b, 0xba, 0xfb, 0x47, 0x7e, 0x44, 0xd1,
	0x26, 0x74, 0x03, 0xf6, 0x21, 0x0f, 0x89, 0x05, 0x9a, 0x41, 0x8f, 0x92, 0xfc, 0x34, 0x49, 0x9f,
	0x48, 0x99, 0xd4, 0x12, 0x7f, 0x06, 0xbd, 0x3d, 0x3f, 0xf6, 0x69, 0x40, 0x18, 0xd2, 0x42, 0x7c,
	0xf2, 0xc3, 0x1d, 0x57, 0x2d, 0xd1, 0x2e, 0x6c, 0x2e, 0x09, 0x0d, 0x23, 0xfa, 0xd8, 0x4b, 0x96,
	0x84, 0x7a, 0x0a, 0xad, 0xc5, 0xd1, 0x1a, 0xf7, 0x98, 0x2b, 0xbf, 0x4f, 0x72, 0x49, 0xdb, 0x70,
	0xe5, 0xf3, 0xbc, 0x07, 0xff, 0xc9, 0x01, 0x64, 0x9e, 0x90, 0xbe, 0xbc, 0x07, 0x7d, 0x49, 0x52,
	0xb8, 0xf1, 0x60, 0xf7, 0x9a, 0xf2, 0xa8, 0x3a, 0xf6, 0x8e, 0x5c, 0x67, 0x77, 0x69, 0x9e, 0x9e,
	0xb9, 0xab, 0x49, 0x1a, 0x92, 0x34, 0x9b, 0x1f, 0xc0, 0xd0, 0xda, 0x40, 0x13, 0x68, 0xeb, 0x8b,
	0x65, 0x9f, 0xe8, 0x65, 0xe8, 0x9e, 0xf8, 0x71, 0x21, 0x74, 0x1a, 0xec, 0x8e, 0x15, 0x0f, 0xc5,
	0x40, 0xec, 0xbe, 0xdd, 0x7a, 0xcb, 0xc1, 0x31, 0xa0, 0x4f, 0x96, 0x84, 0xee, 0x1f, 0xf9, 0x94,
	0x92, 0xf8, 0x5b, 0x8c, 0xb6, 0x24, 0x24, 0x55, 0x30, 0x4b, 0xfd, 0x56, 0x25, 0x78, 0xb6, 0x61,
	0xd5, 0x3f, 0x4e, 0x0a, 0x9a, 0x73, 0xb7, 0x6f, 0xbb, 0x72, 0xc5, 0x9c, 0xd4, 0xe2, 0x26, 0x0d,
	0x7e, 0x1d, 0x46, 0xfb, 0x09, 0xa5, 0x24, 0xc8, 0x8d, 0xbb, 0xe5, 0x02, 0x14, 0x69, 0xa4, 0xee,
	0x56, 0xad, 0x99, 0xcb, 0x95, 0xd8, 0x92, 0xc0, 0x9f, 0x1d, 0x18, 0xb0, 0x00, 0xf9, 0x89, 0x1f,
	0xc5, 0x45, 0x4a, 0xd8, 0x71, 0x7e, 0x5b, 0x5e, 0x54, 0x66, 0x19, 0xb5, 0x66, 0x9e, 0xb1, 0xf4,
	0x23, 0xbe, 0x25, 0xdd, 0x47, 0x2e, 0xd9, 0xa9, 0x2f, 0x0b, 0x9f, 0xe6, 0x51, 0x7e, 0xc6, 0xe5,
	0xee, 0xb8, 0xe5, 0x9a, 0xdd, 0x88, 0xa9, 0x3d, 0x8f, 0xd3, 0xea, 0x8d, 0xbc, 0x02, 0xa3, 0x2f,
	0x84, 0x00, 0x5e, 0x4a, 0xfc, 0x2c, 0xa1, 0xb3, 0xae, 0x88, 0x19, 0x1b, 0x8a, 0x27, 0x30, 0x7a,
	0x9f, 0xe4, 0xf7, 0xe9, 0x17, 0x89, 0x54, 0x17, 0xff, 0xb3, 0x0d, 0xe3, 0x12, 0x24, 0x7d, 0x65,
	0x06, 0xbd, 0x13, 0x92, 0x66, 0x51, 0xa2, 0xdc, 0x5f, 0x2d, 0x6b, 0xd6, 0x69, 0xd5, 0x43, 0x0a,
	0x21, 0xe8, 0x14, 0x69, 0xc4, 0xd2, 0x0e, 0x4b, 0x96, 0xfc, 0x1b, 0x5d, 0x82, 0x35, 0x5a, 0x1c,
	0x7b, 0x4c, 0x66, 0x95, 0x68, 0x34, 0xa0, 0xdc, 0xf5, 0xa3, 0x34, 0xe3, 0x82, 0xab, 0x5d, 0x06,
	0x40, 0xdf, 0x03, 0xe9, 0x7f, 0xb3, 0x55, 0xee, 0x53, 0x1b, 0xca, 0xa7, 0x3e, 0xe1, 0xd0, 0x7d,
	0x66, 0x5e, 0xe5, 0xa2, 0x68, 0x17, 0xda, 0x31, 0x0d, 0x67, 0x3d, 0xee, 0xe1, 0x57, 0x0c, 0x0f,
	0x37, 0x15, 0xdc, 0x39, 0xa0, 0xa1, 0xf0, 0x6c, 0x86, 0x8c, 0x5e, 0x83, 0x55, 0x99, 0xb8, 0xfb,
	0x9c, 0x01, 0x52, 0xc7, 0x44, 0xe2, 0xe6, 0x27, 0x25, 0x06, 0xcb, 0x0b, 0x7e, 0x1c, 0xf9, 0xd9,
	0x6c, 0x4d, 0xe4, 0x05, 0xbe, 0x30, 0xf3, 0x02, 0x58, 0x79, 0x01, 0xdd, 0x84, 0x0d, 0x15, 0xd6,
	0x3c, 0x47, 0x1f, 0xf9, 0xd9, 0x11, 0xc9, 0x66, 0x03, 0x7e, 0x37, 0x4d, 0x5b, 0xf3, 0xf7, 0xa1,
	0xaf, 0xc4, 0x7b, 0x8e, 0xf8, 0x3a, 0xa0, 0x21, 0x97, 0xd3, 0x88, 0xaf, 0xb7, 0x78, 0x1e, 0x60,
	0x05, 0xcd, 0xb0, 0xf7, 0x33, 0x25, 0x45, 0x17, 0x36, 0xac, 0x93, 0x65, 0x39, 0x1c, 0xa7, 0x64,
	0x59, 0x88, 0x8e, 0xe1, 0x30, 0x48, 0x52, 0x91, 0xe0, 0xa6, 0x2e, 0x68, 0x30, 0x8b, 0xbf, 0x05,
	0x0b, 0xb1, 0x50, 0x56, 0x41, 0xb9, 0xc2, 0x19, 0x4c, 0x0f, 0xa2, 0x2c, 0x17, 0x36, 0x53, 0xc2,
	0x18, 0x01, 0xe1, 0xd8, 0x01, 0xb1, 0xc3, 0x0a, 0x7e, 0x10, 0x17, 0x21, 0xf1, 0x92, 0x53, 0xea,
	0x49, 0x07, 0x10, 0x24, 0x1b, 0x76, 0x98, 0x5d, 0xe2, 0xe8, 0x38, 0x12, 0x51, 0x3f, 0x74, 0xc5,
	0x02, 0xff, 0xde, 0x01, 0x64, 0x72, 0x95, 0x8a, 0xfc, 0xa8, 0xf4, 0x28, 0x91, 0x09, 0x5f, 0x29,
	0x6f, 0xb1, 0x86, 0x2b, 0x9d, 0xcc, 0xce, 0x83, 0xf7, 0x61, 0x60, 0x80, 0x1b, 0xac, 0x74, 0xd5,
	0xb6, 0xd2, 0xc8, 0xf6, 0x58, 0xd3, 0x48, 0x17, 0x60, 0x8b, 0x31, 0x95, 0xc5, 0x33, 0x22, 0xea,
	0x6a, 0xf0, 0x07, 0xb0, 0x5d, 0xdd, 0x90, 0xd2, 0xdf, 0x04, 0x08, 0x4a, 0xa8, 0xd4, 0x60, 0x52,
	0xed, 0x0e, 0x5c, 0x03, 0x07, 0x23, 0x98, 0x30, 0x5a, 0xac, 0x54, 0x96, 0xf4, 0x5f, 0x15, 0xf6,
	0x90, 0x30, 0x49, 0x7a, 0x13, 0xba, 0x22, 0x08, 0x45, 0xa3, 0x23, 0x16, 0xe5, 0x71, 0xa2, 0x2d,
	0x87, 0x6f, 0xc9, 0xe3, 0xc4, 0xbc, 0x57, 0x0c, 0x5d, 0x11, 0xe1, 0x42, 0xa8, 0x75, 0x25, 0x14,
	0xc3, 0x72, 0xc5, 0x96, 0xe2, 0xfb, 0x69, 0xea, 0x87, 0xa5, 0xb2, 0xda, 0x7a, 0xec, 0x0e, 0xbb,
	0xca, 0x7a, 0xef, 0x08, 0xe3, 0x29, 0x54, 0xc9, 0xe4, 0x65, 0x58, 0xcd, 0x39, 0x44, 0x72, 0x19,
	0x2a, 0x2e, 0x1c, 0xcf, 0x95, 0x9b, 0x78, 0x09, 0x7d, 0x99, 0xeb, 0x33, 0x5e, 0x13, 0x82, 0x3c,
	0x3a, 0x11, 0xfe, 0x3a, 0x74, 0xe5, 0x8a, 0x65, 0xdd, 0x88, 0xca, 0x9d, 0x16, 0xdf, 0x29, 0xd7,
	0xdc, 0x35, 0x45, 0x74, 0x4a, 0x97, 0x52, 0x4b, 0x46, 0x2d, 0x88, 0x93, 0x8c, 0x84, 0x32, 0x91,
	0xc9, 0x15, 0xfe, 0xb7, 0x03, 0x3d, 0x19, 0x86, 0x0c, 0x27, 0xcb, 0xfd, 0xbc, 0xc8, 0xa4, 0x57,
	0xc8, 0x15, 0xba, 0x0e, 0xfd, 0x40, 0x4a, 0x25, 0x7d, 0x43, 0x5b, 0x4e, 0xc2, 0xdd, 0x12, 0x83,
	0xa9, 0xca, 0xfb, 0x0e, 0x91, 0x4b, 0x0d, 0x55, 0x79, 0x8f, 0xe2, 0xca, 0x4d, 0x74, 0x05, 0x06,
	0x0b, 0xd6, 0x69, 0x1e, 0x91, 0xe8, 0xf1, 0x51, 0x2e, 0xa5, 0x32, 0x41, 0x65, 0x4a, 0xee, 0x1a,
	0x29, 0xd9, 0x48, 0xf2, 0xab, 0x76, 0x92, 0x2f, 0x73, 0x5c, 0xcf, 0xc8, 0x71, 0xf8, 0x2f, 0x2d,
	0xe8, 0x72, 0xff, 0xe5, 0x5e, 0x92, 0x46, 0xb2, 0xbd, 0x71, 0x5c, 0xb1, 0xb0, 0x4a, 0x58, 0xab,
	0x52, 0xc2, 0x8c, 0x38, 0x6f, 0xdb, 0x71, 0x3e, 0x82, 0x56, 0x14, 0xca, 0x92, 0xd6, 0x8a, 0x42,
	0x74, 0xb5, 0x52, 0xec, 0x78, 0x19, 0xbb, 0xb7, 0x52, 0x29, 0x77, 0x97, 0xa0, 0x1f, 0x27, 0x81,
	0x1f, 0x33, 0x82, 0xab, 0x12, 0xa3, 0x84, 0xa0, 0xcb, 0x00, 0x01, 0x7f, 0x92, 0x84, 0x9e, 0x9f,
	0x73, 0x25, 0x3a, 0xae, 0x01, 0x41, 0x2f, 0x43, 0x27, 0x8b, 0x42, 0xc2, 0xb3, 0xfd, 0x68, 0x77,
	0x6a, 0x05, 0xe7, 0x61, 0x14, 0x12, 0x97, 0x6f, 0xb3, 0x4c, 0x19, 0x65, 0x3a, 0xc7, 0xf0, 0x8c,
	0xdf, 0x77, 0x2d, 0x18, 0xbb, 0xd8, 0xa3, 0x24, 0x0e, 0x79, 0xd6, 0xef, 0xb8, 0xfc, 0x7b, 0x6f,
	0x08, 0x03, 0x81, 0xc0, 0xab, 0x1b, 0xfe, 0xab, 0x03, 0x5d, 0xee, 0x9a, 0xe8, 0x06, 0x0c, 0x8e,
	0xfd, 0x27, 0x24, 0x95, 0xf4, 0x1c, 0x6e, 0xff, 0xa1, 0xc5, 0xde, 0x35, 0x31, 0xd0, 0x2e, 0x0c,
	0x72, 0xe3, 0x40, 0xab, 0xe9, 0xc0, 0xc8, 0xc0, 0x60, 0xca, 0x6f, 0xc3, 0x6a, 0xca, 0x4b, 0x89,
	0xbc, 0x69, 0xb9, 0xb2, 0xcc, 0xd3, 0xe1, 0x9d, 0x51, 0xa3, 0x79, 0xba, 0x96, 0x79, 0xf0, 0xd7,
	0x8e, 0x4c, 0x75, 0x0f, 0x97, 0xa1, 0x9f, 0xb3, 0xe0, 0xeb, 0x9e, 0x2f, 0xfc, 0xbd, 0x15, 0x57,
	0xec, 0xa2, 0x1f, 0xc2, 0x50, 0x08, 0x94, 0x92, 0xe3, 0xe4, 0xc4, 0x8f, 0xa5, 0xe8, 0x9b, 0xb6,
	0xe8, 0x62, 0xef, 0xde, 0x8a, 0x6b, 0x23, 0xef, 0x8d, 0x60, 0x5d, 0x00, 0x0a, 0xce, 0x14, 0xff,
	0xc1, 0x81, 0x75, 0xf3, 0x84, 0xa5, 0x8b, 0x73, 0xbe, 0xab, 0xd5, 0x7b, 0xac, 0xb2, 0x33, 0x6b,
	0x57, 0x3a, 0xb3, 0xb9, 0xe1, 0x50, 0xc2, 0x19, 0xb5, 0x3b, 0x55, 0xfd, 0xa0, 0x5b, 0xf7, 0x03,
	0x7c, 0x04, 0xab, 0x22, 0xb7, 0xa3, 0xd7, 0x01, 0x16, 0xc5, 0x99, 0x67, 0xd5, 0x97, 0x8a, 0xc9,
	0x0c, 0x04, 0xe6, 0x13, 0x19, 0x89, 0x63, 0x5d, 0xe0, 0x1a, 0xf0, 0x4d, 0x0c, 0xfc, 0x86, 0xaa,
	0x3d, 0xbc, 0xef, 0x61, 0x0e, 0xc8, 0xbc, 0x4c, 0x26, 0x36, 0xfe, 0xcd, 0xea, 0x51, 0x72, 0x4a,
	0x65, 0x46, 0x63, 0x9f, 0xf8, 0xbf, 0x2d, 0xe8, 0xb0, 0x24, 0xcc, 0x6e, 0x47, 0xbd, 0x0a, 0x65,
	0xc1, 0x55, 0xef, 0xc1, 0x67, 0xe9, 0xec, 0x7e, 0x0c, 0xeb, 0x31, 0x0d, 0xd5, 0x52, 0x65, 0xa5,
	0x4b, 0x66, 0x9a, 0x67, 0x8d, 0xc8, 0x83, 0x62, 0xf1, 0x21, 0x39, 0x93, 0x35, 0xd3, 0x3a, 0xc1,
	0xf8, 0x47, 0x74, 0x91, 0x14, 0x54, 0x5c, 0x73, 0xdf, 0x55, 0x4b, 0x5d, 0x7a, 0xba, 0x46, 0xe9,
	0x61, 0xa9, 0xed, 0xab, 0x22, 0xf4, 0xec, 0x44, 0x65, 0x82, 0xd0, 0x75, 0x98, 0x66, 0x24, 0x48,
	0x68, 0x98, 0x79, 0x81, 0x68, 0xcd, 0x49, 0xc8, 0x63, 0x7e, 0xe8, 0xd6, 0x37, 0x58, 0x9f, 0x2c,
	0x1a, 0xb9, 0xf2, 0x71, 0xdc, 0x17, 0x7d, 0xb2, 0x0d, 0x9d, 0xbf, 0x0b, 0xe3, 0x8a, 0x22, 0x0d,
	0x55, 0x7e, 0xd3, 0xac, 0xf2, 0x6b, 0x66, 0x55, 0xff, 0xa3, 0x03, 0xd3, 0x07, 0xec, 0xfd, 0x2c,
	0xdd, 0xb6, 0xac, 0x72, 0xff, 0xb7, 0xbc, 0x69, 0x3a, 0x73, 0xa7, 0xe2, 0xcc, 0x2a, 0xbf, 0x75,
	0x9f, 0x9a, 0xdf, 0xf0, 0xaf, 0x5b, 0x80, 0x4c, 0x21, 0x65, 0x7d, 0xbd, 0x0d, 0x93, 0x88, 0xe6,
	0x24, 0xa5, 0x7e, 0xec, 0x1d, 0xfb, 0x79, 0x70, 0x44, 0xce, 0x71, 0xe3, 0x1a, 0x1a, 0x7a, 0x07,
	0x46, 0xbc, 0x93, 0xcd, 0x8a, 0x20, 0x20, 0x59, 0x46, 0x94, 0x3f, 0x97, 0x1d, 0x3b, 0x7b, 0x28,
	0x1d, 0x8a, 0x4d, 0xb7, 0x82, 0x8a, 0x6e, 0xb1, 0xee, 0xf2, 0xd8, 0x8f, 0x28, 0x7f, 0x02, 0xf3,
	0x48, 0x6b, 0x37, 0x25, 0xbc, 0x2a, 0x16, 0xba, 0x0d, 0x43, 0x4e, 0x4a, 0x3e, 0x75, 0xd8, 0xfb,
	0xa2, 0xc6, 0x54, 0xbe, 0xce, 0x5c, 0x1b, 0x13, 0xff, 0xa6, 0x05, 0x63, 0x7d, 0x05, 0x77, 0x4f,
	0x08, 0xcd, 0xd1, 0x2d, 0x18, 0xd9, 0x8a, 0x9d, 0x97, 0xeb, 0x2a, 0x68, 0xe8, 0x36, 0xac, 0x9b,
	0x2a, 0xc9, 0x9c, 0xd7, 0xa4, 0x3b, 0xab, 0x67, 0x26, 0x2a, 0xba, 0xfd, 0x6c, 0xba, 0xdf, 0x5b,
	0x69, 0xd2, 0x7e, 0xdd, 0xd4, 0x89, 0x3b, 0x43, 0xb3, 0xf2, 0x25, 0x57, 0x89, 0xba, 0xd7, 0x83,
	0x2e, 0x61, 0x2a, 0xe3, 0xdf, 0x39, 0x00, 0xfa, 0xad, 0x73, 0x6e, 0xf3, 0x62, 0x24, 0x8f, 0x96,
	0x9d, 0x3c, 0xcc, 0xb6, 0xa6, 0xfd, 0xad, 0x6d, 0x8d, 0xd1, 0x79, 0x74, 0x6a, 0x9d, 0x87, 0x98,
	0xba, 0x74, 0x8d, 0xa9, 0x0b, 0x7e, 0x03, 0xb6, 0x78, 0xe6, 0x27, 0x7a, 0xc4, 0xf4, 0xed, 0x63,
	0x90, 0x19, 0x6c, 0x57, 0x0f, 0xc9, 0x17, 0xfb, 0x01, 0x20, 0xb1, 0x63, 0x05, 0xe7, 0xd3, 0xde,
	0xed, 0x4f, 0x09, 0x51, 0xfc, 0x26, 0x6c, 0x58, 0xd4, 0x64, 0x14, 0x5d, 0x86, 0x89, 0x42, 0xf1,
	0x12, 0xea, 0xf1, 0x26, 0xc1, 0xd1, 0x4d, 0x02, 0x7e, 0x1d, 0xa6, 0xe2, 0x98, 0x39, 0x1f, 0x3b,
	0xf7, 0x39, 0x84, 0x37, 0x95, 0xcc, 0xd6, 0xb8, 0xeb, 0x6d, 0xd8, 0x7c, 0x2f, 0xca, 0x82, 0xe4,
	0x84, 0xa4, 0xec, 0xb1, 0x96, 0x19, 0x6f, 0x3c, 0xab, 0x89, 0x6a, 0x98, 0xa1, 0xe0, 0x37, 0x61,
	0xab, 0x72, 0x56, 0x4a, 0x2e, 0x1f, 0xe3, 0x2c, 0xf1, 0x67, 0xb2, 0xac, 0x68, 0x00, 0x9e, 0xc2,
	0xf8, 0xf0, 0xa8, 0xc8, 0xc3, 0xe4, 0x54, 0x8d, 0xd9, 0xd8, 0xf3, 0x40, 0x83, 0xa4, 0x64, 0x3f,
	0x80, 0xed, 0xc3, 0x62, 0x91, 0x05, 0x69, 0xb4, 0x20, 0xf6, 0x93, 0x6f, 0x0e, 0x7d, 0xf2, 0x55,
	0x94, 0xe5, 0xac, 0xb1, 0x76, 0x78, 0x09, 0x28, 0xd7, 0xf8, 0x5d, 0xd8, 0x2a, 0x4f, 0x31, 0xc7,
	0xcd, 0x8c, 0xc1, 0xa1, 0x7a, 0xf3, 0xf1, 0x76, 0x47, 0x9e, 0xb4, 0x81, 0xf8, 0x5f, 0x6d, 0x31,
	0x8a, 0x91, 0x51, 0x86, 0x2e, 0xd6, 0x4c, 0xda, 0xe3, 0xeb, 0xfb, 0x76, 0xbd, 0x6f, 0x55, 0xea,
	0xfd, 0x53, 0x93, 0xae, 0xd5, 0x43, 0x99, 0xa9, 0x5a, 0xf7, 0x5d, 0x5d, 0xab, 0xef, 0xba, 0x06,
	0x63, 0x31, 0x81, 0xf2, 0x52, 0x12, 0x90, 0xe8, 0x84, 0x84, 0xbc, 0xe4, 0x74, 0xdc, 0x2a, 0x98,
	0xd5, 0x3a, 0x09, 0xca, 0x08, 0xcd, 0x79, 0xbb, 0xd9, 0x71, 0x4d, 0x50, 0xcd, 0xae, 0xd0, 0x30,
	0x09, 0xba, 0x0e, 0x9d, 0x34, 0x89, 0xc9, 0x6c, 0xc0, 0x93, 0xff, 0xac, 0x21, 0xfb, 0xec, 0xb8,
	0x49, 0x4c, 0x5c, 0x8e, 0xc5, 0xaa, 0xa7, 0x8a, 0x18, 0x2d, 0xdf, 0x3a, 0x27, 0x5b, 0xdf, 0x60,
	0x66, 0x28, 0x81, 0x5c, 0xc6, 0xa1, 0x98, 0xdf, 0x5a, 0x40, 0xd6, 0x7e, 0xa7, 0xde, 0x32, 0x25,
	0xd1, 0xb1, 0xff, 0x98, 0xcc, 0x46, 0x1c, 0xc5, 0x80, 0xe8, 0x32, 0x38, 0x36, 0xca, 0x20, 0xbe,
	0x04, 0x1d, 0x26, 0x17, 0x5a, 0x83, 0xee, 0xa7, 0x77, 0x3e, 0xbc, 0xeb, 0x4e, 0x56, 0xd8, 0xe7,
	0x47, 0xfc, 0xd3, 0xc1, 0x0f, 0x60, 0xfd, 0x21, 0x5d, 0x3c, 0xd7, 0x68, 0x97, 0x39, 0x72, 0x4a,
	0x64, 0xe9, 0x97, 0x93, 0x03, 0x0d, 0xc0, 0x63, 0x18, 0x4a, 0x8a, 0xc2, 0x65, 0x5f, 0xbb, 0x0c,
	0x6b, 0x65, 0x85, 0x44, 0x3d, 0x68, 0xef, 0x3d, 0xfc, 0xd9, 0x64, 0x05, 0xf5, 0xa1, 0x73, 0x78,
	0xf7, 0xe0, 0x60, 0xe2, 0xec, 0xfe, 0xd6, 0x81, 0xde, 0xa3, 0x22, 0xbc, 0x4f, 0xa3, 0x1c, 0xdd,
	0x05, 0xd0, 0x3f, 0x7a, 0xa0, 0x8b, 0x65, 0xae, 0xab, 0xfe, 0x74, 0x32, 0x9f, 0x37, 0x6d, 0xc9,
	0x18, 0x59, 0x61, 0x64, 0xf4, 0xaf, 0x0e, 0x9a, 0x4c, 0xed, 0xa7, 0x0b, 0x4d, 0xa6, 0xfe, 0x23,
	0x05, 0x5e, 0xd9, 0xfd, 0xdb, 0x14, 0xda, 0x8f, 0x8a, 0x10, 0x3d, 0x82, 0x81, 0x31, 0x87, 0x47,
	0xb5, 0x99, 0xc0, 0xbc, 0xfc, 0x0d, 0xa1, 0x69, 0x5c, 0x3f, 0xff, 0xfa, 0xef, 0xff, 0xf9, 0xa6,
	0xb5, 0x89, 0xc7, 0x37, 0x4e, 0xbe, 0x7f, 0xc3, 0x0f, 0x43, 0x65, 0xd4, 0xb7, 0x9d, 0xd7, 0x90,
	0x0b, 0x3d, 0x39, 0x6a, 0x47, 0xdb, 0x06, 0x0d, 0x23, 0x77, 0xcd, 0x2f, 0xd4, 0xe0, 0x92, 0xee,
	0x36, 0xa7, 0x3b, 0xc1, 0x03, 0x49, 0x97, 0x05, 0x13, 0xa3, 0xb9, 0x80, 0x81, 0x91, 0x38, 0x51,
	0xa9, 0x62, 0x3d, 0x37, 0x6b, 0xb9, 0x1b, 0x32, 0xad, 0x2d, 0x37, 0x7f, 0x42, 0x10, 0x1e, 0xe5,
	0x8c, 0xc7, 0x23, 0x00, 0x3d, 0xdc, 0xd6, 0x17, 0x5c, 0x1b, 0xa8, 0xeb, 0x0b, 0xae, 0xcf, 0xc2,
	0xf1, 0x06, 0x67, 0x30, 0x44, 0x5c, 0x01, 0x35, 0xca, 0xf7, 0x60, 0x60, 0x8c, 0x93, 0xb5, 0xf4,
	0xf5, 0x89, 0xb6, 0x96, 0xbe, 0x69, 0xfe, 0x7c, 0x81, 0x13, 0x9f, 0x0a, 0xe9, 0x93, 0x25, 0xa1,
	0xb2, 0x4a, 0xb2, 0x2b, 0x97, 0xa3, 0x66, 0x7d, 0xe5, 0xf6, 0xa4, 0x5a, 0x5f, 0x79, 0x75, 0x26,
	0x6d, 0x5d, 0xb9, 0x74, 0x78, 0x76, 0x1d, 0x7b, 0xd0, 0xde, 0xf3, 0x29, 0x42, 0x7a, 0x28, 0xaf,
	0x02, 0x6a, 0xbe, 0x61, 0xc1, 0x24, 0x1d, 0xc4, 0xe9, 0xac, 0xe3, 0x9e, 0xd0, 0x9c, 0x32, 0x1a,
	0x1f, 0x40, 0x97, 0xc7, 0x0d, 0xda, 0xd4, 0x3e, 0xa9, 0x03, 0x73, 0xbe, 0x55, 0x81, 0x4a, 0x4a,
	0x9b, 0x9c, 0xd2, 0x08, 0xaf, 0x31, 0x4a, 0x05, 0x95, 0xb4, 0x0e, 0xa0, 0x27, 0x27, 0xb3, 0x5a,
	0x47, 0x7b, 0x3c, 0xad, 0x75, 0xac, 0x8c, 0x70, 0xf1, 0x84, 0x53, 0x04, 0xd4, 0x67, 0x14, 0x23,
	0x46, 0xe2, 0xe7, 0x30, 0x30, 0xa6, 0x96, 0xc8, 0x34, 0x69, 0x65, 0x08, 0xaa, 0x4d, 0xd2, 0x30,
	0xe6, 0x54, 0xb2, 0xa2, 0x75, 0x46, 0x99, 0x65, 0x14, 0x4e, 0xfd, 0x33, 0x00, 0x3d, 0x1d, 0xd4,
	0xae, 0x54, 0x9b, 0x69, 0x6a, 0x57, 0xaa, 0x0f, 0x13, 0xd5, 0x85, 0x22, 0xe0, 0xd6, 0x16, 0xa4,
	0x1e, 0xc3, 0xc8, 0x1e, 0xf4, 0xa1, 0x17, 0x4d, 0x0a, 0xb5, 0xc9, 0xe0, 0xfc, 0xf2, 0x79, 0xdb,
	0xb6, 0xf5, 0xd1, 0x88, 0x5b, 0x5f, 0x93, 0x3d, 0x84, 0xb5, 0x72, 0xe2, 0x87, 0x66, 0x26, 0x11,
	0x73, 0x30, 0x38, 0xbf, 0xd8, 0xb0, 0x23, 0x29, 0x4f, 0x39, 0xe5, 0x01, 0xe2, 0x56, 0x14, 0x0f,
	0x34, 0x45, 0x94, 0xcf, 0xf1, 0x6d, 0xa2, 0xc6, 0xb8, 0xb0, 0x42, 0xd4, 0x1c, 0x1a, 0x56, 0x88,
	0x72, 0x3a, 0x9f, 0x8b, 0xbb, 0x16, 0x83, 0x3f, 0xfb, 0xae, 0xad, 0xb9, 0xa1, 0x7d, 0xd7, 0xf6,
	0x9c, 0x10, 0x5f, 0xe4, 0x74, 0x37, 0x30, 0xbf, 0x86, 0x38, 0xca, 0x72, 0x31, 0x18, 0x64, 0x7e,
	0xf7, 0x0b, 0x00, 0xdd, 0xf5, 0x6b, 0xfa, 0xb5, 0x17, 0x9b, 0xf6, 0xbe, 0xca, 0x23, 0xc1, 0x26,
	0xce, 0x7f, 0x29, 0x55, 0x39, 0xe7, 0xa6, 0x83, 0xbe, 0x80, 0x91, 0xc6, 0x3f, 0x3c, 0xa3, 0xc1,
	0xd3, 0x58, 0xcc, 0x9b, 0xb6, 0xa4, 0x0a, 0x2f, 0x72, 0x2e, 0x17, 0x30, 0xb2, 0xb9, 0x64, 0x67,
	0x34, 0x60, 0x6a, 0x50, 0x18, 0xd9, 0x2d, 0xae, 0xf6, 0x9c, 0xc6, 0x7e, 0x59, 0x7b, 0xce, 0x39,
	0x9d, 0xb1, 0xc5, 0x4f, 0xa4, 0x52, 0xb3, 0x0a, 0x7c, 0x0e, 0xa0, 0x9b, 0x50, 0xad, 0x53, 0xad,
	0x8f, 0x9d, 0xcf, 0x9b, 0xb6, 0x9a, 0xcc, 0x22, 0x78, 0xa8, 0x8a, 0xf0, 0x4b, 0x18, 0x5a, 0x2d,
	0x29, 0x2a, 0x27, 0x0b, 0x4d, 0x5d, 0xee, 0xfc, 0xc5, 0x73, 0x76, 0x25, 0xa3, 0x4b, 0x9c, 0xd1,
	0x36, 0x9e, 0x32, 0x46, 0xa1, 0x44, 0xe1, 0x4d, 0x2c, 0xe3, 0xf5, 0x53, 0xe8, 0xab, 0xa6, 0x15,
	0x95, 0x56, 0xae, 0x74, 0xb6, 0xf3, 0x59, 0x7d, 0xa3, 0x92, 0xb6, 0x79, 0x8e, 0xc8, 0xe4, 0x2e,
	0xa3, 0x4b, 0x60, 0x5c, 0x69, 0x7c, 0x51, 0x79, 0xeb, 0xcd, 0x1d, 0xf1, 0xdc, 0xfe, 0x3d, 0x4b,
	0x0c, 0xda, 0xf0, 0x0b, 0x9c, 0xc1, 0x16, 0xda, 0xe0, 0x0c, 0xd4, 0x41, 0x61, 0xfe, 0x9b, 0x0e,
	0x5a, 0xc0, 0xc8, 0xee, 0x94, 0xb5, 0xe9, 0x1b, 0x3b, 0xe8, 0x79, 0xd3, 0x33, 0x54, 0x95, 0x4e,
	0x84, 0x2c, 0x26, 0xec, 0x8d, 0xc8, 0x78, 0x2c, 0x2b, 0xdd, 0xb8, 0x7c, 0x46, 0x3e, 0x1f, 0x2b,
	0x79, 0x08, 0xbf, 0xc4, 0x59, 0xbd, 0x80, 0x2e, 0xd6, 0x58, 0xa9, 0xc7, 0xf8, 0x4d, 0x67, 0xb1,
	0xca, 0xff, 0x84, 0xf2, 0xc6, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe1, 0xcb, 0xcf, 0x0e, 0xaf,
	0x22, 0x00, 0x00,
}
