// Code generated by protoc-gen-go. DO NOT EDIT.
// source: xudrpc.proto

/*
Package xudrpc is a generated protocol buffer package.

It is generated from these files:
	xudrpc.proto

It has these top-level messages:
	AddCurrencyRequest
	AddCurrencyResponse
	AddPairRequest
	AddPairResponse
	BanRequest
	BanResponse
	ChannelBalance
	ChannelBalanceRequest
	ChannelBalanceResponse
	ConnectRequest
	ConnectResponse
	ExecuteSwapRequest
	SwapFailure
	GetInfoRequest
	GetInfoResponse
	GetNodeInfoRequest
	GetNodeInfoResponse
	ListOrdersRequest
	ListOrdersResponse
	ListCurrenciesRequest
	ListCurrenciesResponse
	ListPairsRequest
	ListPairsResponse
	ListPeersRequest
	ListPeersResponse
	LndChannels
	LndInfo
	Order
	OrderRemoval
	Orders
	OrdersCount
	Peer
	PlaceOrderRequest
	PlaceOrderResponse
	PlaceOrderEvent
	RaidenInfo
	RemoveCurrencyRequest
	RemoveCurrencyResponse
	RemoveOrderRequest
	RemoveOrderResponse
	RemovePairRequest
	RemovePairResponse
	ShutdownRequest
	ShutdownResponse
	SubscribeAddedOrdersRequest
	SubscribeRemovedOrdersRequest
	SubscribeSwapsRequest
	SwapSuccess
	UnbanRequest
	UnbanResponse
*/
package xudrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OrderSide int32

const (
	OrderSide_BUY  OrderSide = 0
	OrderSide_SELL OrderSide = 1
)

var OrderSide_name = map[int32]string{
	0: "BUY",
	1: "SELL",
}
var OrderSide_value = map[string]int32{
	"BUY":  0,
	"SELL": 1,
}

func (x OrderSide) String() string {
	return proto.EnumName(OrderSide_name, int32(x))
}
func (OrderSide) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AddCurrencyRequest_SwapClient int32

const (
	AddCurrencyRequest_LND    AddCurrencyRequest_SwapClient = 0
	AddCurrencyRequest_RAIDEN AddCurrencyRequest_SwapClient = 1
)

var AddCurrencyRequest_SwapClient_name = map[int32]string{
	0: "LND",
	1: "RAIDEN",
}
var AddCurrencyRequest_SwapClient_value = map[string]int32{
	"LND":    0,
	"RAIDEN": 1,
}

func (x AddCurrencyRequest_SwapClient) String() string {
	return proto.EnumName(AddCurrencyRequest_SwapClient_name, int32(x))
}
func (AddCurrencyRequest_SwapClient) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

type SwapSuccess_Role int32

const (
	SwapSuccess_TAKER SwapSuccess_Role = 0
	SwapSuccess_MAKER SwapSuccess_Role = 1
)

var SwapSuccess_Role_name = map[int32]string{
	0: "TAKER",
	1: "MAKER",
}
var SwapSuccess_Role_value = map[string]int32{
	"TAKER": 0,
	"MAKER": 1,
}

func (x SwapSuccess_Role) String() string {
	return proto.EnumName(SwapSuccess_Role_name, int32(x))
}
func (SwapSuccess_Role) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{47, 0} }

type AddCurrencyRequest struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
	// The payment channel network client to use for executing swaps.
	SwapClient AddCurrencyRequest_SwapClient `protobuf:"varint,2,opt,name=swap_client,enum=xudrpc.AddCurrencyRequest_SwapClient" json:"swap_client,omitempty"`
	// The contract address for layered tokens such as ERC20.
	TokenAddress string `protobuf:"bytes,3,opt,name=token_address" json:"token_address,omitempty"`
	// The number of places to the right of the decimal point of the smallest subunit of the currency.
	// For example, BTC, LTC, and others where the smallest subunits (satoshis) are 0.00000001 full
	// units (bitcoins) have 8 decimal places. ETH has 18. This can be thought of as the base 10
	// exponent of the smallest subunit expressed as a positive integer. A default value of 8 is
	// used if unspecified.
	DecimalPlaces uint32 `protobuf:"varint,4,opt,name=decimal_places" json:"decimal_places,omitempty"`
}

func (m *AddCurrencyRequest) Reset()                    { *m = AddCurrencyRequest{} }
func (m *AddCurrencyRequest) String() string            { return proto.CompactTextString(m) }
func (*AddCurrencyRequest) ProtoMessage()               {}
func (*AddCurrencyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AddCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *AddCurrencyRequest) GetSwapClient() AddCurrencyRequest_SwapClient {
	if m != nil {
		return m.SwapClient
	}
	return AddCurrencyRequest_LND
}

func (m *AddCurrencyRequest) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *AddCurrencyRequest) GetDecimalPlaces() uint32 {
	if m != nil {
		return m.DecimalPlaces
	}
	return 0
}

type AddCurrencyResponse struct {
}

func (m *AddCurrencyResponse) Reset()                    { *m = AddCurrencyResponse{} }
func (m *AddCurrencyResponse) String() string            { return proto.CompactTextString(m) }
func (*AddCurrencyResponse) ProtoMessage()               {}
func (*AddCurrencyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AddPairRequest struct {
	// The base currency that is bought and sold for this trading pair.
	BaseCurrency string `protobuf:"bytes,1,opt,name=base_currency" json:"base_currency,omitempty"`
	// The currency used to quote a price for the base currency.
	QuoteCurrency string `protobuf:"bytes,2,opt,name=quote_currency" json:"quote_currency,omitempty"`
}

func (m *AddPairRequest) Reset()                    { *m = AddPairRequest{} }
func (m *AddPairRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPairRequest) ProtoMessage()               {}
func (*AddPairRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AddPairRequest) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *AddPairRequest) GetQuoteCurrency() string {
	if m != nil {
		return m.QuoteCurrency
	}
	return ""
}

type AddPairResponse struct {
}

func (m *AddPairResponse) Reset()                    { *m = AddPairResponse{} }
func (m *AddPairResponse) String() string            { return proto.CompactTextString(m) }
func (*AddPairResponse) ProtoMessage()               {}
func (*AddPairResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type BanRequest struct {
	// The node pub key of the node to ban.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
}

func (m *BanRequest) Reset()                    { *m = BanRequest{} }
func (m *BanRequest) String() string            { return proto.CompactTextString(m) }
func (*BanRequest) ProtoMessage()               {}
func (*BanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *BanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type BanResponse struct {
}

func (m *BanResponse) Reset()                    { *m = BanResponse{} }
func (m *BanResponse) String() string            { return proto.CompactTextString(m) }
func (*BanResponse) ProtoMessage()               {}
func (*BanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type ChannelBalance struct {
	// Sum of channels balances denominated in satoshis or equivalent.
	Balance int64 `protobuf:"varint,1,opt,name=balance" json:"balance,omitempty"`
	// Sum of channels pending balances denominated in satoshis or equivalent.
	PendingOpenBalance int64 `protobuf:"varint,2,opt,name=pending_open_balance" json:"pending_open_balance,omitempty"`
}

func (m *ChannelBalance) Reset()                    { *m = ChannelBalance{} }
func (m *ChannelBalance) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalance) ProtoMessage()               {}
func (*ChannelBalance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ChannelBalance) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *ChannelBalance) GetPendingOpenBalance() int64 {
	if m != nil {
		return m.PendingOpenBalance
	}
	return 0
}

type ChannelBalanceRequest struct {
	// The ticker symbol of the currency to query for, if unspecified then balances for all supported
	// currencies are queried.
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
}

func (m *ChannelBalanceRequest) Reset()                    { *m = ChannelBalanceRequest{} }
func (m *ChannelBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceRequest) ProtoMessage()               {}
func (*ChannelBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ChannelBalanceRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type ChannelBalanceResponse struct {
	// A map between currency ticker symbols and their channel balances.
	Balances map[string]*ChannelBalance `protobuf:"bytes,1,rep,name=balances,json=orders" json:"balances,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ChannelBalanceResponse) Reset()                    { *m = ChannelBalanceResponse{} }
func (m *ChannelBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceResponse) ProtoMessage()               {}
func (*ChannelBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ChannelBalanceResponse) GetBalances() map[string]*ChannelBalance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type ConnectRequest struct {
	// The uri of the node to connect to in "[nodePubKey]@[host]:[port]" format.
	NodeUri string `protobuf:"bytes,1,opt,name=node_uri" json:"node_uri,omitempty"`
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ConnectRequest) GetNodeUri() string {
	if m != nil {
		return m.NodeUri
	}
	return ""
}

type ConnectResponse struct {
}

func (m *ConnectResponse) Reset()                    { *m = ConnectResponse{} }
func (m *ConnectResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectResponse) ProtoMessage()               {}
func (*ConnectResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type ExecuteSwapRequest struct {
	// The order id of the maker order.
	OrderId string `protobuf:"bytes,1,opt,name=order_id" json:"order_id,omitempty"`
	// The trading pair of the swap orders.
	PairId string `protobuf:"bytes,2,opt,name=pair_id" json:"pair_id,omitempty"`
	// The node pub key of the peer which owns the maker order. This is optional but helps locate the order more quickly.
	PeerPubKey string `protobuf:"bytes,3,opt,name=peer_pub_key" json:"peer_pub_key,omitempty"`
	// The quantity to swap. The whole order will be swapped if unspecified.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity" json:"quantity,omitempty"`
}

func (m *ExecuteSwapRequest) Reset()                    { *m = ExecuteSwapRequest{} }
func (m *ExecuteSwapRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteSwapRequest) ProtoMessage()               {}
func (*ExecuteSwapRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ExecuteSwapRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *ExecuteSwapRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *ExecuteSwapRequest) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *ExecuteSwapRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type SwapFailure struct {
	// The global UUID for the order that failed the swap.
	OrderId string `protobuf:"bytes,1,opt,name=order_id" json:"order_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id" json:"pair_id,omitempty"`
	// The order quantity that was attempted to be swapped.
	Quantity uint64 `protobuf:"varint,3,opt,name=quantity" json:"quantity,omitempty"`
	// The node pub key of the peer that we attempted to swap with.
	PeerPubKey string `protobuf:"bytes,4,opt,name=peer_pub_key" json:"peer_pub_key,omitempty"`
	// The reason why the swap failed.
	FailureReason string `protobuf:"bytes,5,opt,name=failure_reason" json:"failure_reason,omitempty"`
}

func (m *SwapFailure) Reset()                    { *m = SwapFailure{} }
func (m *SwapFailure) String() string            { return proto.CompactTextString(m) }
func (*SwapFailure) ProtoMessage()               {}
func (*SwapFailure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SwapFailure) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapFailure) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapFailure) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *SwapFailure) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *SwapFailure) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type GetInfoResponse struct {
	// The version of this instance of xud.
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The node pub key of this node.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// A list of uris that can be used to connect to this node. These are shared with peers.
	Uris []string `protobuf:"bytes,3,rep,name=uris" json:"uris,omitempty"`
	// The number of currently connected peers.
	NumPeers int32 `protobuf:"varint,4,opt,name=num_peers" json:"num_peers,omitempty"`
	// The number of supported trading pairs.
	NumPairs int32 `protobuf:"varint,5,opt,name=num_pairs" json:"num_pairs,omitempty"`
	// The number of active, standing orders in the order book.
	Orders *OrdersCount        `protobuf:"bytes,6,opt,name=orders" json:"orders,omitempty"`
	Lnd    map[string]*LndInfo `protobuf:"bytes,7,rep,name=lnd" json:"lnd,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Raiden *RaidenInfo         `protobuf:"bytes,8,opt,name=raiden" json:"raiden,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetInfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetInfoResponse) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *GetInfoResponse) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *GetInfoResponse) GetNumPeers() int32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *GetInfoResponse) GetNumPairs() int32 {
	if m != nil {
		return m.NumPairs
	}
	return 0
}

func (m *GetInfoResponse) GetOrders() *OrdersCount {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *GetInfoResponse) GetLnd() map[string]*LndInfo {
	if m != nil {
		return m.Lnd
	}
	return nil
}

func (m *GetInfoResponse) GetRaiden() *RaidenInfo {
	if m != nil {
		return m.Raiden
	}
	return nil
}

type GetNodeInfoRequest struct {
	// The node pub key of the node for which to get information.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
}

func (m *GetNodeInfoRequest) Reset()                    { *m = GetNodeInfoRequest{} }
func (m *GetNodeInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNodeInfoRequest) ProtoMessage()               {}
func (*GetNodeInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetNodeInfoRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type GetNodeInfoResponse struct {
	// The node's reputation score. Points are subtracted for unexpected or potentially malicious
	// behavior. Points are added when swaps are successfully executed.
	ReputationScore int32 `protobuf:"varint,1,opt,name=reputationScore,json=reputation" json:"reputationScore,omitempty"`
	// Whether the node is currently banned.
	Banned bool `protobuf:"varint,2,opt,name=banned" json:"banned,omitempty"`
}

func (m *GetNodeInfoResponse) Reset()                    { *m = GetNodeInfoResponse{} }
func (m *GetNodeInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNodeInfoResponse) ProtoMessage()               {}
func (*GetNodeInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetNodeInfoResponse) GetReputationScore() int32 {
	if m != nil {
		return m.ReputationScore
	}
	return 0
}

func (m *GetNodeInfoResponse) GetBanned() bool {
	if m != nil {
		return m.Banned
	}
	return false
}

type ListOrdersRequest struct {
	// The trading pair for which to retrieve orders.
	PairId string `protobuf:"bytes,1,opt,name=pair_id" json:"pair_id,omitempty"`
	// Whether own orders should be included in result or not.
	IncludeOwnOrders bool `protobuf:"varint,2,opt,name=include_own_orders" json:"include_own_orders,omitempty"`
}

func (m *ListOrdersRequest) Reset()                    { *m = ListOrdersRequest{} }
func (m *ListOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListOrdersRequest) ProtoMessage()               {}
func (*ListOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListOrdersRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *ListOrdersRequest) GetIncludeOwnOrders() bool {
	if m != nil {
		return m.IncludeOwnOrders
	}
	return false
}

type ListOrdersResponse struct {
	// A map between pair ids and their buy and sell orders.
	Orders map[string]*Orders `protobuf:"bytes,1,rep,name=orders" json:"orders,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListOrdersResponse) Reset()                    { *m = ListOrdersResponse{} }
func (m *ListOrdersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOrdersResponse) ProtoMessage()               {}
func (*ListOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ListOrdersResponse) GetOrders() map[string]*Orders {
	if m != nil {
		return m.Orders
	}
	return nil
}

type ListCurrenciesRequest struct {
}

func (m *ListCurrenciesRequest) Reset()                    { *m = ListCurrenciesRequest{} }
func (m *ListCurrenciesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListCurrenciesRequest) ProtoMessage()               {}
func (*ListCurrenciesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type ListCurrenciesResponse struct {
	// A list of ticker symbols of the supported currencies.
	Currencies []string `protobuf:"bytes,1,rep,name=currencies" json:"currencies,omitempty"`
}

func (m *ListCurrenciesResponse) Reset()                    { *m = ListCurrenciesResponse{} }
func (m *ListCurrenciesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListCurrenciesResponse) ProtoMessage()               {}
func (*ListCurrenciesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ListCurrenciesResponse) GetCurrencies() []string {
	if m != nil {
		return m.Currencies
	}
	return nil
}

type ListPairsRequest struct {
}

func (m *ListPairsRequest) Reset()                    { *m = ListPairsRequest{} }
func (m *ListPairsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPairsRequest) ProtoMessage()               {}
func (*ListPairsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type ListPairsResponse struct {
	// The list of supported trading pair tickers in formats like "LTC/BTC".
	Pairs []string `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *ListPairsResponse) Reset()                    { *m = ListPairsResponse{} }
func (m *ListPairsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPairsResponse) ProtoMessage()               {}
func (*ListPairsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ListPairsResponse) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type ListPeersRequest struct {
}

func (m *ListPeersRequest) Reset()                    { *m = ListPeersRequest{} }
func (m *ListPeersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPeersRequest) ProtoMessage()               {}
func (*ListPeersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

type ListPeersResponse struct {
	// The list of connected peers.
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *ListPeersResponse) Reset()                    { *m = ListPeersResponse{} }
func (m *ListPeersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPeersResponse) ProtoMessage()               {}
func (*ListPeersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ListPeersResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type LndChannels struct {
	// The number of active/online channels for this lnd instance that can be used for swaps.
	Active int32 `protobuf:"varint,1,opt,name=active" json:"active,omitempty"`
	// The number of inactive/offline channels for this lnd instance.
	Inactive int32 `protobuf:"varint,2,opt,name=inactive" json:"inactive,omitempty"`
	// The number of channels that are pending on-chain confirmation before they can be used.
	Pending int32 `protobuf:"varint,3,opt,name=pending" json:"pending,omitempty"`
}

func (m *LndChannels) Reset()                    { *m = LndChannels{} }
func (m *LndChannels) String() string            { return proto.CompactTextString(m) }
func (*LndChannels) ProtoMessage()               {}
func (*LndChannels) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *LndChannels) GetActive() int32 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *LndChannels) GetInactive() int32 {
	if m != nil {
		return m.Inactive
	}
	return 0
}

func (m *LndChannels) GetPending() int32 {
	if m != nil {
		return m.Pending
	}
	return 0
}

type LndInfo struct {
	Error       string       `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Channels    *LndChannels `protobuf:"bytes,2,opt,name=channels" json:"channels,omitempty"`
	Chains      []string     `protobuf:"bytes,3,rep,name=chains" json:"chains,omitempty"`
	Blockheight int32        `protobuf:"varint,4,opt,name=blockheight" json:"blockheight,omitempty"`
	Uris        []string     `protobuf:"bytes,5,rep,name=uris" json:"uris,omitempty"`
	Version     string       `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
	Alias       string       `protobuf:"bytes,7,opt,name=alias" json:"alias,omitempty"`
}

func (m *LndInfo) Reset()                    { *m = LndInfo{} }
func (m *LndInfo) String() string            { return proto.CompactTextString(m) }
func (*LndInfo) ProtoMessage()               {}
func (*LndInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *LndInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *LndInfo) GetChannels() *LndChannels {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *LndInfo) GetChains() []string {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *LndInfo) GetBlockheight() int32 {
	if m != nil {
		return m.Blockheight
	}
	return 0
}

func (m *LndInfo) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *LndInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LndInfo) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type Order struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that this order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// A UUID for this order.
	Id string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// Types that are valid to be assigned to OwnOrPeer:
	//	*Order_PeerPubKey
	//	*Order_LocalId
	OwnOrPeer isOrder_OwnOrPeer `protobuf_oneof:"own_or_peer"`
	// The epoch time when this order was created.
	CreatedAt int64 `protobuf:"varint,7,opt,name=created_at" json:"created_at,omitempty"`
	// Whether this order is a buy or sell
	Side OrderSide `protobuf:"varint,8,opt,name=side,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// Whether this order is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,9,opt,name=is_own_order" json:"is_own_order,omitempty"`
	// The quantity on hold pending swap exectuion.
	Hold uint64 `protobuf:"varint,10,opt,name=hold" json:"hold,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

type isOrder_OwnOrPeer interface{ isOrder_OwnOrPeer() }

type Order_PeerPubKey struct {
	PeerPubKey string `protobuf:"bytes,5,opt,name=peer_pub_key,oneof"`
}
type Order_LocalId struct {
	LocalId string `protobuf:"bytes,6,opt,name=local_id,oneof"`
}

func (*Order_PeerPubKey) isOrder_OwnOrPeer() {}
func (*Order_LocalId) isOrder_OwnOrPeer()    {}

func (m *Order) GetOwnOrPeer() isOrder_OwnOrPeer {
	if m != nil {
		return m.OwnOrPeer
	}
	return nil
}

func (m *Order) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Order) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *Order) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Order) GetPeerPubKey() string {
	if x, ok := m.GetOwnOrPeer().(*Order_PeerPubKey); ok {
		return x.PeerPubKey
	}
	return ""
}

func (m *Order) GetLocalId() string {
	if x, ok := m.GetOwnOrPeer().(*Order_LocalId); ok {
		return x.LocalId
	}
	return ""
}

func (m *Order) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

func (m *Order) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

func (m *Order) GetHold() uint64 {
	if m != nil {
		return m.Hold
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Order) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Order_OneofMarshaler, _Order_OneofUnmarshaler, _Order_OneofSizer, []interface{}{
		(*Order_PeerPubKey)(nil),
		(*Order_LocalId)(nil),
	}
}

func _Order_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Order)
	// own_or_peer
	switch x := m.OwnOrPeer.(type) {
	case *Order_PeerPubKey:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PeerPubKey)
	case *Order_LocalId:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LocalId)
	case nil:
	default:
		return fmt.Errorf("Order.OwnOrPeer has unexpected type %T", x)
	}
	return nil
}

func _Order_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Order)
	switch tag {
	case 5: // own_or_peer.peer_pub_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OwnOrPeer = &Order_PeerPubKey{x}
		return true, err
	case 6: // own_or_peer.local_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OwnOrPeer = &Order_LocalId{x}
		return true, err
	default:
		return false, nil
	}
}

func _Order_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Order)
	// own_or_peer
	switch x := m.OwnOrPeer.(type) {
	case *Order_PeerPubKey:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PeerPubKey)))
		n += len(x.PeerPubKey)
	case *Order_LocalId:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LocalId)))
		n += len(x.LocalId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OrderRemoval struct {
	// The quantity of the order being removed.
	Quantity uint64 `protobuf:"varint,1,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id" json:"pair_id,omitempty"`
	// The global UUID for the order.
	OrderId string `protobuf:"bytes,3,opt,name=order_id" json:"order_id,omitempty"`
	// The local id for the order, if applicable.
	LocalId string `protobuf:"bytes,4,opt,name=local_id" json:"local_id,omitempty"`
	// Whether the order being removed is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,5,opt,name=is_own_order" json:"is_own_order,omitempty"`
}

func (m *OrderRemoval) Reset()                    { *m = OrderRemoval{} }
func (m *OrderRemoval) String() string            { return proto.CompactTextString(m) }
func (*OrderRemoval) ProtoMessage()               {}
func (*OrderRemoval) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *OrderRemoval) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *OrderRemoval) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *OrderRemoval) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderRemoval) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *OrderRemoval) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

type Orders struct {
	// A list of buy orders sorted by descending price.
	BuyOrders []*Order `protobuf:"bytes,1,rep,name=buy_orders" json:"buy_orders,omitempty"`
	// A list of sell orders sorted by ascending price.
	SellOrders []*Order `protobuf:"bytes,2,rep,name=sell_orders" json:"sell_orders,omitempty"`
}

func (m *Orders) Reset()                    { *m = Orders{} }
func (m *Orders) String() string            { return proto.CompactTextString(m) }
func (*Orders) ProtoMessage()               {}
func (*Orders) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *Orders) GetBuyOrders() []*Order {
	if m != nil {
		return m.BuyOrders
	}
	return nil
}

func (m *Orders) GetSellOrders() []*Order {
	if m != nil {
		return m.SellOrders
	}
	return nil
}

type OrdersCount struct {
	// The number of orders belonging to remote xud nodes.
	Peer int32 `protobuf:"varint,1,opt,name=peer" json:"peer,omitempty"`
	// The number of orders belonging to our local xud node.
	Own int32 `protobuf:"varint,2,opt,name=own" json:"own,omitempty"`
}

func (m *OrdersCount) Reset()                    { *m = OrdersCount{} }
func (m *OrdersCount) String() string            { return proto.CompactTextString(m) }
func (*OrdersCount) ProtoMessage()               {}
func (*OrdersCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *OrdersCount) GetPeer() int32 {
	if m != nil {
		return m.Peer
	}
	return 0
}

func (m *OrdersCount) GetOwn() int32 {
	if m != nil {
		return m.Own
	}
	return 0
}

type Peer struct {
	// The socket address with host and port for this peer.
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The node pub key to uniquely identify this peer.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// A map of ticker symbols to lnd pub keys for this peer
	LndPubKeys map[string]string `protobuf:"bytes,3,rep,name=lnd_pub_keys" json:"lnd_pub_keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Indicates whether this peer was connected inbound.
	Inbound bool `protobuf:"varint,4,opt,name=inbound" json:"inbound,omitempty"`
	// A list of trading pair tickers supported by this peer.
	Pairs []string `protobuf:"bytes,5,rep,name=pairs" json:"pairs,omitempty"`
	// The version of xud being used by the peer.
	XudVersion string `protobuf:"bytes,6,opt,name=xud_version" json:"xud_version,omitempty"`
	// The time in seconds that we have been connected to this peer.
	SecondsConnected int32 `protobuf:"varint,7,opt,name=seconds_connected" json:"seconds_connected,omitempty"`
	// The raiden address for this peer
	RaidenAddress string `protobuf:"bytes,8,opt,name=raiden_address" json:"raiden_address,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *Peer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Peer) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *Peer) GetLndPubKeys() map[string]string {
	if m != nil {
		return m.LndPubKeys
	}
	return nil
}

func (m *Peer) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *Peer) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *Peer) GetXudVersion() string {
	if m != nil {
		return m.XudVersion
	}
	return ""
}

func (m *Peer) GetSecondsConnected() int32 {
	if m != nil {
		return m.SecondsConnected
	}
	return 0
}

func (m *Peer) GetRaidenAddress() string {
	if m != nil {
		return m.RaidenAddress
	}
	return ""
}

type PlaceOrderRequest struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The local id to assign to the order.
	OrderId string `protobuf:"bytes,4,opt,name=order_id" json:"order_id,omitempty"`
	// Whether the order is a Buy or Sell.
	Side OrderSide `protobuf:"varint,5,opt,name=side,enum=xudrpc.OrderSide" json:"side,omitempty"`
}

func (m *PlaceOrderRequest) Reset()                    { *m = PlaceOrderRequest{} }
func (m *PlaceOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderRequest) ProtoMessage()               {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *PlaceOrderRequest) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *PlaceOrderRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *PlaceOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *PlaceOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *PlaceOrderRequest) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

type PlaceOrderResponse struct {
	// A list of own orders (or portions thereof) that matched the newly placed order.
	InternalMatches []*Order `protobuf:"bytes,1,rep,name=internal_matches" json:"internal_matches,omitempty"`
	// A list of successful swaps of peer orders that matched the newly placed order.
	SwapSuccesses []*SwapSuccess `protobuf:"bytes,2,rep,name=swap_successes" json:"swap_successes,omitempty"`
	// The remaining portion of the order, after matches, that enters the order book.
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order" json:"remaining_order,omitempty"`
	// A list of swap attempts that failed.
	SwapFailures []*SwapFailure `protobuf:"bytes,4,rep,name=swap_failures" json:"swap_failures,omitempty"`
}

func (m *PlaceOrderResponse) Reset()                    { *m = PlaceOrderResponse{} }
func (m *PlaceOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderResponse) ProtoMessage()               {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *PlaceOrderResponse) GetInternalMatches() []*Order {
	if m != nil {
		return m.InternalMatches
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapSuccesses() []*SwapSuccess {
	if m != nil {
		return m.SwapSuccesses
	}
	return nil
}

func (m *PlaceOrderResponse) GetRemainingOrder() *Order {
	if m != nil {
		return m.RemainingOrder
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapFailures() []*SwapFailure {
	if m != nil {
		return m.SwapFailures
	}
	return nil
}

type PlaceOrderEvent struct {
	// Types that are valid to be assigned to Event:
	//	*PlaceOrderEvent_InternalMatch
	//	*PlaceOrderEvent_SwapSuccess
	//	*PlaceOrderEvent_RemainingOrder
	//	*PlaceOrderEvent_SwapFailure
	Event isPlaceOrderEvent_Event `protobuf_oneof:"event"`
}

func (m *PlaceOrderEvent) Reset()                    { *m = PlaceOrderEvent{} }
func (m *PlaceOrderEvent) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderEvent) ProtoMessage()               {}
func (*PlaceOrderEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

type isPlaceOrderEvent_Event interface{ isPlaceOrderEvent_Event() }

type PlaceOrderEvent_InternalMatch struct {
	InternalMatch *Order `protobuf:"bytes,1,opt,name=internal_match,oneof"`
}
type PlaceOrderEvent_SwapSuccess struct {
	SwapSuccess *SwapSuccess `protobuf:"bytes,2,opt,name=swap_success,oneof"`
}
type PlaceOrderEvent_RemainingOrder struct {
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order,oneof"`
}
type PlaceOrderEvent_SwapFailure struct {
	SwapFailure *SwapFailure `protobuf:"bytes,4,opt,name=swap_failure,oneof"`
}

func (*PlaceOrderEvent_InternalMatch) isPlaceOrderEvent_Event()  {}
func (*PlaceOrderEvent_SwapSuccess) isPlaceOrderEvent_Event()    {}
func (*PlaceOrderEvent_RemainingOrder) isPlaceOrderEvent_Event() {}
func (*PlaceOrderEvent_SwapFailure) isPlaceOrderEvent_Event()    {}

func (m *PlaceOrderEvent) GetEvent() isPlaceOrderEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *PlaceOrderEvent) GetInternalMatch() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_InternalMatch); ok {
		return x.InternalMatch
	}
	return nil
}

func (m *PlaceOrderEvent) GetSwapSuccess() *SwapSuccess {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_SwapSuccess); ok {
		return x.SwapSuccess
	}
	return nil
}

func (m *PlaceOrderEvent) GetRemainingOrder() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_RemainingOrder); ok {
		return x.RemainingOrder
	}
	return nil
}

func (m *PlaceOrderEvent) GetSwapFailure() *SwapFailure {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_SwapFailure); ok {
		return x.SwapFailure
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PlaceOrderEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PlaceOrderEvent_OneofMarshaler, _PlaceOrderEvent_OneofUnmarshaler, _PlaceOrderEvent_OneofSizer, []interface{}{
		(*PlaceOrderEvent_InternalMatch)(nil),
		(*PlaceOrderEvent_SwapSuccess)(nil),
		(*PlaceOrderEvent_RemainingOrder)(nil),
		(*PlaceOrderEvent_SwapFailure)(nil),
	}
}

func _PlaceOrderEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PlaceOrderEvent)
	// event
	switch x := m.Event.(type) {
	case *PlaceOrderEvent_InternalMatch:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InternalMatch); err != nil {
			return err
		}
	case *PlaceOrderEvent_SwapSuccess:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SwapSuccess); err != nil {
			return err
		}
	case *PlaceOrderEvent_RemainingOrder:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemainingOrder); err != nil {
			return err
		}
	case *PlaceOrderEvent_SwapFailure:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SwapFailure); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PlaceOrderEvent.Event has unexpected type %T", x)
	}
	return nil
}

func _PlaceOrderEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PlaceOrderEvent)
	switch tag {
	case 1: // event.internal_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Order)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_InternalMatch{msg}
		return true, err
	case 2: // event.swap_success
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SwapSuccess)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_SwapSuccess{msg}
		return true, err
	case 3: // event.remaining_order
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Order)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_RemainingOrder{msg}
		return true, err
	case 4: // event.swap_failure
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SwapFailure)
		err := b.DecodeMessage(msg)
		m.Event = &PlaceOrderEvent_SwapFailure{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PlaceOrderEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PlaceOrderEvent)
	// event
	switch x := m.Event.(type) {
	case *PlaceOrderEvent_InternalMatch:
		s := proto.Size(x.InternalMatch)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_SwapSuccess:
		s := proto.Size(x.SwapSuccess)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_RemainingOrder:
		s := proto.Size(x.RemainingOrder)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PlaceOrderEvent_SwapFailure:
		s := proto.Size(x.SwapFailure)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RaidenInfo struct {
	Error    string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Address  string `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	Channels int32  `protobuf:"varint,3,opt,name=channels" json:"channels,omitempty"`
	Version  string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
}

func (m *RaidenInfo) Reset()                    { *m = RaidenInfo{} }
func (m *RaidenInfo) String() string            { return proto.CompactTextString(m) }
func (*RaidenInfo) ProtoMessage()               {}
func (*RaidenInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *RaidenInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RaidenInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaidenInfo) GetChannels() int32 {
	if m != nil {
		return m.Channels
	}
	return 0
}

func (m *RaidenInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type RemoveCurrencyRequest struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
}

func (m *RemoveCurrencyRequest) Reset()                    { *m = RemoveCurrencyRequest{} }
func (m *RemoveCurrencyRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveCurrencyRequest) ProtoMessage()               {}
func (*RemoveCurrencyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *RemoveCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type RemoveCurrencyResponse struct {
}

func (m *RemoveCurrencyResponse) Reset()                    { *m = RemoveCurrencyResponse{} }
func (m *RemoveCurrencyResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveCurrencyResponse) ProtoMessage()               {}
func (*RemoveCurrencyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

type RemoveOrderRequest struct {
	// The local id of the order to remove.
	OrderId string `protobuf:"bytes,1,opt,name=order_id" json:"order_id,omitempty"`
	// The quantity to remove from the order. If zero or unspecified then entire order is removed.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity" json:"quantity,omitempty"`
}

func (m *RemoveOrderRequest) Reset()                    { *m = RemoveOrderRequest{} }
func (m *RemoveOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveOrderRequest) ProtoMessage()               {}
func (*RemoveOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *RemoveOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *RemoveOrderRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type RemoveOrderResponse struct {
	// Any portion of the order that was on hold due to ongoing swaps at the time of the request
	// and could not be removed until after the swaps finish.
	QuantityOnHold uint64 `protobuf:"varint,1,opt,name=quantity_on_hold,json=hold" json:"quantity_on_hold,omitempty"`
}

func (m *RemoveOrderResponse) Reset()                    { *m = RemoveOrderResponse{} }
func (m *RemoveOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveOrderResponse) ProtoMessage()               {}
func (*RemoveOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *RemoveOrderResponse) GetQuantityOnHold() uint64 {
	if m != nil {
		return m.QuantityOnHold
	}
	return 0
}

type RemovePairRequest struct {
	// The trading pair ticker to remove in a format such as "LTC/BTC".
	PairId string `protobuf:"bytes,1,opt,name=pair_id" json:"pair_id,omitempty"`
}

func (m *RemovePairRequest) Reset()                    { *m = RemovePairRequest{} }
func (m *RemovePairRequest) String() string            { return proto.CompactTextString(m) }
func (*RemovePairRequest) ProtoMessage()               {}
func (*RemovePairRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *RemovePairRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type RemovePairResponse struct {
}

func (m *RemovePairResponse) Reset()                    { *m = RemovePairResponse{} }
func (m *RemovePairResponse) String() string            { return proto.CompactTextString(m) }
func (*RemovePairResponse) ProtoMessage()               {}
func (*RemovePairResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

type ShutdownRequest struct {
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

type ShutdownResponse struct {
}

func (m *ShutdownResponse) Reset()                    { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()               {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

type SubscribeAddedOrdersRequest struct {
	// Whether to transmit all existing active orders upon establishing the stream.
	Existing bool `protobuf:"varint,1,opt,name=existing" json:"existing,omitempty"`
}

func (m *SubscribeAddedOrdersRequest) Reset()                    { *m = SubscribeAddedOrdersRequest{} }
func (m *SubscribeAddedOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeAddedOrdersRequest) ProtoMessage()               {}
func (*SubscribeAddedOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *SubscribeAddedOrdersRequest) GetExisting() bool {
	if m != nil {
		return m.Existing
	}
	return false
}

type SubscribeRemovedOrdersRequest struct {
}

func (m *SubscribeRemovedOrdersRequest) Reset()                    { *m = SubscribeRemovedOrdersRequest{} }
func (m *SubscribeRemovedOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRemovedOrdersRequest) ProtoMessage()               {}
func (*SubscribeRemovedOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

type SubscribeSwapsRequest struct {
	// Whether to include the results for swaps initiated via the PlaceOrder or ExecuteSwap calls.
	// These swap results are also returned in the responses for the respective calls.
	IncludeTaker bool `protobuf:"varint,1,opt,name=include_taker" json:"include_taker,omitempty"`
}

func (m *SubscribeSwapsRequest) Reset()                    { *m = SubscribeSwapsRequest{} }
func (m *SubscribeSwapsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeSwapsRequest) ProtoMessage()               {}
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *SubscribeSwapsRequest) GetIncludeTaker() bool {
	if m != nil {
		return m.IncludeTaker
	}
	return false
}

type SwapSuccess struct {
	// The global UUID for the order that was swapped.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	// The local id for the order that was swapped.
	LocalId string `protobuf:"bytes,2,opt,name=local_id" json:"local_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The order quantity that was swapped.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity" json:"quantity,omitempty"`
	// The hex-encoded payment hash for the swaps.
	RHash string `protobuf:"bytes,5,opt,name=r_hash" json:"r_hash,omitempty"`
	// The amount of the smallest base unit of the currency (like satoshis or wei) received.
	AmountReceived int64 `protobuf:"varint,8,opt,name=amount_received" json:"amount_received,omitempty"`
	// The amount of the smallest base unit of the currency (like satoshis or wei) sent.
	AmountSent int64 `protobuf:"varint,9,opt,name=amount_sent" json:"amount_sent,omitempty"`
	// The node pub key of the peer that executed this order.
	PeerPubKey string `protobuf:"bytes,10,opt,name=peer_pub_key" json:"peer_pub_key,omitempty"`
	// Our role in the swap, either MAKER or TAKER.
	Role SwapSuccess_Role `protobuf:"varint,11,opt,name=role,enum=xudrpc.SwapSuccess_Role" json:"role,omitempty"`
	// The ticker symbol of the currency received.
	CurrencyReceived string `protobuf:"bytes,12,opt,name=currency_received" json:"currency_received,omitempty"`
	// The ticker symbol of the currency sent.
	CurrencySent string `protobuf:"bytes,13,opt,name=currency_sent" json:"currency_sent,omitempty"`
	// The hex-encoded preimage.
	RPreimage string `protobuf:"bytes,14,opt,name=r_preimage" json:"r_preimage,omitempty"`
	// The price used for the swap.
	Price float64 `protobuf:"fixed64,15,opt,name=price" json:"price,omitempty"`
}

func (m *SwapSuccess) Reset()                    { *m = SwapSuccess{} }
func (m *SwapSuccess) String() string            { return proto.CompactTextString(m) }
func (*SwapSuccess) ProtoMessage()               {}
func (*SwapSuccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *SwapSuccess) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapSuccess) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *SwapSuccess) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapSuccess) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *SwapSuccess) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *SwapSuccess) GetAmountReceived() int64 {
	if m != nil {
		return m.AmountReceived
	}
	return 0
}

func (m *SwapSuccess) GetAmountSent() int64 {
	if m != nil {
		return m.AmountSent
	}
	return 0
}

func (m *SwapSuccess) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *SwapSuccess) GetRole() SwapSuccess_Role {
	if m != nil {
		return m.Role
	}
	return SwapSuccess_TAKER
}

func (m *SwapSuccess) GetCurrencyReceived() string {
	if m != nil {
		return m.CurrencyReceived
	}
	return ""
}

func (m *SwapSuccess) GetCurrencySent() string {
	if m != nil {
		return m.CurrencySent
	}
	return ""
}

func (m *SwapSuccess) GetRPreimage() string {
	if m != nil {
		return m.RPreimage
	}
	return ""
}

func (m *SwapSuccess) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type UnbanRequest struct {
	// The node pub key of the peer to unban.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// Whether to attempt to connect to the peer after it is unbanned.
	Reconnect bool `protobuf:"varint,2,opt,name=reconnect" json:"reconnect,omitempty"`
}

func (m *UnbanRequest) Reset()                    { *m = UnbanRequest{} }
func (m *UnbanRequest) String() string            { return proto.CompactTextString(m) }
func (*UnbanRequest) ProtoMessage()               {}
func (*UnbanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *UnbanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *UnbanRequest) GetReconnect() bool {
	if m != nil {
		return m.Reconnect
	}
	return false
}

type UnbanResponse struct {
}

func (m *UnbanResponse) Reset()                    { *m = UnbanResponse{} }
func (m *UnbanResponse) String() string            { return proto.CompactTextString(m) }
func (*UnbanResponse) ProtoMessage()               {}
func (*UnbanResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func init() {
	proto.RegisterType((*AddCurrencyRequest)(nil), "xudrpc.AddCurrencyRequest")
	proto.RegisterType((*AddCurrencyResponse)(nil), "xudrpc.AddCurrencyResponse")
	proto.RegisterType((*AddPairRequest)(nil), "xudrpc.AddPairRequest")
	proto.RegisterType((*AddPairResponse)(nil), "xudrpc.AddPairResponse")
	proto.RegisterType((*BanRequest)(nil), "xudrpc.BanRequest")
	proto.RegisterType((*BanResponse)(nil), "xudrpc.BanResponse")
	proto.RegisterType((*ChannelBalance)(nil), "xudrpc.ChannelBalance")
	proto.RegisterType((*ChannelBalanceRequest)(nil), "xudrpc.ChannelBalanceRequest")
	proto.RegisterType((*ChannelBalanceResponse)(nil), "xudrpc.ChannelBalanceResponse")
	proto.RegisterType((*ConnectRequest)(nil), "xudrpc.ConnectRequest")
	proto.RegisterType((*ConnectResponse)(nil), "xudrpc.ConnectResponse")
	proto.RegisterType((*ExecuteSwapRequest)(nil), "xudrpc.ExecuteSwapRequest")
	proto.RegisterType((*SwapFailure)(nil), "xudrpc.SwapFailure")
	proto.RegisterType((*GetInfoRequest)(nil), "xudrpc.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "xudrpc.GetInfoResponse")
	proto.RegisterType((*GetNodeInfoRequest)(nil), "xudrpc.GetNodeInfoRequest")
	proto.RegisterType((*GetNodeInfoResponse)(nil), "xudrpc.GetNodeInfoResponse")
	proto.RegisterType((*ListOrdersRequest)(nil), "xudrpc.ListOrdersRequest")
	proto.RegisterType((*ListOrdersResponse)(nil), "xudrpc.ListOrdersResponse")
	proto.RegisterType((*ListCurrenciesRequest)(nil), "xudrpc.ListCurrenciesRequest")
	proto.RegisterType((*ListCurrenciesResponse)(nil), "xudrpc.ListCurrenciesResponse")
	proto.RegisterType((*ListPairsRequest)(nil), "xudrpc.ListPairsRequest")
	proto.RegisterType((*ListPairsResponse)(nil), "xudrpc.ListPairsResponse")
	proto.RegisterType((*ListPeersRequest)(nil), "xudrpc.ListPeersRequest")
	proto.RegisterType((*ListPeersResponse)(nil), "xudrpc.ListPeersResponse")
	proto.RegisterType((*LndChannels)(nil), "xudrpc.LndChannels")
	proto.RegisterType((*LndInfo)(nil), "xudrpc.LndInfo")
	proto.RegisterType((*Order)(nil), "xudrpc.Order")
	proto.RegisterType((*OrderRemoval)(nil), "xudrpc.OrderRemoval")
	proto.RegisterType((*Orders)(nil), "xudrpc.Orders")
	proto.RegisterType((*OrdersCount)(nil), "xudrpc.OrdersCount")
	proto.RegisterType((*Peer)(nil), "xudrpc.Peer")
	proto.RegisterType((*PlaceOrderRequest)(nil), "xudrpc.PlaceOrderRequest")
	proto.RegisterType((*PlaceOrderResponse)(nil), "xudrpc.PlaceOrderResponse")
	proto.RegisterType((*PlaceOrderEvent)(nil), "xudrpc.PlaceOrderEvent")
	proto.RegisterType((*RaidenInfo)(nil), "xudrpc.RaidenInfo")
	proto.RegisterType((*RemoveCurrencyRequest)(nil), "xudrpc.RemoveCurrencyRequest")
	proto.RegisterType((*RemoveCurrencyResponse)(nil), "xudrpc.RemoveCurrencyResponse")
	proto.RegisterType((*RemoveOrderRequest)(nil), "xudrpc.RemoveOrderRequest")
	proto.RegisterType((*RemoveOrderResponse)(nil), "xudrpc.RemoveOrderResponse")
	proto.RegisterType((*RemovePairRequest)(nil), "xudrpc.RemovePairRequest")
	proto.RegisterType((*RemovePairResponse)(nil), "xudrpc.RemovePairResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "xudrpc.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "xudrpc.ShutdownResponse")
	proto.RegisterType((*SubscribeAddedOrdersRequest)(nil), "xudrpc.SubscribeAddedOrdersRequest")
	proto.RegisterType((*SubscribeRemovedOrdersRequest)(nil), "xudrpc.SubscribeRemovedOrdersRequest")
	proto.RegisterType((*SubscribeSwapsRequest)(nil), "xudrpc.SubscribeSwapsRequest")
	proto.RegisterType((*SwapSuccess)(nil), "xudrpc.SwapSuccess")
	proto.RegisterType((*UnbanRequest)(nil), "xudrpc.UnbanRequest")
	proto.RegisterType((*UnbanResponse)(nil), "xudrpc.UnbanResponse")
	proto.RegisterEnum("xudrpc.OrderSide", OrderSide_name, OrderSide_value)
	proto.RegisterEnum("xudrpc.AddCurrencyRequest_SwapClient", AddCurrencyRequest_SwapClient_name, AddCurrencyRequest_SwapClient_value)
	proto.RegisterEnum("xudrpc.SwapSuccess_Role", SwapSuccess_Role_name, SwapSuccess_Role_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Xud service

type XudClient interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error)
	// Gets the total balance available across all payment channels for one or all currencies.
	ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error)
	// Gets general information about this node.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// Gets general information about a node.
	GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error)
	// The synchronous non-streaming version of PlaceOrder.
	PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Execute a swap on a maker peer order
	ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*SwapSuccess, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error)
	// Begin gracefully shutting down xud.
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Subscribes to orders being added to the order book. This call, together with SubscribeRemovedOrders,
	// allows the client to maintain an up-to-date view of the order book. For example, an exchange that
	// wants to show its users a real time list of the orders available to them would subscribe to this
	// streaming call to be alerted of new orders as they become available for trading.
	SubscribeAddedOrders(ctx context.Context, in *SubscribeAddedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeAddedOrdersClient, error)
	// Subscribes to orders being removed - either in full or in part - from the order book. This call,
	// together with SubscribeAddedOrders, allows the client to maintain an up-to-date view of the order
	// book. For example, an exchange that wants to show its users a real time list of the orders available
	// to them would subscribe to this streaming call to be alerted when part or all of an existing order
	// is no longer available for trading.
	SubscribeRemovedOrders(ctx context.Context, in *SubscribeRemovedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeRemovedOrdersClient, error)
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error)
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error)
}

type xudClient struct {
	cc *grpc.ClientConn
}

func NewXudClient(cc *grpc.ClientConn) XudClient {
	return &xudClient{cc}
}

func (c *xudClient) AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error) {
	out := new(AddCurrencyResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/AddCurrency", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error) {
	out := new(AddPairResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/AddPair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error) {
	out := new(RemoveOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemoveOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error) {
	out := new(ChannelBalanceResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ChannelBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error) {
	out := new(BanResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Ban", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error) {
	out := new(UnbanResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Unban", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error) {
	out := new(GetNodeInfoResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetNodeInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error) {
	out := new(ListCurrenciesResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListCurrencies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error) {
	out := new(ListPairsResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListPairs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[0], c.cc, "/xudrpc.Xud/PlaceOrder", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudPlaceOrderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_PlaceOrderClient interface {
	Recv() (*PlaceOrderEvent, error)
	grpc.ClientStream
}

type xudPlaceOrderClient struct {
	grpc.ClientStream
}

func (x *xudPlaceOrderClient) Recv() (*PlaceOrderEvent, error) {
	m := new(PlaceOrderEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/PlaceOrderSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*SwapSuccess, error) {
	out := new(SwapSuccess)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ExecuteSwap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error) {
	out := new(RemoveCurrencyResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemoveCurrency", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error) {
	out := new(RemovePairResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/RemovePair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) SubscribeAddedOrders(ctx context.Context, in *SubscribeAddedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeAddedOrdersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[1], c.cc, "/xudrpc.Xud/SubscribeAddedOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeAddedOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeAddedOrdersClient interface {
	Recv() (*Order, error)
	grpc.ClientStream
}

type xudSubscribeAddedOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeAddedOrdersClient) Recv() (*Order, error) {
	m := new(Order)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeRemovedOrders(ctx context.Context, in *SubscribeRemovedOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeRemovedOrdersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[2], c.cc, "/xudrpc.Xud/SubscribeRemovedOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeRemovedOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeRemovedOrdersClient interface {
	Recv() (*OrderRemoval, error)
	grpc.ClientStream
}

type xudSubscribeRemovedOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeRemovedOrdersClient) Recv() (*OrderRemoval, error) {
	m := new(OrderRemoval)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[3], c.cc, "/xudrpc.Xud/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapsClient interface {
	Recv() (*SwapSuccess, error)
	grpc.ClientStream
}

type xudSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapsClient) Recv() (*SwapSuccess, error) {
	m := new(SwapSuccess)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[4], c.cc, "/xudrpc.Xud/SubscribeSwapFailures", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapFailuresClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapFailuresClient interface {
	Recv() (*SwapFailure, error)
	grpc.ClientStream
}

type xudSubscribeSwapFailuresClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapFailuresClient) Recv() (*SwapFailure, error) {
	m := new(SwapFailure)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Xud service

type XudServer interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	AddCurrency(context.Context, *AddCurrencyRequest) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	AddPair(context.Context, *AddPairRequest) (*AddPairResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	RemoveOrder(context.Context, *RemoveOrderRequest) (*RemoveOrderResponse, error)
	// Gets the total balance available across all payment channels for one or all currencies.
	ChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	Ban(context.Context, *BanRequest) (*BanResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	Unban(context.Context, *UnbanRequest) (*UnbanResponse, error)
	// Gets general information about this node.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// Gets general information about a node.
	GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	ListCurrencies(context.Context, *ListCurrenciesRequest) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	ListPairs(context.Context, *ListPairsRequest) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(*PlaceOrderRequest, Xud_PlaceOrderServer) error
	// The synchronous non-streaming version of PlaceOrder.
	PlaceOrderSync(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Execute a swap on a maker peer order
	ExecuteSwap(context.Context, *ExecuteSwapRequest) (*SwapSuccess, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	RemoveCurrency(context.Context, *RemoveCurrencyRequest) (*RemoveCurrencyResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	RemovePair(context.Context, *RemovePairRequest) (*RemovePairResponse, error)
	// Begin gracefully shutting down xud.
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Subscribes to orders being added to the order book. This call, together with SubscribeRemovedOrders,
	// allows the client to maintain an up-to-date view of the order book. For example, an exchange that
	// wants to show its users a real time list of the orders available to them would subscribe to this
	// streaming call to be alerted of new orders as they become available for trading.
	SubscribeAddedOrders(*SubscribeAddedOrdersRequest, Xud_SubscribeAddedOrdersServer) error
	// Subscribes to orders being removed - either in full or in part - from the order book. This call,
	// together with SubscribeAddedOrders, allows the client to maintain an up-to-date view of the order
	// book. For example, an exchange that wants to show its users a real time list of the orders available
	// to them would subscribe to this streaming call to be alerted when part or all of an existing order
	// is no longer available for trading.
	SubscribeRemovedOrders(*SubscribeRemovedOrdersRequest, Xud_SubscribeRemovedOrdersServer) error
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(*SubscribeSwapsRequest, Xud_SubscribeSwapsServer) error
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(*SubscribeSwapsRequest, Xud_SubscribeSwapFailuresServer) error
}

func RegisterXudServer(s *grpc.Server, srv XudServer) {
	s.RegisterService(&_Xud_serviceDesc, srv)
}

func _Xud_AddCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddCurrency(ctx, req.(*AddCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_AddPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddPair(ctx, req.(*AddPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveOrder(ctx, req.(*RemoveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ChannelBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ChannelBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ChannelBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ChannelBalance(ctx, req.(*ChannelBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Ban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Ban(ctx, req.(*BanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Unban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Unban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Unban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Unban(ctx, req.(*UnbanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetNodeInfo(ctx, req.(*GetNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCurrenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListCurrencies(ctx, req.(*ListCurrenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPairs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPairs(ctx, req.(*ListPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_PlaceOrder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlaceOrderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).PlaceOrder(m, &xudPlaceOrderServer{stream})
}

type Xud_PlaceOrderServer interface {
	Send(*PlaceOrderEvent) error
	grpc.ServerStream
}

type xudPlaceOrderServer struct {
	grpc.ServerStream
}

func (x *xudPlaceOrderServer) Send(m *PlaceOrderEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_PlaceOrderSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).PlaceOrderSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/PlaceOrderSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).PlaceOrderSync(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ExecuteSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ExecuteSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ExecuteSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ExecuteSwap(ctx, req.(*ExecuteSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveCurrency(ctx, req.(*RemoveCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemovePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemovePair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemovePair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemovePair(ctx, req.(*RemovePairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_SubscribeAddedOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeAddedOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeAddedOrders(m, &xudSubscribeAddedOrdersServer{stream})
}

type Xud_SubscribeAddedOrdersServer interface {
	Send(*Order) error
	grpc.ServerStream
}

type xudSubscribeAddedOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeAddedOrdersServer) Send(m *Order) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeRemovedOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRemovedOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeRemovedOrders(m, &xudSubscribeRemovedOrdersServer{stream})
}

type Xud_SubscribeRemovedOrdersServer interface {
	Send(*OrderRemoval) error
	grpc.ServerStream
}

type xudSubscribeRemovedOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeRemovedOrdersServer) Send(m *OrderRemoval) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwaps(m, &xudSubscribeSwapsServer{stream})
}

type Xud_SubscribeSwapsServer interface {
	Send(*SwapSuccess) error
	grpc.ServerStream
}

type xudSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapsServer) Send(m *SwapSuccess) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwapFailures_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwapFailures(m, &xudSubscribeSwapFailuresServer{stream})
}

type Xud_SubscribeSwapFailuresServer interface {
	Send(*SwapFailure) error
	grpc.ServerStream
}

type xudSubscribeSwapFailuresServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapFailuresServer) Send(m *SwapFailure) error {
	return x.ServerStream.SendMsg(m)
}

var _Xud_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.Xud",
	HandlerType: (*XudServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCurrency",
			Handler:    _Xud_AddCurrency_Handler,
		},
		{
			MethodName: "AddPair",
			Handler:    _Xud_AddPair_Handler,
		},
		{
			MethodName: "RemoveOrder",
			Handler:    _Xud_RemoveOrder_Handler,
		},
		{
			MethodName: "ChannelBalance",
			Handler:    _Xud_ChannelBalance_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Xud_Connect_Handler,
		},
		{
			MethodName: "Ban",
			Handler:    _Xud_Ban_Handler,
		},
		{
			MethodName: "Unban",
			Handler:    _Xud_Unban_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Xud_GetInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Xud_GetNodeInfo_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Xud_ListOrders_Handler,
		},
		{
			MethodName: "ListCurrencies",
			Handler:    _Xud_ListCurrencies_Handler,
		},
		{
			MethodName: "ListPairs",
			Handler:    _Xud_ListPairs_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Xud_ListPeers_Handler,
		},
		{
			MethodName: "PlaceOrderSync",
			Handler:    _Xud_PlaceOrderSync_Handler,
		},
		{
			MethodName: "ExecuteSwap",
			Handler:    _Xud_ExecuteSwap_Handler,
		},
		{
			MethodName: "RemoveCurrency",
			Handler:    _Xud_RemoveCurrency_Handler,
		},
		{
			MethodName: "RemovePair",
			Handler:    _Xud_RemovePair_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Xud_Shutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PlaceOrder",
			Handler:       _Xud_PlaceOrder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeAddedOrders",
			Handler:       _Xud_SubscribeAddedOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeRemovedOrders",
			Handler:       _Xud_SubscribeRemovedOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Xud_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwapFailures",
			Handler:       _Xud_SubscribeSwapFailures_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "xudrpc.proto",
}

func init() { proto.RegisterFile("xudrpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2506 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x19, 0x4b, 0x73, 0xdc, 0x48,
	0xd9, 0x9a, 0x87, 0x67, 0xfc, 0xcd, 0x78, 0x66, 0xdc, 0x76, 0x9c, 0x89, 0xf2, 0xc0, 0xdb, 0x9b,
	0xa4, 0x4c, 0xc8, 0x3a, 0xc1, 0x29, 0x2a, 0xc9, 0x52, 0x4b, 0x11, 0x67, 0xbd, 0x49, 0x58, 0x13,
	0x52, 0x32, 0xcb, 0x7b, 0x57, 0xa5, 0x91, 0x3a, 0xb1, 0x2a, 0x72, 0x6b, 0xa2, 0x87, 0x1d, 0x17,
	0x17, 0x8a, 0xe2, 0xc4, 0x95, 0x0b, 0x37, 0x28, 0xae, 0x9c, 0xf7, 0x6f, 0x70, 0xe1, 0xc2, 0x0f,
	0xe0, 0x44, 0x15, 0x47, 0xee, 0x54, 0xbf, 0xa4, 0x6e, 0x49, 0xe3, 0x4a, 0x28, 0x6e, 0xea, 0xaf,
	0xbf, 0xfe, 0x5e, 0xfd, 0xbd, 0xfa, 0x13, 0x0c, 0xdf, 0xe6, 0x41, 0x32, 0xf7, 0x77, 0xe6, 0x49,
	0x9c, 0xc5, 0x68, 0x59, 0xac, 0xec, 0x35, 0x8f, 0xd2, 0x38, 0xf3, 0xb2, 0x30, 0xa6, 0xa9, 0xd8,
	0xc2, 0xff, 0xb2, 0x00, 0x3d, 0x0a, 0x82, 0xc7, 0x79, 0x92, 0x10, 0xea, 0x9f, 0x39, 0xe4, 0x4d,
	0x4e, 0xd2, 0x0c, 0xd9, 0xd0, 0xf7, 0x25, 0x68, 0x6a, 0x6d, 0x59, 0xdb, 0x2b, 0x4e, 0xb1, 0x46,
	0x4f, 0x60, 0x90, 0x9e, 0x7a, 0x73, 0xd7, 0x8f, 0x42, 0x42, 0xb3, 0x69, 0x6b, 0xcb, 0xda, 0x1e,
	0xed, 0xde, 0xd8, 0x91, 0x1c, 0xeb, 0xc4, 0x76, 0x0e, 0x4f, 0xbd, 0xf9, 0x63, 0x8e, 0xec, 0xe8,
	0x27, 0xd1, 0x75, 0x58, 0xcd, 0xe2, 0xd7, 0x84, 0xba, 0x5e, 0x10, 0x24, 0x24, 0x4d, 0xa7, 0x6d,
	0xce, 0xc9, 0x04, 0xa2, 0x9b, 0x30, 0x0a, 0x88, 0x1f, 0x1e, 0x7b, 0x91, 0x3b, 0x8f, 0x3c, 0x9f,
	0xa4, 0xd3, 0xce, 0x96, 0xb5, 0xbd, 0xea, 0x54, 0xa0, 0xf8, 0x03, 0x80, 0x92, 0x11, 0xea, 0x41,
	0xfb, 0xe0, 0xf9, 0xa7, 0x93, 0x25, 0x04, 0xb0, 0xec, 0x3c, 0x7a, 0xf6, 0xe9, 0xfe, 0xf3, 0x89,
	0x85, 0x2f, 0xc0, 0xba, 0x21, 0x5e, 0x3a, 0x8f, 0x69, 0x4a, 0xf0, 0x57, 0x30, 0x7a, 0x14, 0x04,
	0x2f, 0xbc, 0x30, 0x51, 0xea, 0x5f, 0x87, 0xd5, 0x99, 0x97, 0x12, 0xb7, 0x62, 0x03, 0x13, 0xc8,
	0x24, 0x7b, 0x93, 0xc7, 0x99, 0x86, 0xd6, 0xe2, 0x68, 0x15, 0x28, 0x5e, 0x83, 0x71, 0x41, 0x5f,
	0xb2, 0xbc, 0x0b, 0xb0, 0xe7, 0x51, 0xc5, 0x0e, 0xc3, 0x90, 0xc6, 0x01, 0x71, 0xe7, 0xf9, 0xcc,
	0x7d, 0x4d, 0x14, 0x37, 0x03, 0x86, 0x57, 0x61, 0xc0, 0x4f, 0x94, 0x32, 0x3f, 0x3e, 0xf2, 0x28,
	0x25, 0xd1, 0x9e, 0x17, 0x79, 0xd4, 0x27, 0x68, 0x0a, 0xbd, 0x99, 0xf8, 0xe4, 0xe7, 0xdb, 0x8e,
	0x5a, 0xa2, 0x5d, 0xd8, 0x98, 0x13, 0x1a, 0x84, 0xf4, 0x95, 0x1b, 0xcf, 0x09, 0x75, 0x15, 0x5a,
	0x8b, 0xa3, 0x35, 0xee, 0xe1, 0x7b, 0x70, 0xc1, 0xa4, 0xff, 0x0e, 0x9e, 0x81, 0xbf, 0xb6, 0x60,
	0xb3, 0x7a, 0x4a, 0xc8, 0x8b, 0x3e, 0x83, 0xbe, 0x24, 0x9d, 0x4e, 0xad, 0xad, 0xf6, 0xf6, 0x60,
	0xf7, 0xb6, 0xf2, 0x98, 0xe6, 0x13, 0x3b, 0x72, 0x9d, 0xee, 0xd3, 0x2c, 0x39, 0x73, 0x96, 0xe3,
	0x24, 0x20, 0x49, 0x6a, 0x1f, 0xc2, 0xaa, 0xb1, 0x81, 0x26, 0xd0, 0x2e, 0x4d, 0xc6, 0x3e, 0xd1,
	0x6d, 0xe8, 0x9e, 0x78, 0x51, 0x2e, 0xf4, 0x1b, 0xec, 0x6e, 0x2e, 0xe0, 0x23, 0x90, 0x3e, 0x6e,
	0x3d, 0xb0, 0xf0, 0x6d, 0x18, 0x3d, 0x8e, 0x29, 0x25, 0x7e, 0xa6, 0x69, 0xc9, 0xad, 0x9f, 0x27,
	0xa1, 0xd2, 0x52, 0xad, 0xd9, 0x75, 0x16, 0xd8, 0xf2, 0x36, 0x7e, 0x6f, 0x01, 0xda, 0x7f, 0x4b,
	0xfc, 0x3c, 0x23, 0xcc, 0x07, 0x35, 0x2a, 0x5c, 0x6c, 0x37, 0x0c, 0x14, 0x15, 0xb5, 0x66, 0xd7,
	0x35, 0xf7, 0x42, 0xbe, 0x25, 0xbc, 0x46, 0x2d, 0x99, 0x37, 0xcc, 0x09, 0x49, 0x0a, 0x6f, 0x10,
	0x51, 0x61, 0xc0, 0x18, 0xe5, 0x37, 0xb9, 0x47, 0xb3, 0x30, 0x3b, 0xe3, 0xe1, 0xd0, 0x71, 0x8a,
	0x35, 0xfe, 0xab, 0x05, 0x03, 0x26, 0xc5, 0x67, 0x5e, 0x18, 0xe5, 0x09, 0xf9, 0x1f, 0xa5, 0xd0,
	0x39, 0xb4, 0x4d, 0x0e, 0x35, 0x09, 0x3b, 0x0d, 0x12, 0xde, 0x84, 0xd1, 0x4b, 0x21, 0x80, 0x9b,
	0x10, 0x2f, 0x8d, 0xe9, 0xb4, 0x2b, 0x82, 0xc3, 0x84, 0xe2, 0x09, 0x8c, 0x9e, 0x90, 0xec, 0x19,
	0x7d, 0x19, 0x4b, 0xab, 0xe1, 0xff, 0xb4, 0x60, 0x5c, 0x80, 0xa4, 0xfb, 0x4c, 0xa1, 0x77, 0x42,
	0x92, 0x34, 0x8c, 0xa9, 0x54, 0x41, 0x2d, 0x6b, 0xb1, 0xd3, 0xaa, 0xc7, 0x0e, 0x42, 0xd0, 0xc9,
	0x93, 0x90, 0xe5, 0x97, 0xf6, 0xf6, 0x8a, 0xc3, 0xbf, 0xd1, 0x15, 0x58, 0xa1, 0xf9, 0xb1, 0xcb,
	0x64, 0x16, 0x19, 0xa5, 0xeb, 0x94, 0x80, 0x62, 0xd7, 0x0b, 0x93, 0x94, 0x0b, 0xae, 0x76, 0x19,
	0x00, 0x7d, 0x0b, 0xa4, 0x3b, 0x4e, 0x97, 0xb9, 0x8b, 0xad, 0x2b, 0x17, 0xfb, 0x11, 0x87, 0x3e,
	0x8e, 0x73, 0x9a, 0x29, 0x8f, 0x45, 0xbb, 0xd0, 0x8e, 0x68, 0x30, 0xed, 0x71, 0xa7, 0xdf, 0x52,
	0x98, 0x15, 0x05, 0x77, 0x0e, 0x68, 0x20, 0x1c, 0x9d, 0x21, 0xa3, 0x5b, 0xb0, 0x9c, 0x78, 0x61,
	0x40, 0xe8, 0xb4, 0xcf, 0x19, 0x20, 0x75, 0xcc, 0xe1, 0x50, 0x7e, 0x52, 0x62, 0xd8, 0x4f, 0xa0,
	0xaf, 0x0e, 0x37, 0x04, 0xc3, 0x0d, 0x33, 0x18, 0xc6, 0x8a, 0xd0, 0x01, 0x0d, 0x38, 0x15, 0x2d,
	0x0a, 0x1e, 0x00, 0x7a, 0x42, 0xb2, 0xe7, 0x71, 0x40, 0xb4, 0xdb, 0x78, 0xa7, 0xdc, 0xe4, 0xc0,
	0xba, 0x71, 0x52, 0x5e, 0xda, 0x87, 0x30, 0x4e, 0xc8, 0x3c, 0x17, 0x05, 0xe7, 0xd0, 0x8f, 0x13,
	0x91, 0x99, 0xba, 0x0e, 0x94, 0x60, 0xb4, 0x09, 0xcb, 0x33, 0x16, 0x97, 0xc2, 0x01, 0xfb, 0x8e,
	0x5c, 0xe1, 0x2f, 0x61, 0xed, 0x20, 0x4c, 0x33, 0x61, 0x51, 0x25, 0x8c, 0xe6, 0xae, 0x96, 0xe9,
	0xae, 0x3b, 0x80, 0x42, 0xea, 0x47, 0x79, 0x40, 0xdc, 0xf8, 0x94, 0xba, 0xf2, 0x7a, 0x04, 0xc9,
	0x86, 0x1d, 0xfc, 0x27, 0x0b, 0x90, 0x4e, 0x5f, 0x8a, 0xfc, 0xbd, 0xe2, 0x66, 0x45, 0x92, 0xba,
	0x59, 0xd8, 0xab, 0x86, 0x2b, 0x2f, 0xdb, 0x4c, 0x4f, 0xcf, 0x60, 0xa0, 0x81, 0x1b, 0xee, 0xe3,
	0xba, 0x79, 0x1f, 0x23, 0xd3, 0x73, 0xf4, 0xeb, 0xb8, 0x08, 0x17, 0x18, 0x53, 0x59, 0xad, 0x42,
	0xa2, 0x8c, 0x80, 0x1f, 0xc0, 0x66, 0x75, 0x43, 0x4a, 0x7f, 0x0d, 0xc0, 0x2f, 0xa0, 0x5c, 0x83,
	0x15, 0x47, 0x83, 0x60, 0x04, 0x13, 0x76, 0x92, 0x55, 0xa2, 0x82, 0xda, 0x37, 0x85, 0x9d, 0x25,
	0x4c, 0x12, 0xda, 0x80, 0xae, 0x70, 0x7d, 0x41, 0x43, 0x2c, 0x8a, 0xe3, 0xa4, 0xbc, 0x11, 0x7c,
	0x5f, 0x1e, 0x27, 0xba, 0x15, 0x31, 0x74, 0x45, 0x5c, 0x09, 0x23, 0x0e, 0x95, 0x92, 0x0c, 0xcb,
	0x11, 0x5b, 0xf8, 0x97, 0x30, 0x38, 0xa0, 0x81, 0xcc, 0xc9, 0x29, 0x73, 0x03, 0xcf, 0xcf, 0xc2,
	0x13, 0xe5, 0x22, 0x72, 0xc5, 0xd2, 0x50, 0x48, 0xe5, 0x4e, 0x8b, 0xef, 0x14, 0x6b, 0xee, 0x0d,
	0xa2, 0x76, 0xf1, 0x0c, 0xd5, 0x75, 0xd4, 0x12, 0xff, 0xcd, 0x82, 0x9e, 0xf4, 0x70, 0xa6, 0x0b,
	0x49, 0x92, 0x38, 0x91, 0xb7, 0x20, 0x16, 0xe8, 0x0e, 0xf4, 0x7d, 0xc9, 0x5b, 0x5e, 0xc5, 0xba,
	0x16, 0x1a, 0x4a, 0x2c, 0xa7, 0x40, 0x62, 0x02, 0xfa, 0x47, 0x5e, 0x48, 0x55, 0x16, 0x91, 0x2b,
	0xb4, 0x05, 0x83, 0x59, 0x14, 0xfb, 0xaf, 0x8f, 0x48, 0xf8, 0xea, 0x28, 0x93, 0x99, 0x44, 0x07,
	0x15, 0xd9, 0xa7, 0xab, 0x65, 0x1f, 0x2d, 0x9f, 0x2d, 0x9b, 0xf9, 0x6c, 0x03, 0xba, 0x5e, 0x14,
	0x7a, 0xe9, 0xb4, 0x27, 0xc4, 0xe5, 0x0b, 0xfc, 0x75, 0x0b, 0xba, 0xdc, 0x45, 0xf8, 0xd5, 0x24,
	0xa1, 0x2c, 0xf2, 0x96, 0x23, 0x16, 0x46, 0xb6, 0x6e, 0x55, 0xb2, 0xb5, 0x16, 0x34, 0x6d, 0x33,
	0x68, 0x46, 0xd0, 0x0a, 0x03, 0x99, 0xbd, 0x5b, 0x61, 0x80, 0xae, 0x57, 0xf2, 0x3a, 0xcf, 0xd8,
	0x4f, 0x97, 0x2a, 0x99, 0xfd, 0x0a, 0xf4, 0xa3, 0xd8, 0xf7, 0x22, 0x46, 0x70, 0x59, 0x62, 0x14,
	0x10, 0xee, 0x83, 0x09, 0xf1, 0x32, 0x12, 0xb8, 0x5e, 0xc6, 0x95, 0x68, 0x3b, 0x1a, 0x04, 0xdd,
	0x80, 0x4e, 0x1a, 0x06, 0x84, 0x27, 0xb6, 0xd1, 0xee, 0x9a, 0xe1, 0xff, 0x87, 0x61, 0x40, 0x1c,
	0xbe, 0xcd, 0xd2, 0x4e, 0x98, 0x96, 0x01, 0x3b, 0x5d, 0xe1, 0x91, 0x6c, 0xc0, 0x98, 0x61, 0x8f,
	0xe2, 0x28, 0x98, 0x02, 0x57, 0x98, 0x7f, 0xef, 0xad, 0xc2, 0x40, 0x20, 0xf0, 0x44, 0x8e, 0xff,
	0x6c, 0xc1, 0x90, 0x93, 0x76, 0xc8, 0x71, 0x7c, 0xe2, 0x45, 0x86, 0xa1, 0xac, 0xc5, 0x86, 0xaa,
	0x17, 0xc3, 0xa2, 0x84, 0xb6, 0x2b, 0x25, 0xd4, 0xd6, 0xcc, 0x21, 0x4c, 0x59, 0x1a, 0xa3, 0xaa,
	0x45, 0xb7, 0xae, 0x05, 0x3e, 0x82, 0x65, 0x11, 0xfc, 0xe8, 0x23, 0x80, 0x59, 0x7e, 0xe6, 0x1a,
	0x09, 0x68, 0xd5, 0x30, 0x90, 0xa3, 0x21, 0xa0, 0x3b, 0x30, 0x48, 0x49, 0x14, 0x95, 0xb9, 0xae,
	0x01, 0x5f, 0xc7, 0xc0, 0xf7, 0x54, 0x72, 0xe2, 0x05, 0x8a, 0x99, 0x8f, 0xd9, 0x48, 0x06, 0x1c,
	0xff, 0x66, 0x09, 0x2b, 0x3e, 0xa5, 0x32, 0xd2, 0xd8, 0x27, 0xfe, 0x77, 0x0b, 0x3a, 0x2c, 0x6e,
	0x99, 0x75, 0x54, 0x9f, 0x2e, 0x73, 0xaf, 0xea, 0xd0, 0xdf, 0xa5, 0x04, 0x7f, 0x1f, 0x86, 0x11,
	0x0d, 0xd4, 0x52, 0x04, 0xd1, 0x60, 0xf7, 0x8a, 0x9e, 0x19, 0x58, 0xe0, 0xbd, 0xc8, 0x67, 0x9f,
	0x93, 0x33, 0x99, 0x54, 0x8d, 0x13, 0x8c, 0x7f, 0x48, 0x67, 0x71, 0x4e, 0x85, 0x99, 0xfb, 0x8e,
	0x5a, 0x96, 0xd9, 0xaa, 0xab, 0x65, 0x2b, 0x16, 0x98, 0x6f, 0xf3, 0xc0, 0x35, 0xc3, 0x4c, 0x07,
	0xa1, 0xdb, 0xb0, 0x96, 0x12, 0x3f, 0xa6, 0x41, 0xea, 0xfa, 0xa2, 0xa1, 0x23, 0x01, 0xf7, 0xd8,
	0xae, 0x53, 0xdf, 0x60, 0x0d, 0x8d, 0xa8, 0xb8, 0xc5, 0x73, 0xa5, 0x2f, 0x1a, 0x1a, 0x13, 0x6a,
	0x7f, 0x02, 0xe3, 0x8a, 0x22, 0x0d, 0x65, 0x60, 0x43, 0x2f, 0x03, 0x2b, 0x7a, 0xda, 0xff, 0x8b,
	0x05, 0x6b, 0x2f, 0xd8, 0x8b, 0x46, 0xba, 0xad, 0x28, 0x7c, 0xff, 0xcf, 0xa8, 0xd7, 0x9d, 0xb9,
	0x53, 0x71, 0x66, 0x15, 0x9d, 0xdd, 0x73, 0xa3, 0x13, 0xff, 0xa6, 0x05, 0x48, 0x17, 0x52, 0xe6,
	0xfd, 0x87, 0x30, 0x09, 0x69, 0x46, 0x12, 0xea, 0x45, 0xee, 0xb1, 0x97, 0xf9, 0x47, 0x64, 0x81,
	0x1b, 0xd7, 0xd0, 0xd0, 0x77, 0x61, 0xc4, 0x9f, 0x86, 0x69, 0xee, 0xfb, 0x24, 0x4d, 0x89, 0xf2,
	0xe7, 0x22, 0x2b, 0xb3, 0x8e, 0xf6, 0x50, 0x6c, 0x3a, 0x15, 0x54, 0x74, 0x9f, 0x35, 0x1a, 0xc7,
	0x5e, 0x48, 0xf9, 0x33, 0x86, 0x47, 0x5a, 0x9b, 0xe7, 0xf4, 0x0a, 0xdb, 0x2a, 0x16, 0x7a, 0x08,
	0xab, 0x9c, 0x94, 0xec, 0x49, 0x59, 0x23, 0x58, 0x63, 0x2a, 0xdb, 0x68, 0xc7, 0xc4, 0xc4, 0xbf,
	0x6b, 0xc1, 0xb8, 0x34, 0xc1, 0xfe, 0x09, 0x7b, 0x74, 0xde, 0x87, 0x91, 0xa9, 0x18, 0xbf, 0xae,
	0xaa, 0x18, 0x4f, 0x97, 0x9c, 0x0a, 0x1a, 0x7a, 0x08, 0x43, 0x5d, 0xa5, 0x6a, 0x45, 0xd2, 0x74,
	0x67, 0xd9, 0x58, 0x47, 0x45, 0x0f, 0xdf, 0x4d, 0xf7, 0xa7, 0x4b, 0x4d, 0xda, 0x0f, 0x75, 0x9d,
	0xb8, 0x33, 0x34, 0x2b, 0x5f, 0x70, 0x95, 0xa8, 0x7b, 0x3d, 0xe8, 0x12, 0xa6, 0x32, 0x4e, 0x00,
	0xca, 0x9e, 0x74, 0x41, 0xad, 0xd5, 0x32, 0x47, 0xcb, 0xcc, 0x1c, 0xb6, 0x56, 0x85, 0x45, 0x09,
	0x2f, 0x0b, 0xae, 0x56, 0x22, 0x3b, 0x46, 0x89, 0x64, 0x6f, 0x53, 0x9e, 0xce, 0xc9, 0x7b, 0x4c,
	0x2d, 0xf0, 0x14, 0x36, 0xab, 0x87, 0xe4, 0xe3, 0xed, 0x00, 0x90, 0xd8, 0x31, 0x22, 0xee, 0xbc,
	0x57, 0xd3, 0x39, 0x71, 0x87, 0xbf, 0x03, 0xeb, 0x06, 0xb5, 0xa2, 0x35, 0x9b, 0x28, 0x14, 0x37,
	0xa6, 0x2e, 0xaf, 0x5b, 0x56, 0x59, 0xb7, 0xf0, 0x47, 0xb0, 0x26, 0x8e, 0xe9, 0x63, 0x88, 0x85,
	0xed, 0x2e, 0xde, 0x50, 0x32, 0x1b, 0x53, 0x85, 0x35, 0x18, 0x1f, 0x1e, 0xe5, 0x59, 0x10, 0x9f,
	0xaa, 0xd1, 0x02, 0xeb, 0xd9, 0x4a, 0x90, 0x44, 0x7b, 0x08, 0x97, 0x0f, 0xf3, 0x59, 0xea, 0x27,
	0xe1, 0x8c, 0x3c, 0x0a, 0x02, 0x12, 0x98, 0x4d, 0xb6, 0x0d, 0x7d, 0xf2, 0x36, 0x4c, 0x33, 0xd6,
	0x57, 0x59, 0x3c, 0xd3, 0x16, 0x6b, 0xfc, 0x0d, 0xb8, 0x5a, 0x1c, 0x15, 0x02, 0x98, 0x87, 0xf1,
	0x27, 0x70, 0xa1, 0x40, 0x60, 0x0e, 0x94, 0x6a, 0x23, 0x15, 0xd5, 0x86, 0x67, 0xde, 0x6b, 0x59,
	0x76, 0xfa, 0x8e, 0x09, 0xc4, 0xff, 0x68, 0x8b, 0xb7, 0xab, 0xf4, 0x76, 0x74, 0xa9, 0x76, 0x0b,
	0x3d, 0xbe, 0x7e, 0x66, 0xd6, 0xdd, 0x56, 0xa5, 0xee, 0x9e, 0x9b, 0xfc, 0x16, 0x3d, 0x9c, 0x59,
	0x8b, 0x97, 0xb8, 0x47, 0x5e, 0x7a, 0x24, 0x9f, 0xaa, 0x72, 0x85, 0xb6, 0x61, 0xec, 0x1d, 0xb3,
	0x92, 0xe9, 0x26, 0xc4, 0x27, 0xe1, 0x09, 0x09, 0x78, 0xea, 0x6f, 0x3b, 0x55, 0x30, 0xab, 0x39,
	0x12, 0x94, 0x12, 0x9a, 0xf1, 0xa6, 0xa5, 0xed, 0xe8, 0xa0, 0xda, 0xd3, 0x19, 0x1a, 0x9e, 0xce,
	0xb7, 0xa1, 0x93, 0xc4, 0x11, 0x99, 0x0e, 0x78, 0x12, 0x9e, 0x36, 0x64, 0x81, 0x1d, 0x27, 0x8e,
	0x88, 0xc3, 0xb1, 0x58, 0x15, 0x53, 0x4e, 0x5e, 0xca, 0x37, 0xe4, 0x64, 0xeb, 0x1b, 0xec, 0x1a,
	0x0a, 0x20, 0x97, 0x71, 0x55, 0x4c, 0xb6, 0x0c, 0x20, 0x6b, 0xe2, 0x12, 0x77, 0x9e, 0x90, 0xf0,
	0xd8, 0x7b, 0x45, 0xa6, 0x23, 0x8e, 0xa2, 0x41, 0xca, 0x72, 0x34, 0xd6, 0xca, 0x11, 0xbe, 0x02,
	0x1d, 0x26, 0x17, 0x5a, 0x81, 0xee, 0x8f, 0x1f, 0x7d, 0xbe, 0xef, 0x4c, 0x96, 0xd8, 0xe7, 0x0f,
	0xf9, 0xa7, 0x85, 0x5f, 0xc0, 0xf0, 0x0b, 0x3a, 0x7b, 0xaf, 0xa1, 0x17, 0x7b, 0x86, 0x27, 0x44,
	0x96, 0x60, 0xf9, 0x98, 0x2b, 0x01, 0x78, 0x0c, 0xab, 0x92, 0xa2, 0x70, 0xec, 0x5b, 0xd7, 0x60,
	0xa5, 0xa8, 0x54, 0xa8, 0x07, 0xed, 0xbd, 0x2f, 0x7e, 0x3e, 0x59, 0x42, 0x7d, 0xe8, 0x1c, 0xee,
	0x1f, 0x1c, 0x4c, 0xac, 0xdd, 0x3f, 0xae, 0x41, 0xfb, 0x67, 0x79, 0x80, 0x66, 0x30, 0xd0, 0xe6,
	0x80, 0xc8, 0x5e, 0x3c, 0xbb, 0xb4, 0x2f, 0x37, 0xee, 0xc9, 0x40, 0xb2, 0x7f, 0xfb, 0xf7, 0x7f,
	0xfe, 0xa1, 0xb5, 0x81, 0xc7, 0x77, 0x4e, 0xbe, 0x7d, 0xc7, 0x0b, 0x02, 0x65, 0xc4, 0x8f, 0xad,
	0x5b, 0xc8, 0x81, 0x9e, 0x1c, 0xfa, 0xa1, 0x4d, 0x8d, 0x86, 0x16, 0xde, 0xf6, 0xc5, 0x1a, 0x5c,
	0xd2, 0xdd, 0xe4, 0x74, 0x27, 0x78, 0x20, 0xe9, 0x32, 0xe7, 0x65, 0x34, 0x67, 0x30, 0xd0, 0x72,
	0x4b, 0x29, 0x77, 0x3d, 0x7d, 0x95, 0x72, 0x37, 0x24, 0x23, 0x53, 0xee, 0x84, 0x23, 0xf0, 0xa8,
	0x62, 0x3c, 0x5e, 0xd7, 0x06, 0x8b, 0x57, 0x17, 0x0d, 0xea, 0x04, 0xa7, 0x6b, 0xe7, 0xcf, 0xf1,
	0x14, 0x33, 0x84, 0x18, 0x33, 0x99, 0xdd, 0xd5, 0x64, 0xd2, 0x81, 0x9e, 0x1c, 0xa5, 0x95, 0x46,
	0x32, 0x27, 0x71, 0xa5, 0x91, 0xaa, 0x33, 0x37, 0xc3, 0x48, 0xd2, 0x25, 0x98, 0x02, 0x7b, 0xd0,
	0xde, 0xf3, 0x28, 0x2a, 0x46, 0x26, 0xe5, 0x9c, 0xd5, 0x5e, 0x37, 0x60, 0x92, 0x0e, 0xe2, 0x74,
	0x86, 0xb8, 0xc7, 0xe8, 0xcc, 0x3c, 0xca, 0x68, 0xfc, 0x00, 0xba, 0xdc, 0xb3, 0xd0, 0x86, 0x3a,
	0xa1, 0xbb, 0xae, 0x7d, 0xa1, 0x02, 0x95, 0x94, 0x36, 0x38, 0xa5, 0x11, 0x5e, 0x61, 0x94, 0x72,
	0x2a, 0x69, 0x1d, 0x40, 0x4f, 0x0e, 0x7b, 0x4a, 0x1d, 0xcd, 0x89, 0x57, 0xa9, 0x63, 0x65, 0x2a,
	0x84, 0x27, 0x9c, 0x22, 0xa0, 0x3e, 0xa3, 0x18, 0x32, 0x12, 0xbf, 0x82, 0x81, 0x36, 0x6a, 0x29,
	0x5d, 0xa0, 0x3e, 0xb9, 0x29, 0x5d, 0xa0, 0x61, 0x36, 0xa3, 0x64, 0x45, 0x43, 0x46, 0x99, 0xc5,
	0x1c, 0xa7, 0xfe, 0x53, 0x80, 0x72, 0xd0, 0x81, 0x2e, 0x35, 0x0d, 0x3f, 0x04, 0x6d, 0x7b, 0xf1,
	0x5c, 0x44, 0x19, 0x14, 0x01, 0x23, 0x2d, 0xdf, 0x2a, 0xaf, 0x60, 0x64, 0xce, 0x2c, 0x4a, 0xaf,
	0x6a, 0x1c, 0x72, 0x94, 0x5e, 0xd5, 0x3c, 0xea, 0x50, 0xb7, 0x8f, 0x46, 0xfc, 0xf6, 0x4b, 0xb2,
	0x87, 0xb0, 0x52, 0x8c, 0x33, 0xd0, 0x54, 0x27, 0xa2, 0x4f, 0x3d, 0xec, 0x4b, 0x0d, 0x3b, 0xaa,
	0x88, 0x72, 0xca, 0x03, 0xc4, 0x6f, 0x51, 0x3c, 0x25, 0x14, 0x51, 0x3e, 0x1a, 0x34, 0x89, 0x6a,
	0xb3, 0x90, 0x0a, 0x51, 0x7d, 0x22, 0x52, 0x21, 0xca, 0xe9, 0x7c, 0x09, 0x50, 0xf6, 0x8f, 0xa5,
	0xad, 0x6b, 0xbd, 0x7f, 0xe9, 0x1d, 0x95, 0x76, 0x13, 0x5f, 0xe2, 0x44, 0xd7, 0x31, 0xb7, 0x01,
	0xff, 0x0b, 0xa2, 0xa2, 0xf8, 0xae, 0x85, 0x5e, 0xc2, 0xa8, 0xc4, 0x3f, 0x3c, 0xa3, 0xfe, 0x79,
	0x2c, 0xec, 0xa6, 0x2d, 0x29, 0xfa, 0x55, 0xce, 0xe5, 0x22, 0x46, 0x26, 0x97, 0xf4, 0x8c, 0xfa,
	0xcc, 0xbd, 0x7f, 0x01, 0x03, 0x6d, 0xf2, 0x5d, 0x3a, 0x64, 0x7d, 0x1c, 0x6e, 0x37, 0xf5, 0xb3,
	0x66, 0x2e, 0x22, 0xe2, 0x10, 0x6b, 0x35, 0x19, 0x6d, 0x0a, 0x23, 0xb3, 0x67, 0x2b, 0xbd, 0xa6,
	0xb1, 0x01, 0x2c, 0xbd, 0x66, 0x41, 0xab, 0x67, 0xe8, 0x22, 0x12, 0x9f, 0x9e, 0xb3, 0xbf, 0x02,
	0x28, 0xbb, 0xaa, 0xd2, 0x5e, 0xb5, 0xc6, 0xcc, 0xb6, 0x9b, 0xb6, 0x24, 0x0f, 0xe3, 0x56, 0x04,
	0x0f, 0x95, 0xbf, 0x7f, 0x02, 0x7d, 0xd5, 0x8c, 0xa1, 0xe2, 0x56, 0x2b, 0x1d, 0x9b, 0x3d, 0xad,
	0x6f, 0x48, 0xca, 0x17, 0x39, 0xe5, 0x35, 0xcc, 0x63, 0x36, 0x95, 0xbb, 0xc2, 0x4e, 0x1b, 0x4d,
	0x0d, 0x1d, 0xfa, 0xb0, 0x20, 0xb5, 0xb8, 0xdd, 0xb3, 0xcd, 0x77, 0x02, 0xde, 0xe2, 0x4c, 0x6c,
	0x34, 0xe5, 0x4c, 0xd4, 0x39, 0x8f, 0x9d, 0x13, 0xf7, 0x7e, 0xd7, 0x42, 0xbf, 0x86, 0xcd, 0xe6,
	0x2e, 0x10, 0xdd, 0xa8, 0x71, 0x6c, 0xea, 0x12, 0xed, 0x0d, 0xf3, 0x5d, 0x26, 0x66, 0x33, 0x18,
	0x73, 0xd6, 0x57, 0x90, 0x6d, 0xb0, 0x16, 0x26, 0x2c, 0x99, 0xcf, 0x60, 0x64, 0x76, 0x98, 0xa5,
	0x53, 0x34, 0x76, 0x9e, 0xe7, 0xba, 0x9d, 0xa8, 0x4a, 0x05, 0x2f, 0xe6, 0x78, 0x8c, 0xc7, 0xbc,
	0xd2, 0xc5, 0xca, 0x67, 0xd0, 0xfb, 0xb1, 0x92, 0x87, 0xf0, 0x07, 0x9c, 0xd5, 0x65, 0x74, 0xa9,
	0xc6, 0x4a, 0x3d, 0x26, 0xef, 0x5a, 0xb3, 0x65, 0xfe, 0x3b, 0xf6, 0xde, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x9c, 0x8d, 0xd7, 0x1a, 0xb9, 0x1d, 0x00, 0x00,
}
