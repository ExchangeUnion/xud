// Code generated by protoc-gen-go. DO NOT EDIT.
// source: xudrpc.proto

package xudrpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type OrderSide int32

const (
	OrderSide_BUY  OrderSide = 0
	OrderSide_SELL OrderSide = 1
)

var OrderSide_name = map[int32]string{
	0: "BUY",
	1: "SELL",
}

var OrderSide_value = map[string]int32{
	"BUY":  0,
	"SELL": 1,
}

func (x OrderSide) String() string {
	return proto.EnumName(OrderSide_name, int32(x))
}

func (OrderSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{0}
}

type Currency_SwapClient int32

const (
	Currency_LND    Currency_SwapClient = 0
	Currency_RAIDEN Currency_SwapClient = 1
)

var Currency_SwapClient_name = map[int32]string{
	0: "LND",
	1: "RAIDEN",
}

var Currency_SwapClient_value = map[string]int32{
	"LND":    0,
	"RAIDEN": 1,
}

func (x Currency_SwapClient) String() string {
	return proto.EnumName(Currency_SwapClient_name, int32(x))
}

func (Currency_SwapClient) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{12, 0}
}

type ListOrdersRequest_Owner int32

const (
	ListOrdersRequest_BOTH ListOrdersRequest_Owner = 0
	ListOrdersRequest_OWN  ListOrdersRequest_Owner = 1
	ListOrdersRequest_PEER ListOrdersRequest_Owner = 2
)

var ListOrdersRequest_Owner_name = map[int32]string{
	0: "BOTH",
	1: "OWN",
	2: "PEER",
}

var ListOrdersRequest_Owner_value = map[string]int32{
	"BOTH": 0,
	"OWN":  1,
	"PEER": 2,
}

func (x ListOrdersRequest_Owner) String() string {
	return proto.EnumName(ListOrdersRequest_Owner_name, int32(x))
}

func (ListOrdersRequest_Owner) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{24, 0}
}

type SwapSuccess_Role int32

const (
	SwapSuccess_TAKER SwapSuccess_Role = 0
	SwapSuccess_MAKER SwapSuccess_Role = 1
)

var SwapSuccess_Role_name = map[int32]string{
	0: "TAKER",
	1: "MAKER",
}

var SwapSuccess_Role_value = map[string]int32{
	"TAKER": 0,
	"MAKER": 1,
}

func (x SwapSuccess_Role) String() string {
	return proto.EnumName(SwapSuccess_Role_name, int32(x))
}

func (SwapSuccess_Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{58, 0}
}

type AddCurrencyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddCurrencyResponse) Reset()         { *m = AddCurrencyResponse{} }
func (m *AddCurrencyResponse) String() string { return proto.CompactTextString(m) }
func (*AddCurrencyResponse) ProtoMessage()    {}
func (*AddCurrencyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{0}
}

func (m *AddCurrencyResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddCurrencyResponse.Unmarshal(m, b)
}
func (m *AddCurrencyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddCurrencyResponse.Marshal(b, m, deterministic)
}
func (m *AddCurrencyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCurrencyResponse.Merge(m, src)
}
func (m *AddCurrencyResponse) XXX_Size() int {
	return xxx_messageInfo_AddCurrencyResponse.Size(m)
}
func (m *AddCurrencyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCurrencyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddCurrencyResponse proto.InternalMessageInfo

type AddPairRequest struct {
	// The base currency that is bought and sold for this trading pair.
	BaseCurrency string `protobuf:"bytes,1,opt,name=base_currency,proto3" json:"base_currency,omitempty"`
	// The currency used to quote a price for the base currency.
	QuoteCurrency        string   `protobuf:"bytes,2,opt,name=quote_currency,proto3" json:"quote_currency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddPairRequest) Reset()         { *m = AddPairRequest{} }
func (m *AddPairRequest) String() string { return proto.CompactTextString(m) }
func (*AddPairRequest) ProtoMessage()    {}
func (*AddPairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{1}
}

func (m *AddPairRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddPairRequest.Unmarshal(m, b)
}
func (m *AddPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddPairRequest.Marshal(b, m, deterministic)
}
func (m *AddPairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPairRequest.Merge(m, src)
}
func (m *AddPairRequest) XXX_Size() int {
	return xxx_messageInfo_AddPairRequest.Size(m)
}
func (m *AddPairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddPairRequest proto.InternalMessageInfo

func (m *AddPairRequest) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *AddPairRequest) GetQuoteCurrency() string {
	if m != nil {
		return m.QuoteCurrency
	}
	return ""
}

type AddPairResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddPairResponse) Reset()         { *m = AddPairResponse{} }
func (m *AddPairResponse) String() string { return proto.CompactTextString(m) }
func (*AddPairResponse) ProtoMessage()    {}
func (*AddPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{2}
}

func (m *AddPairResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddPairResponse.Unmarshal(m, b)
}
func (m *AddPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddPairResponse.Marshal(b, m, deterministic)
}
func (m *AddPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPairResponse.Merge(m, src)
}
func (m *AddPairResponse) XXX_Size() int {
	return xxx_messageInfo_AddPairResponse.Size(m)
}
func (m *AddPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddPairResponse proto.InternalMessageInfo

type Balance struct {
	// Total balance denominated in satoshis.
	TotalBalance uint64 `protobuf:"varint,1,opt,name=total_balance,proto3" json:"total_balance,omitempty"`
	// Sum of confirmed channel balances denominated in satoshis.
	ChannelBalance uint64 `protobuf:"varint,2,opt,name=channel_balance,proto3" json:"channel_balance,omitempty"`
	// Sum of pending channel balances denominated in satoshis.
	PendingChannelBalance uint64 `protobuf:"varint,3,opt,name=pending_channel_balance,proto3" json:"pending_channel_balance,omitempty"`
	// Sum of inactive channel balances denominated in satoshis.
	InactiveChannelBalance uint64 `protobuf:"varint,4,opt,name=inactive_channel_balance,proto3" json:"inactive_channel_balance,omitempty"`
	// Confirmed wallet balance in satoshis.
	WalletBalance uint64 `protobuf:"varint,5,opt,name=wallet_balance,proto3" json:"wallet_balance,omitempty"`
	// Unconfirmed wallet balance in satoshis.
	UnconfirmedWalletBalance uint64   `protobuf:"varint,6,opt,name=unconfirmed_wallet_balance,proto3" json:"unconfirmed_wallet_balance,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *Balance) Reset()         { *m = Balance{} }
func (m *Balance) String() string { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()    {}
func (*Balance) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{3}
}

func (m *Balance) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Balance.Unmarshal(m, b)
}
func (m *Balance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Balance.Marshal(b, m, deterministic)
}
func (m *Balance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Balance.Merge(m, src)
}
func (m *Balance) XXX_Size() int {
	return xxx_messageInfo_Balance.Size(m)
}
func (m *Balance) XXX_DiscardUnknown() {
	xxx_messageInfo_Balance.DiscardUnknown(m)
}

var xxx_messageInfo_Balance proto.InternalMessageInfo

func (m *Balance) GetTotalBalance() uint64 {
	if m != nil {
		return m.TotalBalance
	}
	return 0
}

func (m *Balance) GetChannelBalance() uint64 {
	if m != nil {
		return m.ChannelBalance
	}
	return 0
}

func (m *Balance) GetPendingChannelBalance() uint64 {
	if m != nil {
		return m.PendingChannelBalance
	}
	return 0
}

func (m *Balance) GetInactiveChannelBalance() uint64 {
	if m != nil {
		return m.InactiveChannelBalance
	}
	return 0
}

func (m *Balance) GetWalletBalance() uint64 {
	if m != nil {
		return m.WalletBalance
	}
	return 0
}

func (m *Balance) GetUnconfirmedWalletBalance() uint64 {
	if m != nil {
		return m.UnconfirmedWalletBalance
	}
	return 0
}

type BanRequest struct {
	// The node pub key of the node to ban.
	NodePubKey           string   `protobuf:"bytes,1,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BanRequest) Reset()         { *m = BanRequest{} }
func (m *BanRequest) String() string { return proto.CompactTextString(m) }
func (*BanRequest) ProtoMessage()    {}
func (*BanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{4}
}

func (m *BanRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BanRequest.Unmarshal(m, b)
}
func (m *BanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BanRequest.Marshal(b, m, deterministic)
}
func (m *BanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BanRequest.Merge(m, src)
}
func (m *BanRequest) XXX_Size() int {
	return xxx_messageInfo_BanRequest.Size(m)
}
func (m *BanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BanRequest proto.InternalMessageInfo

func (m *BanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type BanResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BanResponse) Reset()         { *m = BanResponse{} }
func (m *BanResponse) String() string { return proto.CompactTextString(m) }
func (*BanResponse) ProtoMessage()    {}
func (*BanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{5}
}

func (m *BanResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BanResponse.Unmarshal(m, b)
}
func (m *BanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BanResponse.Marshal(b, m, deterministic)
}
func (m *BanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BanResponse.Merge(m, src)
}
func (m *BanResponse) XXX_Size() int {
	return xxx_messageInfo_BanResponse.Size(m)
}
func (m *BanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BanResponse proto.InternalMessageInfo

type Chain struct {
	// The blockchain the swap client is on (eg bitcoin, litecoin)
	Chain string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	// The network the swap client is on (eg regtest, testnet, mainnet)
	Network              string   `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Chain) Reset()         { *m = Chain{} }
func (m *Chain) String() string { return proto.CompactTextString(m) }
func (*Chain) ProtoMessage()    {}
func (*Chain) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{6}
}

func (m *Chain) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Chain.Unmarshal(m, b)
}
func (m *Chain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Chain.Marshal(b, m, deterministic)
}
func (m *Chain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chain.Merge(m, src)
}
func (m *Chain) XXX_Size() int {
	return xxx_messageInfo_Chain.Size(m)
}
func (m *Chain) XXX_DiscardUnknown() {
	xxx_messageInfo_Chain.DiscardUnknown(m)
}

var xxx_messageInfo_Chain proto.InternalMessageInfo

func (m *Chain) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *Chain) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

type Channels struct {
	// The number of active/online channels for this lnd instance that can be used for swaps.
	Active uint32 `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	// The number of inactive/offline channels for this lnd instance.
	Inactive uint32 `protobuf:"varint,2,opt,name=inactive,proto3" json:"inactive,omitempty"`
	// The number of channels that are pending on-chain confirmation before they can be used.
	Pending uint32 `protobuf:"varint,3,opt,name=pending,proto3" json:"pending,omitempty"`
	// The number of channels that have been closed.
	Closed               uint32   `protobuf:"varint,4,opt,name=closed,proto3" json:"closed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Channels) Reset()         { *m = Channels{} }
func (m *Channels) String() string { return proto.CompactTextString(m) }
func (*Channels) ProtoMessage()    {}
func (*Channels) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{7}
}

func (m *Channels) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Channels.Unmarshal(m, b)
}
func (m *Channels) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Channels.Marshal(b, m, deterministic)
}
func (m *Channels) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Channels.Merge(m, src)
}
func (m *Channels) XXX_Size() int {
	return xxx_messageInfo_Channels.Size(m)
}
func (m *Channels) XXX_DiscardUnknown() {
	xxx_messageInfo_Channels.DiscardUnknown(m)
}

var xxx_messageInfo_Channels proto.InternalMessageInfo

func (m *Channels) GetActive() uint32 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *Channels) GetInactive() uint32 {
	if m != nil {
		return m.Inactive
	}
	return 0
}

func (m *Channels) GetPending() uint32 {
	if m != nil {
		return m.Pending
	}
	return 0
}

func (m *Channels) GetClosed() uint32 {
	if m != nil {
		return m.Closed
	}
	return 0
}

type ConnectRequest struct {
	// The uri of the node to connect to in "[nodePubKey]@[host]:[port]" format.
	NodeUri              string   `protobuf:"bytes,1,opt,name=node_uri,proto3" json:"node_uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectRequest) Reset()         { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()    {}
func (*ConnectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{8}
}

func (m *ConnectRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectRequest.Unmarshal(m, b)
}
func (m *ConnectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectRequest.Marshal(b, m, deterministic)
}
func (m *ConnectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectRequest.Merge(m, src)
}
func (m *ConnectRequest) XXX_Size() int {
	return xxx_messageInfo_ConnectRequest.Size(m)
}
func (m *ConnectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectRequest proto.InternalMessageInfo

func (m *ConnectRequest) GetNodeUri() string {
	if m != nil {
		return m.NodeUri
	}
	return ""
}

type ConnectResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectResponse) Reset()         { *m = ConnectResponse{} }
func (m *ConnectResponse) String() string { return proto.CompactTextString(m) }
func (*ConnectResponse) ProtoMessage()    {}
func (*ConnectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{9}
}

func (m *ConnectResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectResponse.Unmarshal(m, b)
}
func (m *ConnectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectResponse.Marshal(b, m, deterministic)
}
func (m *ConnectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectResponse.Merge(m, src)
}
func (m *ConnectResponse) XXX_Size() int {
	return xxx_messageInfo_ConnectResponse.Size(m)
}
func (m *ConnectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectResponse proto.InternalMessageInfo

type CreateNodeRequest struct {
	// The password in utf-8 with which to encrypt the new xud node key as well
	// as any uninitialized underlying wallets.
	Password             string   `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateNodeRequest) Reset()         { *m = CreateNodeRequest{} }
func (m *CreateNodeRequest) String() string { return proto.CompactTextString(m) }
func (*CreateNodeRequest) ProtoMessage()    {}
func (*CreateNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{10}
}

func (m *CreateNodeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateNodeRequest.Unmarshal(m, b)
}
func (m *CreateNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateNodeRequest.Marshal(b, m, deterministic)
}
func (m *CreateNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateNodeRequest.Merge(m, src)
}
func (m *CreateNodeRequest) XXX_Size() int {
	return xxx_messageInfo_CreateNodeRequest.Size(m)
}
func (m *CreateNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateNodeRequest proto.InternalMessageInfo

func (m *CreateNodeRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type CreateNodeResponse struct {
	// The 24 word mnemonic to recover the xud identity key and underlying wallets
	SeedMnemonic []string `protobuf:"bytes,1,rep,name=seed_mnemonic,json=seedMnemonic,proto3" json:"seed_mnemonic,omitempty"`
	// The list of lnd clients that were initialized.
	InitializedLnds []string `protobuf:"bytes,2,rep,name=initialized_lnds,json=initializedLnds,proto3" json:"initialized_lnds,omitempty"`
	// Whether raiden was initialized.
	InitializedRaiden    bool     `protobuf:"varint,3,opt,name=initialized_raiden,json=initializedRaiden,proto3" json:"initialized_raiden,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateNodeResponse) Reset()         { *m = CreateNodeResponse{} }
func (m *CreateNodeResponse) String() string { return proto.CompactTextString(m) }
func (*CreateNodeResponse) ProtoMessage()    {}
func (*CreateNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{11}
}

func (m *CreateNodeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateNodeResponse.Unmarshal(m, b)
}
func (m *CreateNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateNodeResponse.Marshal(b, m, deterministic)
}
func (m *CreateNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateNodeResponse.Merge(m, src)
}
func (m *CreateNodeResponse) XXX_Size() int {
	return xxx_messageInfo_CreateNodeResponse.Size(m)
}
func (m *CreateNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateNodeResponse proto.InternalMessageInfo

func (m *CreateNodeResponse) GetSeedMnemonic() []string {
	if m != nil {
		return m.SeedMnemonic
	}
	return nil
}

func (m *CreateNodeResponse) GetInitializedLnds() []string {
	if m != nil {
		return m.InitializedLnds
	}
	return nil
}

func (m *CreateNodeResponse) GetInitializedRaiden() bool {
	if m != nil {
		return m.InitializedRaiden
	}
	return false
}

type Currency struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	// The payment channel network client to use for executing swaps.
	SwapClient Currency_SwapClient `protobuf:"varint,2,opt,name=swap_client,proto3,enum=xudrpc.Currency_SwapClient" json:"swap_client,omitempty"`
	// The contract address for layered tokens such as ERC20.
	TokenAddress string `protobuf:"bytes,3,opt,name=token_address,proto3" json:"token_address,omitempty"`
	// The number of places to the right of the decimal point of the smallest subunit of the currency.
	// For example, BTC, LTC, and others where the smallest subunits (satoshis) are 0.00000001 full
	// units (bitcoins) have 8 decimal places. ETH has 18. This can be thought of as the base 10
	// exponent of the smallest subunit expressed as a positive integer. A default value of 8 is
	// used if unspecified.
	DecimalPlaces        uint32   `protobuf:"varint,4,opt,name=decimal_places,proto3" json:"decimal_places,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Currency) Reset()         { *m = Currency{} }
func (m *Currency) String() string { return proto.CompactTextString(m) }
func (*Currency) ProtoMessage()    {}
func (*Currency) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{12}
}

func (m *Currency) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Currency.Unmarshal(m, b)
}
func (m *Currency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Currency.Marshal(b, m, deterministic)
}
func (m *Currency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Currency.Merge(m, src)
}
func (m *Currency) XXX_Size() int {
	return xxx_messageInfo_Currency.Size(m)
}
func (m *Currency) XXX_DiscardUnknown() {
	xxx_messageInfo_Currency.DiscardUnknown(m)
}

var xxx_messageInfo_Currency proto.InternalMessageInfo

func (m *Currency) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Currency) GetSwapClient() Currency_SwapClient {
	if m != nil {
		return m.SwapClient
	}
	return Currency_LND
}

func (m *Currency) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *Currency) GetDecimalPlaces() uint32 {
	if m != nil {
		return m.DecimalPlaces
	}
	return 0
}

type DiscoverNodesRequest struct {
	// The node pub key of the peer to discover nodes from.
	PeerPubKey           string   `protobuf:"bytes,1,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiscoverNodesRequest) Reset()         { *m = DiscoverNodesRequest{} }
func (m *DiscoverNodesRequest) String() string { return proto.CompactTextString(m) }
func (*DiscoverNodesRequest) ProtoMessage()    {}
func (*DiscoverNodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{13}
}

func (m *DiscoverNodesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DiscoverNodesRequest.Unmarshal(m, b)
}
func (m *DiscoverNodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DiscoverNodesRequest.Marshal(b, m, deterministic)
}
func (m *DiscoverNodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverNodesRequest.Merge(m, src)
}
func (m *DiscoverNodesRequest) XXX_Size() int {
	return xxx_messageInfo_DiscoverNodesRequest.Size(m)
}
func (m *DiscoverNodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverNodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverNodesRequest proto.InternalMessageInfo

func (m *DiscoverNodesRequest) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

type DiscoverNodesResponse struct {
	NumNodes             uint32   `protobuf:"varint,1,opt,name=num_nodes,proto3" json:"num_nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiscoverNodesResponse) Reset()         { *m = DiscoverNodesResponse{} }
func (m *DiscoverNodesResponse) String() string { return proto.CompactTextString(m) }
func (*DiscoverNodesResponse) ProtoMessage()    {}
func (*DiscoverNodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{14}
}

func (m *DiscoverNodesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DiscoverNodesResponse.Unmarshal(m, b)
}
func (m *DiscoverNodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DiscoverNodesResponse.Marshal(b, m, deterministic)
}
func (m *DiscoverNodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverNodesResponse.Merge(m, src)
}
func (m *DiscoverNodesResponse) XXX_Size() int {
	return xxx_messageInfo_DiscoverNodesResponse.Size(m)
}
func (m *DiscoverNodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverNodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverNodesResponse proto.InternalMessageInfo

func (m *DiscoverNodesResponse) GetNumNodes() uint32 {
	if m != nil {
		return m.NumNodes
	}
	return 0
}

type ExecuteSwapRequest struct {
	// The order id of the maker order.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The trading pair of the swap orders.
	PairId string `protobuf:"bytes,2,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The node pub key of the peer which owns the maker order. This is optional but helps locate the order more quickly.
	PeerPubKey string `protobuf:"bytes,3,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	// The quantity to swap denominated in satoshis. The whole order will be swapped if unspecified.
	Quantity             uint64   `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteSwapRequest) Reset()         { *m = ExecuteSwapRequest{} }
func (m *ExecuteSwapRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteSwapRequest) ProtoMessage()    {}
func (*ExecuteSwapRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{15}
}

func (m *ExecuteSwapRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteSwapRequest.Unmarshal(m, b)
}
func (m *ExecuteSwapRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteSwapRequest.Marshal(b, m, deterministic)
}
func (m *ExecuteSwapRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteSwapRequest.Merge(m, src)
}
func (m *ExecuteSwapRequest) XXX_Size() int {
	return xxx_messageInfo_ExecuteSwapRequest.Size(m)
}
func (m *ExecuteSwapRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteSwapRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteSwapRequest proto.InternalMessageInfo

func (m *ExecuteSwapRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *ExecuteSwapRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *ExecuteSwapRequest) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *ExecuteSwapRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type GetBalanceRequest struct {
	// The ticker symbol of the currency to query for, if unspecified then balances for all supported
	// currencies are queried.
	Currency             string   `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBalanceRequest) Reset()         { *m = GetBalanceRequest{} }
func (m *GetBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*GetBalanceRequest) ProtoMessage()    {}
func (*GetBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{16}
}

func (m *GetBalanceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetBalanceRequest.Unmarshal(m, b)
}
func (m *GetBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetBalanceRequest.Marshal(b, m, deterministic)
}
func (m *GetBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceRequest.Merge(m, src)
}
func (m *GetBalanceRequest) XXX_Size() int {
	return xxx_messageInfo_GetBalanceRequest.Size(m)
}
func (m *GetBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceRequest proto.InternalMessageInfo

func (m *GetBalanceRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type GetBalanceResponse struct {
	// A map between currency ticker symbols and their balances.
	Balances             map[string]*Balance `protobuf:"bytes,1,rep,name=balances,json=orders,proto3" json:"balances,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetBalanceResponse) Reset()         { *m = GetBalanceResponse{} }
func (m *GetBalanceResponse) String() string { return proto.CompactTextString(m) }
func (*GetBalanceResponse) ProtoMessage()    {}
func (*GetBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{17}
}

func (m *GetBalanceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetBalanceResponse.Unmarshal(m, b)
}
func (m *GetBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetBalanceResponse.Marshal(b, m, deterministic)
}
func (m *GetBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceResponse.Merge(m, src)
}
func (m *GetBalanceResponse) XXX_Size() int {
	return xxx_messageInfo_GetBalanceResponse.Size(m)
}
func (m *GetBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceResponse proto.InternalMessageInfo

func (m *GetBalanceResponse) GetBalances() map[string]*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type GetInfoRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetInfoRequest) Reset()         { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()    {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{18}
}

func (m *GetInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInfoRequest.Unmarshal(m, b)
}
func (m *GetInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInfoRequest.Marshal(b, m, deterministic)
}
func (m *GetInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInfoRequest.Merge(m, src)
}
func (m *GetInfoRequest) XXX_Size() int {
	return xxx_messageInfo_GetInfoRequest.Size(m)
}
func (m *GetInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetInfoRequest proto.InternalMessageInfo

type GetInfoResponse struct {
	// The version of this instance of xud.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The node pub key of this node.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	// A list of uris that can be used to connect to this node. These are shared with peers.
	Uris []string `protobuf:"bytes,3,rep,name=uris,proto3" json:"uris,omitempty"`
	// The number of currently connected peers.
	NumPeers uint32 `protobuf:"varint,4,opt,name=num_peers,proto3" json:"num_peers,omitempty"`
	// The number of supported trading pairs.
	NumPairs uint32 `protobuf:"varint,5,opt,name=num_pairs,proto3" json:"num_pairs,omitempty"`
	// The number of active, standing orders in the order book.
	Orders *OrdersCount        `protobuf:"bytes,6,opt,name=orders,proto3" json:"orders,omitempty"`
	Lnd    map[string]*LndInfo `protobuf:"bytes,7,rep,name=lnd,proto3" json:"lnd,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Raiden *RaidenInfo         `protobuf:"bytes,8,opt,name=raiden,proto3" json:"raiden,omitempty"`
	// The alias of this instance of xud.
	Alias string `protobuf:"bytes,9,opt,name=alias,proto3" json:"alias,omitempty"`
	// The network of this node.
	Network              string   `protobuf:"bytes,10,opt,name=network,proto3" json:"network,omitempty"`
	PendingSwapHashes    []string `protobuf:"bytes,11,rep,name=pending_swap_hashes,proto3" json:"pending_swap_hashes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetInfoResponse) Reset()         { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()    {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{19}
}

func (m *GetInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInfoResponse.Unmarshal(m, b)
}
func (m *GetInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInfoResponse.Marshal(b, m, deterministic)
}
func (m *GetInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInfoResponse.Merge(m, src)
}
func (m *GetInfoResponse) XXX_Size() int {
	return xxx_messageInfo_GetInfoResponse.Size(m)
}
func (m *GetInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetInfoResponse proto.InternalMessageInfo

func (m *GetInfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetInfoResponse) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *GetInfoResponse) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *GetInfoResponse) GetNumPeers() uint32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *GetInfoResponse) GetNumPairs() uint32 {
	if m != nil {
		return m.NumPairs
	}
	return 0
}

func (m *GetInfoResponse) GetOrders() *OrdersCount {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *GetInfoResponse) GetLnd() map[string]*LndInfo {
	if m != nil {
		return m.Lnd
	}
	return nil
}

func (m *GetInfoResponse) GetRaiden() *RaidenInfo {
	if m != nil {
		return m.Raiden
	}
	return nil
}

func (m *GetInfoResponse) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *GetInfoResponse) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *GetInfoResponse) GetPendingSwapHashes() []string {
	if m != nil {
		return m.PendingSwapHashes
	}
	return nil
}

type GetNodeInfoRequest struct {
	// The node pub key of the node for which to get information.
	NodePubKey           string   `protobuf:"bytes,1,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetNodeInfoRequest) Reset()         { *m = GetNodeInfoRequest{} }
func (m *GetNodeInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetNodeInfoRequest) ProtoMessage()    {}
func (*GetNodeInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{20}
}

func (m *GetNodeInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNodeInfoRequest.Unmarshal(m, b)
}
func (m *GetNodeInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNodeInfoRequest.Marshal(b, m, deterministic)
}
func (m *GetNodeInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNodeInfoRequest.Merge(m, src)
}
func (m *GetNodeInfoRequest) XXX_Size() int {
	return xxx_messageInfo_GetNodeInfoRequest.Size(m)
}
func (m *GetNodeInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNodeInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetNodeInfoRequest proto.InternalMessageInfo

func (m *GetNodeInfoRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type GetNodeInfoResponse struct {
	// The node's reputation score. Points are subtracted for unexpected or potentially malicious
	// behavior. Points are added when swaps are successfully executed.
	ReputationScore int32 `protobuf:"zigzag32,1,opt,name=reputationScore,json=reputation,proto3" json:"reputationScore,omitempty"`
	// Whether the node is currently banned.
	Banned               bool     `protobuf:"varint,2,opt,name=banned,proto3" json:"banned,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetNodeInfoResponse) Reset()         { *m = GetNodeInfoResponse{} }
func (m *GetNodeInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetNodeInfoResponse) ProtoMessage()    {}
func (*GetNodeInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{21}
}

func (m *GetNodeInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNodeInfoResponse.Unmarshal(m, b)
}
func (m *GetNodeInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNodeInfoResponse.Marshal(b, m, deterministic)
}
func (m *GetNodeInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNodeInfoResponse.Merge(m, src)
}
func (m *GetNodeInfoResponse) XXX_Size() int {
	return xxx_messageInfo_GetNodeInfoResponse.Size(m)
}
func (m *GetNodeInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNodeInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetNodeInfoResponse proto.InternalMessageInfo

func (m *GetNodeInfoResponse) GetReputationScore() int32 {
	if m != nil {
		return m.ReputationScore
	}
	return 0
}

func (m *GetNodeInfoResponse) GetBanned() bool {
	if m != nil {
		return m.Banned
	}
	return false
}

type ListCurrenciesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListCurrenciesRequest) Reset()         { *m = ListCurrenciesRequest{} }
func (m *ListCurrenciesRequest) String() string { return proto.CompactTextString(m) }
func (*ListCurrenciesRequest) ProtoMessage()    {}
func (*ListCurrenciesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{22}
}

func (m *ListCurrenciesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListCurrenciesRequest.Unmarshal(m, b)
}
func (m *ListCurrenciesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListCurrenciesRequest.Marshal(b, m, deterministic)
}
func (m *ListCurrenciesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCurrenciesRequest.Merge(m, src)
}
func (m *ListCurrenciesRequest) XXX_Size() int {
	return xxx_messageInfo_ListCurrenciesRequest.Size(m)
}
func (m *ListCurrenciesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCurrenciesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCurrenciesRequest proto.InternalMessageInfo

type ListCurrenciesResponse struct {
	// The list of available currencies in the orderbook.
	Currencies           []*Currency `protobuf:"bytes,1,rep,name=currencies,proto3" json:"currencies,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListCurrenciesResponse) Reset()         { *m = ListCurrenciesResponse{} }
func (m *ListCurrenciesResponse) String() string { return proto.CompactTextString(m) }
func (*ListCurrenciesResponse) ProtoMessage()    {}
func (*ListCurrenciesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{23}
}

func (m *ListCurrenciesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListCurrenciesResponse.Unmarshal(m, b)
}
func (m *ListCurrenciesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListCurrenciesResponse.Marshal(b, m, deterministic)
}
func (m *ListCurrenciesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCurrenciesResponse.Merge(m, src)
}
func (m *ListCurrenciesResponse) XXX_Size() int {
	return xxx_messageInfo_ListCurrenciesResponse.Size(m)
}
func (m *ListCurrenciesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCurrenciesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListCurrenciesResponse proto.InternalMessageInfo

func (m *ListCurrenciesResponse) GetCurrencies() []*Currency {
	if m != nil {
		return m.Currencies
	}
	return nil
}

type ListOrdersRequest struct {
	// The trading pair for which to retrieve orders.
	PairId string `protobuf:"bytes,1,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// Whether only own, only peer or both orders should be included in result.
	Owner ListOrdersRequest_Owner `protobuf:"varint,2,opt,name=owner,proto3,enum=xudrpc.ListOrdersRequest_Owner" json:"owner,omitempty"`
	// The maximum number of orders to return from each side of the order book.
	Limit                uint32   `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListOrdersRequest) Reset()         { *m = ListOrdersRequest{} }
func (m *ListOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*ListOrdersRequest) ProtoMessage()    {}
func (*ListOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{24}
}

func (m *ListOrdersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListOrdersRequest.Unmarshal(m, b)
}
func (m *ListOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListOrdersRequest.Marshal(b, m, deterministic)
}
func (m *ListOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersRequest.Merge(m, src)
}
func (m *ListOrdersRequest) XXX_Size() int {
	return xxx_messageInfo_ListOrdersRequest.Size(m)
}
func (m *ListOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersRequest proto.InternalMessageInfo

func (m *ListOrdersRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *ListOrdersRequest) GetOwner() ListOrdersRequest_Owner {
	if m != nil {
		return m.Owner
	}
	return ListOrdersRequest_BOTH
}

func (m *ListOrdersRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ListOrdersResponse struct {
	// A map between pair ids and their buy and sell orders.
	Orders               map[string]*Orders `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ListOrdersResponse) Reset()         { *m = ListOrdersResponse{} }
func (m *ListOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*ListOrdersResponse) ProtoMessage()    {}
func (*ListOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{25}
}

func (m *ListOrdersResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListOrdersResponse.Unmarshal(m, b)
}
func (m *ListOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListOrdersResponse.Marshal(b, m, deterministic)
}
func (m *ListOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersResponse.Merge(m, src)
}
func (m *ListOrdersResponse) XXX_Size() int {
	return xxx_messageInfo_ListOrdersResponse.Size(m)
}
func (m *ListOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersResponse proto.InternalMessageInfo

func (m *ListOrdersResponse) GetOrders() map[string]*Orders {
	if m != nil {
		return m.Orders
	}
	return nil
}

type ListPairsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPairsRequest) Reset()         { *m = ListPairsRequest{} }
func (m *ListPairsRequest) String() string { return proto.CompactTextString(m) }
func (*ListPairsRequest) ProtoMessage()    {}
func (*ListPairsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{26}
}

func (m *ListPairsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPairsRequest.Unmarshal(m, b)
}
func (m *ListPairsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPairsRequest.Marshal(b, m, deterministic)
}
func (m *ListPairsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPairsRequest.Merge(m, src)
}
func (m *ListPairsRequest) XXX_Size() int {
	return xxx_messageInfo_ListPairsRequest.Size(m)
}
func (m *ListPairsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPairsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPairsRequest proto.InternalMessageInfo

type ListPairsResponse struct {
	// The list of supported trading pair tickers in formats like "LTC/BTC".
	Pairs                []string `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPairsResponse) Reset()         { *m = ListPairsResponse{} }
func (m *ListPairsResponse) String() string { return proto.CompactTextString(m) }
func (*ListPairsResponse) ProtoMessage()    {}
func (*ListPairsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{27}
}

func (m *ListPairsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPairsResponse.Unmarshal(m, b)
}
func (m *ListPairsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPairsResponse.Marshal(b, m, deterministic)
}
func (m *ListPairsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPairsResponse.Merge(m, src)
}
func (m *ListPairsResponse) XXX_Size() int {
	return xxx_messageInfo_ListPairsResponse.Size(m)
}
func (m *ListPairsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPairsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListPairsResponse proto.InternalMessageInfo

func (m *ListPairsResponse) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type ListPeersRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPeersRequest) Reset()         { *m = ListPeersRequest{} }
func (m *ListPeersRequest) String() string { return proto.CompactTextString(m) }
func (*ListPeersRequest) ProtoMessage()    {}
func (*ListPeersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{28}
}

func (m *ListPeersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPeersRequest.Unmarshal(m, b)
}
func (m *ListPeersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPeersRequest.Marshal(b, m, deterministic)
}
func (m *ListPeersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPeersRequest.Merge(m, src)
}
func (m *ListPeersRequest) XXX_Size() int {
	return xxx_messageInfo_ListPeersRequest.Size(m)
}
func (m *ListPeersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPeersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPeersRequest proto.InternalMessageInfo

type ListPeersResponse struct {
	// The list of connected peers.
	Peers                []*Peer  `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPeersResponse) Reset()         { *m = ListPeersResponse{} }
func (m *ListPeersResponse) String() string { return proto.CompactTextString(m) }
func (*ListPeersResponse) ProtoMessage()    {}
func (*ListPeersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{29}
}

func (m *ListPeersResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPeersResponse.Unmarshal(m, b)
}
func (m *ListPeersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPeersResponse.Marshal(b, m, deterministic)
}
func (m *ListPeersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPeersResponse.Merge(m, src)
}
func (m *ListPeersResponse) XXX_Size() int {
	return xxx_messageInfo_ListPeersResponse.Size(m)
}
func (m *ListPeersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPeersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListPeersResponse proto.InternalMessageInfo

func (m *ListPeersResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type ListTradesRequest struct {
	// The maximum number of trades to return
	Limit                int32    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTradesRequest) Reset()         { *m = ListTradesRequest{} }
func (m *ListTradesRequest) String() string { return proto.CompactTextString(m) }
func (*ListTradesRequest) ProtoMessage()    {}
func (*ListTradesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{30}
}

func (m *ListTradesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListTradesRequest.Unmarshal(m, b)
}
func (m *ListTradesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListTradesRequest.Marshal(b, m, deterministic)
}
func (m *ListTradesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTradesRequest.Merge(m, src)
}
func (m *ListTradesRequest) XXX_Size() int {
	return xxx_messageInfo_ListTradesRequest.Size(m)
}
func (m *ListTradesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTradesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTradesRequest proto.InternalMessageInfo

func (m *ListTradesRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ListTradesResponse struct {
	Trades               []*Trade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTradesResponse) Reset()         { *m = ListTradesResponse{} }
func (m *ListTradesResponse) String() string { return proto.CompactTextString(m) }
func (*ListTradesResponse) ProtoMessage()    {}
func (*ListTradesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{31}
}

func (m *ListTradesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListTradesResponse.Unmarshal(m, b)
}
func (m *ListTradesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListTradesResponse.Marshal(b, m, deterministic)
}
func (m *ListTradesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTradesResponse.Merge(m, src)
}
func (m *ListTradesResponse) XXX_Size() int {
	return xxx_messageInfo_ListTradesResponse.Size(m)
}
func (m *ListTradesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTradesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTradesResponse proto.InternalMessageInfo

func (m *ListTradesResponse) GetTrades() []*Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

type LndInfo struct {
	Status               string    `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Channels             *Channels `protobuf:"bytes,2,opt,name=channels,proto3" json:"channels,omitempty"`
	Chains               []*Chain  `protobuf:"bytes,3,rep,name=chains,proto3" json:"chains,omitempty"`
	Blockheight          uint32    `protobuf:"varint,4,opt,name=blockheight,proto3" json:"blockheight,omitempty"`
	Uris                 []string  `protobuf:"bytes,5,rep,name=uris,proto3" json:"uris,omitempty"`
	Version              string    `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	Alias                string    `protobuf:"bytes,7,opt,name=alias,proto3" json:"alias,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LndInfo) Reset()         { *m = LndInfo{} }
func (m *LndInfo) String() string { return proto.CompactTextString(m) }
func (*LndInfo) ProtoMessage()    {}
func (*LndInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{32}
}

func (m *LndInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LndInfo.Unmarshal(m, b)
}
func (m *LndInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LndInfo.Marshal(b, m, deterministic)
}
func (m *LndInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LndInfo.Merge(m, src)
}
func (m *LndInfo) XXX_Size() int {
	return xxx_messageInfo_LndInfo.Size(m)
}
func (m *LndInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LndInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LndInfo proto.InternalMessageInfo

func (m *LndInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *LndInfo) GetChannels() *Channels {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *LndInfo) GetChains() []*Chain {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *LndInfo) GetBlockheight() uint32 {
	if m != nil {
		return m.Blockheight
	}
	return 0
}

func (m *LndInfo) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *LndInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LndInfo) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type OpenChannelRequest struct {
	// The node pub key of the peer with which to open channel with.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key,json=peer_pub_key,proto3" json:"node_pub_key,omitempty"`
	// The ticker symbol of the currency to open the channel for.
	Currency string `protobuf:"bytes,2,opt,name=currency,proto3" json:"currency,omitempty"`
	// The amount of the channel denominated in satoshis.
	Amount               int64    `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenChannelRequest) Reset()         { *m = OpenChannelRequest{} }
func (m *OpenChannelRequest) String() string { return proto.CompactTextString(m) }
func (*OpenChannelRequest) ProtoMessage()    {}
func (*OpenChannelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{33}
}

func (m *OpenChannelRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenChannelRequest.Unmarshal(m, b)
}
func (m *OpenChannelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenChannelRequest.Marshal(b, m, deterministic)
}
func (m *OpenChannelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenChannelRequest.Merge(m, src)
}
func (m *OpenChannelRequest) XXX_Size() int {
	return xxx_messageInfo_OpenChannelRequest.Size(m)
}
func (m *OpenChannelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenChannelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenChannelRequest proto.InternalMessageInfo

func (m *OpenChannelRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *OpenChannelRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *OpenChannelRequest) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type OpenChannelResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenChannelResponse) Reset()         { *m = OpenChannelResponse{} }
func (m *OpenChannelResponse) String() string { return proto.CompactTextString(m) }
func (*OpenChannelResponse) ProtoMessage()    {}
func (*OpenChannelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{34}
}

func (m *OpenChannelResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenChannelResponse.Unmarshal(m, b)
}
func (m *OpenChannelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenChannelResponse.Marshal(b, m, deterministic)
}
func (m *OpenChannelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenChannelResponse.Merge(m, src)
}
func (m *OpenChannelResponse) XXX_Size() int {
	return xxx_messageInfo_OpenChannelResponse.Size(m)
}
func (m *OpenChannelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenChannelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OpenChannelResponse proto.InternalMessageInfo

type Order struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price,proto3" json:"price,omitempty"`
	// The quantity of the order in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair that this order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// A UUID for this order.
	Id string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to OwnOrPeer:
	//	*Order_PeerPubKey
	//	*Order_LocalId
	OwnOrPeer isOrder_OwnOrPeer `protobuf_oneof:"own_or_peer"`
	// The epoch time when this order was created.
	CreatedAt uint64 `protobuf:"varint,7,opt,name=created_at,proto3" json:"created_at,omitempty"`
	// Whether this order is a buy or sell
	Side OrderSide `protobuf:"varint,8,opt,name=side,proto3,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// Whether this order is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,9,opt,name=is_own_order,proto3" json:"is_own_order,omitempty"`
	// The quantity on hold pending swap execution.
	Hold                 uint64   `protobuf:"varint,10,opt,name=hold,proto3" json:"hold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{35}
}

func (m *Order) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order.Unmarshal(m, b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order.Marshal(b, m, deterministic)
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return xxx_messageInfo_Order.Size(m)
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Order) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *Order) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type isOrder_OwnOrPeer interface {
	isOrder_OwnOrPeer()
}

type Order_PeerPubKey struct {
	PeerPubKey string `protobuf:"bytes,5,opt,name=peer_pub_key,proto3,oneof"`
}

type Order_LocalId struct {
	LocalId string `protobuf:"bytes,6,opt,name=local_id,proto3,oneof"`
}

func (*Order_PeerPubKey) isOrder_OwnOrPeer() {}

func (*Order_LocalId) isOrder_OwnOrPeer() {}

func (m *Order) GetOwnOrPeer() isOrder_OwnOrPeer {
	if m != nil {
		return m.OwnOrPeer
	}
	return nil
}

func (m *Order) GetPeerPubKey() string {
	if x, ok := m.GetOwnOrPeer().(*Order_PeerPubKey); ok {
		return x.PeerPubKey
	}
	return ""
}

func (m *Order) GetLocalId() string {
	if x, ok := m.GetOwnOrPeer().(*Order_LocalId); ok {
		return x.LocalId
	}
	return ""
}

func (m *Order) GetCreatedAt() uint64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

func (m *Order) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

func (m *Order) GetHold() uint64 {
	if m != nil {
		return m.Hold
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Order) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Order_PeerPubKey)(nil),
		(*Order_LocalId)(nil),
	}
}

type OrderRemoval struct {
	// The quantity removed from the order.
	Quantity uint64 `protobuf:"varint,1,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The global UUID for the order.
	OrderId string `protobuf:"bytes,3,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The local id for the order, if applicable.
	LocalId string `protobuf:"bytes,4,opt,name=local_id,proto3" json:"local_id,omitempty"`
	// Whether the order being removed is a local own order or a remote peer order.
	IsOwnOrder           bool     `protobuf:"varint,5,opt,name=is_own_order,proto3" json:"is_own_order,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderRemoval) Reset()         { *m = OrderRemoval{} }
func (m *OrderRemoval) String() string { return proto.CompactTextString(m) }
func (*OrderRemoval) ProtoMessage()    {}
func (*OrderRemoval) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{36}
}

func (m *OrderRemoval) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderRemoval.Unmarshal(m, b)
}
func (m *OrderRemoval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderRemoval.Marshal(b, m, deterministic)
}
func (m *OrderRemoval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderRemoval.Merge(m, src)
}
func (m *OrderRemoval) XXX_Size() int {
	return xxx_messageInfo_OrderRemoval.Size(m)
}
func (m *OrderRemoval) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderRemoval.DiscardUnknown(m)
}

var xxx_messageInfo_OrderRemoval proto.InternalMessageInfo

func (m *OrderRemoval) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *OrderRemoval) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *OrderRemoval) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderRemoval) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *OrderRemoval) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

type Orders struct {
	// A list of buy orders sorted by descending price.
	BuyOrders []*Order `protobuf:"bytes,1,rep,name=buy_orders,proto3" json:"buy_orders,omitempty"`
	// A list of sell orders sorted by ascending price.
	SellOrders           []*Order `protobuf:"bytes,2,rep,name=sell_orders,proto3" json:"sell_orders,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Orders) Reset()         { *m = Orders{} }
func (m *Orders) String() string { return proto.CompactTextString(m) }
func (*Orders) ProtoMessage()    {}
func (*Orders) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{37}
}

func (m *Orders) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Orders.Unmarshal(m, b)
}
func (m *Orders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Orders.Marshal(b, m, deterministic)
}
func (m *Orders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Orders.Merge(m, src)
}
func (m *Orders) XXX_Size() int {
	return xxx_messageInfo_Orders.Size(m)
}
func (m *Orders) XXX_DiscardUnknown() {
	xxx_messageInfo_Orders.DiscardUnknown(m)
}

var xxx_messageInfo_Orders proto.InternalMessageInfo

func (m *Orders) GetBuyOrders() []*Order {
	if m != nil {
		return m.BuyOrders
	}
	return nil
}

func (m *Orders) GetSellOrders() []*Order {
	if m != nil {
		return m.SellOrders
	}
	return nil
}

type OrdersCount struct {
	// The number of orders belonging to remote xud nodes.
	Peer uint32 `protobuf:"varint,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// The number of orders belonging to our local xud node.
	Own                  uint32   `protobuf:"varint,2,opt,name=own,proto3" json:"own,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrdersCount) Reset()         { *m = OrdersCount{} }
func (m *OrdersCount) String() string { return proto.CompactTextString(m) }
func (*OrdersCount) ProtoMessage()    {}
func (*OrdersCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{38}
}

func (m *OrdersCount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrdersCount.Unmarshal(m, b)
}
func (m *OrdersCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrdersCount.Marshal(b, m, deterministic)
}
func (m *OrdersCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrdersCount.Merge(m, src)
}
func (m *OrdersCount) XXX_Size() int {
	return xxx_messageInfo_OrdersCount.Size(m)
}
func (m *OrdersCount) XXX_DiscardUnknown() {
	xxx_messageInfo_OrdersCount.DiscardUnknown(m)
}

var xxx_messageInfo_OrdersCount proto.InternalMessageInfo

func (m *OrdersCount) GetPeer() uint32 {
	if m != nil {
		return m.Peer
	}
	return 0
}

func (m *OrdersCount) GetOwn() uint32 {
	if m != nil {
		return m.Own
	}
	return 0
}

type OrderUpdate struct {
	// Types that are valid to be assigned to OrderUpdate:
	//	*OrderUpdate_Order
	//	*OrderUpdate_OrderRemoval
	OrderUpdate          isOrderUpdate_OrderUpdate `protobuf_oneof:"order_update"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *OrderUpdate) Reset()         { *m = OrderUpdate{} }
func (m *OrderUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderUpdate) ProtoMessage()    {}
func (*OrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{39}
}

func (m *OrderUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderUpdate.Unmarshal(m, b)
}
func (m *OrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderUpdate.Marshal(b, m, deterministic)
}
func (m *OrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderUpdate.Merge(m, src)
}
func (m *OrderUpdate) XXX_Size() int {
	return xxx_messageInfo_OrderUpdate.Size(m)
}
func (m *OrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderUpdate proto.InternalMessageInfo

type isOrderUpdate_OrderUpdate interface {
	isOrderUpdate_OrderUpdate()
}

type OrderUpdate_Order struct {
	Order *Order `protobuf:"bytes,1,opt,name=order,proto3,oneof"`
}

type OrderUpdate_OrderRemoval struct {
	OrderRemoval *OrderRemoval `protobuf:"bytes,2,opt,name=order_removal,proto3,oneof"`
}

func (*OrderUpdate_Order) isOrderUpdate_OrderUpdate() {}

func (*OrderUpdate_OrderRemoval) isOrderUpdate_OrderUpdate() {}

func (m *OrderUpdate) GetOrderUpdate() isOrderUpdate_OrderUpdate {
	if m != nil {
		return m.OrderUpdate
	}
	return nil
}

func (m *OrderUpdate) GetOrder() *Order {
	if x, ok := m.GetOrderUpdate().(*OrderUpdate_Order); ok {
		return x.Order
	}
	return nil
}

func (m *OrderUpdate) GetOrderRemoval() *OrderRemoval {
	if x, ok := m.GetOrderUpdate().(*OrderUpdate_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderUpdate_Order)(nil),
		(*OrderUpdate_OrderRemoval)(nil),
	}
}

type Peer struct {
	// The socket address with host and port for this peer.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The node pub key to uniquely identify this peer.
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	// A map of ticker symbols to lnd pub keys for this peer
	LndPubKeys map[string]string `protobuf:"bytes,3,rep,name=lnd_pub_keys,proto3" json:"lnd_pub_keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Indicates whether this peer was connected inbound.
	Inbound bool `protobuf:"varint,4,opt,name=inbound,proto3" json:"inbound,omitempty"`
	// A list of trading pair tickers supported by this peer.
	Pairs []string `protobuf:"bytes,5,rep,name=pairs,proto3" json:"pairs,omitempty"`
	// The version of xud being used by the peer.
	XudVersion string `protobuf:"bytes,6,opt,name=xud_version,proto3" json:"xud_version,omitempty"`
	// The time in seconds that we have been connected to this peer.
	SecondsConnected uint32 `protobuf:"varint,7,opt,name=seconds_connected,proto3" json:"seconds_connected,omitempty"`
	// The raiden address for this peer
	RaidenAddress        string   `protobuf:"bytes,8,opt,name=raiden_address,proto3" json:"raiden_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{40}
}

func (m *Peer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Peer.Unmarshal(m, b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return xxx_messageInfo_Peer.Size(m)
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Peer) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *Peer) GetLndPubKeys() map[string]string {
	if m != nil {
		return m.LndPubKeys
	}
	return nil
}

func (m *Peer) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *Peer) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *Peer) GetXudVersion() string {
	if m != nil {
		return m.XudVersion
	}
	return ""
}

func (m *Peer) GetSecondsConnected() uint32 {
	if m != nil {
		return m.SecondsConnected
	}
	return 0
}

func (m *Peer) GetRaidenAddress() string {
	if m != nil {
		return m.RaidenAddress
	}
	return ""
}

type PlaceOrderRequest struct {
	// The price of the order.
	Price float64 `protobuf:"fixed64,1,opt,name=price,proto3" json:"price,omitempty"`
	// The quantity of the order denominated in satoshis.
	Quantity uint64 `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair that the order is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The local id to assign to the order.
	OrderId string `protobuf:"bytes,4,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// Whether the order is a buy or sell.
	Side OrderSide `protobuf:"varint,5,opt,name=side,proto3,enum=xudrpc.OrderSide" json:"side,omitempty"`
	// The local id of an existing order to be replaced. If provided, the order must be successfully
	// found and removed before the new order is placed, otherwise an error is returned.
	ReplaceOrderId string `protobuf:"bytes,6,opt,name=replace_order_id,proto3" json:"replace_order_id,omitempty"`
	// Whether the order must be filled immediately and not allowed to enter the order book.
	ImmediateOrCancel    bool     `protobuf:"varint,7,opt,name=immediate_or_cancel,proto3" json:"immediate_or_cancel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlaceOrderRequest) Reset()         { *m = PlaceOrderRequest{} }
func (m *PlaceOrderRequest) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderRequest) ProtoMessage()    {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{41}
}

func (m *PlaceOrderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderRequest.Unmarshal(m, b)
}
func (m *PlaceOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderRequest.Marshal(b, m, deterministic)
}
func (m *PlaceOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderRequest.Merge(m, src)
}
func (m *PlaceOrderRequest) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderRequest.Size(m)
}
func (m *PlaceOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderRequest proto.InternalMessageInfo

func (m *PlaceOrderRequest) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *PlaceOrderRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *PlaceOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *PlaceOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *PlaceOrderRequest) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_BUY
}

func (m *PlaceOrderRequest) GetReplaceOrderId() string {
	if m != nil {
		return m.ReplaceOrderId
	}
	return ""
}

func (m *PlaceOrderRequest) GetImmediateOrCancel() bool {
	if m != nil {
		return m.ImmediateOrCancel
	}
	return false
}

type PlaceOrderResponse struct {
	// A list of own orders (or portions thereof) that matched the newly placed order.
	InternalMatches []*Order `protobuf:"bytes,1,rep,name=internal_matches,proto3" json:"internal_matches,omitempty"`
	// A list of successful swaps of peer orders that matched the newly placed order.
	SwapSuccesses []*SwapSuccess `protobuf:"bytes,2,rep,name=swap_successes,proto3" json:"swap_successes,omitempty"`
	// The remaining portion of the order, after matches, that enters the order book.
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order,proto3" json:"remaining_order,omitempty"`
	// A list of swap attempts that failed.
	SwapFailures         []*SwapFailure `protobuf:"bytes,4,rep,name=swap_failures,proto3" json:"swap_failures,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PlaceOrderResponse) Reset()         { *m = PlaceOrderResponse{} }
func (m *PlaceOrderResponse) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderResponse) ProtoMessage()    {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{42}
}

func (m *PlaceOrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderResponse.Unmarshal(m, b)
}
func (m *PlaceOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderResponse.Marshal(b, m, deterministic)
}
func (m *PlaceOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderResponse.Merge(m, src)
}
func (m *PlaceOrderResponse) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderResponse.Size(m)
}
func (m *PlaceOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderResponse proto.InternalMessageInfo

func (m *PlaceOrderResponse) GetInternalMatches() []*Order {
	if m != nil {
		return m.InternalMatches
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapSuccesses() []*SwapSuccess {
	if m != nil {
		return m.SwapSuccesses
	}
	return nil
}

func (m *PlaceOrderResponse) GetRemainingOrder() *Order {
	if m != nil {
		return m.RemainingOrder
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapFailures() []*SwapFailure {
	if m != nil {
		return m.SwapFailures
	}
	return nil
}

type PlaceOrderEvent struct {
	// Types that are valid to be assigned to Event:
	//	*PlaceOrderEvent_InternalMatch
	//	*PlaceOrderEvent_SwapSuccess
	//	*PlaceOrderEvent_RemainingOrder
	//	*PlaceOrderEvent_SwapFailure
	Event                isPlaceOrderEvent_Event `protobuf_oneof:"event"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *PlaceOrderEvent) Reset()         { *m = PlaceOrderEvent{} }
func (m *PlaceOrderEvent) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderEvent) ProtoMessage()    {}
func (*PlaceOrderEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{43}
}

func (m *PlaceOrderEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderEvent.Unmarshal(m, b)
}
func (m *PlaceOrderEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderEvent.Marshal(b, m, deterministic)
}
func (m *PlaceOrderEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderEvent.Merge(m, src)
}
func (m *PlaceOrderEvent) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderEvent.Size(m)
}
func (m *PlaceOrderEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderEvent.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderEvent proto.InternalMessageInfo

type isPlaceOrderEvent_Event interface {
	isPlaceOrderEvent_Event()
}

type PlaceOrderEvent_InternalMatch struct {
	InternalMatch *Order `protobuf:"bytes,1,opt,name=internal_match,proto3,oneof"`
}

type PlaceOrderEvent_SwapSuccess struct {
	SwapSuccess *SwapSuccess `protobuf:"bytes,2,opt,name=swap_success,proto3,oneof"`
}

type PlaceOrderEvent_RemainingOrder struct {
	RemainingOrder *Order `protobuf:"bytes,3,opt,name=remaining_order,proto3,oneof"`
}

type PlaceOrderEvent_SwapFailure struct {
	SwapFailure *SwapFailure `protobuf:"bytes,4,opt,name=swap_failure,proto3,oneof"`
}

func (*PlaceOrderEvent_InternalMatch) isPlaceOrderEvent_Event() {}

func (*PlaceOrderEvent_SwapSuccess) isPlaceOrderEvent_Event() {}

func (*PlaceOrderEvent_RemainingOrder) isPlaceOrderEvent_Event() {}

func (*PlaceOrderEvent_SwapFailure) isPlaceOrderEvent_Event() {}

func (m *PlaceOrderEvent) GetEvent() isPlaceOrderEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *PlaceOrderEvent) GetInternalMatch() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_InternalMatch); ok {
		return x.InternalMatch
	}
	return nil
}

func (m *PlaceOrderEvent) GetSwapSuccess() *SwapSuccess {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_SwapSuccess); ok {
		return x.SwapSuccess
	}
	return nil
}

func (m *PlaceOrderEvent) GetRemainingOrder() *Order {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_RemainingOrder); ok {
		return x.RemainingOrder
	}
	return nil
}

func (m *PlaceOrderEvent) GetSwapFailure() *SwapFailure {
	if x, ok := m.GetEvent().(*PlaceOrderEvent_SwapFailure); ok {
		return x.SwapFailure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlaceOrderEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlaceOrderEvent_InternalMatch)(nil),
		(*PlaceOrderEvent_SwapSuccess)(nil),
		(*PlaceOrderEvent_RemainingOrder)(nil),
		(*PlaceOrderEvent_SwapFailure)(nil),
	}
}

type RaidenInfo struct {
	Status               string    `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Address              string    `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Channels             *Channels `protobuf:"bytes,3,opt,name=channels,proto3" json:"channels,omitempty"`
	Version              string    `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Chain                string    `protobuf:"bytes,5,opt,name=chain,proto3" json:"chain,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RaidenInfo) Reset()         { *m = RaidenInfo{} }
func (m *RaidenInfo) String() string { return proto.CompactTextString(m) }
func (*RaidenInfo) ProtoMessage()    {}
func (*RaidenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{44}
}

func (m *RaidenInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RaidenInfo.Unmarshal(m, b)
}
func (m *RaidenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RaidenInfo.Marshal(b, m, deterministic)
}
func (m *RaidenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaidenInfo.Merge(m, src)
}
func (m *RaidenInfo) XXX_Size() int {
	return xxx_messageInfo_RaidenInfo.Size(m)
}
func (m *RaidenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RaidenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RaidenInfo proto.InternalMessageInfo

func (m *RaidenInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *RaidenInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaidenInfo) GetChannels() *Channels {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *RaidenInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RaidenInfo) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

type RemoveCurrencyRequest struct {
	// The ticker symbol for this currency such as BTC, LTC, ETH, etc...
	Currency             string   `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveCurrencyRequest) Reset()         { *m = RemoveCurrencyRequest{} }
func (m *RemoveCurrencyRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveCurrencyRequest) ProtoMessage()    {}
func (*RemoveCurrencyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{45}
}

func (m *RemoveCurrencyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveCurrencyRequest.Unmarshal(m, b)
}
func (m *RemoveCurrencyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveCurrencyRequest.Marshal(b, m, deterministic)
}
func (m *RemoveCurrencyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveCurrencyRequest.Merge(m, src)
}
func (m *RemoveCurrencyRequest) XXX_Size() int {
	return xxx_messageInfo_RemoveCurrencyRequest.Size(m)
}
func (m *RemoveCurrencyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveCurrencyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveCurrencyRequest proto.InternalMessageInfo

func (m *RemoveCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type RemoveCurrencyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveCurrencyResponse) Reset()         { *m = RemoveCurrencyResponse{} }
func (m *RemoveCurrencyResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveCurrencyResponse) ProtoMessage()    {}
func (*RemoveCurrencyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{46}
}

func (m *RemoveCurrencyResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveCurrencyResponse.Unmarshal(m, b)
}
func (m *RemoveCurrencyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveCurrencyResponse.Marshal(b, m, deterministic)
}
func (m *RemoveCurrencyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveCurrencyResponse.Merge(m, src)
}
func (m *RemoveCurrencyResponse) XXX_Size() int {
	return xxx_messageInfo_RemoveCurrencyResponse.Size(m)
}
func (m *RemoveCurrencyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveCurrencyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveCurrencyResponse proto.InternalMessageInfo

type RemoveOrderRequest struct {
	// The local id of the order to remove.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The quantity to remove from the order denominated in satoshis.
	// If zero or unspecified then the entire order is removed.
	Quantity             uint64   `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveOrderRequest) Reset()         { *m = RemoveOrderRequest{} }
func (m *RemoveOrderRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveOrderRequest) ProtoMessage()    {}
func (*RemoveOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{47}
}

func (m *RemoveOrderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveOrderRequest.Unmarshal(m, b)
}
func (m *RemoveOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveOrderRequest.Marshal(b, m, deterministic)
}
func (m *RemoveOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveOrderRequest.Merge(m, src)
}
func (m *RemoveOrderRequest) XXX_Size() int {
	return xxx_messageInfo_RemoveOrderRequest.Size(m)
}
func (m *RemoveOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveOrderRequest proto.InternalMessageInfo

func (m *RemoveOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *RemoveOrderRequest) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type RemoveOrderResponse struct {
	// Any portion of the order that was on hold due to ongoing swaps at the time of the request
	// and could not be removed until after the swaps finish.
	QuantityOnHold       uint64   `protobuf:"varint,1,opt,name=quantity_on_hold,json=hold,proto3" json:"quantity_on_hold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveOrderResponse) Reset()         { *m = RemoveOrderResponse{} }
func (m *RemoveOrderResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveOrderResponse) ProtoMessage()    {}
func (*RemoveOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{48}
}

func (m *RemoveOrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveOrderResponse.Unmarshal(m, b)
}
func (m *RemoveOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveOrderResponse.Marshal(b, m, deterministic)
}
func (m *RemoveOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveOrderResponse.Merge(m, src)
}
func (m *RemoveOrderResponse) XXX_Size() int {
	return xxx_messageInfo_RemoveOrderResponse.Size(m)
}
func (m *RemoveOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveOrderResponse proto.InternalMessageInfo

func (m *RemoveOrderResponse) GetQuantityOnHold() uint64 {
	if m != nil {
		return m.QuantityOnHold
	}
	return 0
}

type RemovePairRequest struct {
	// The trading pair ticker to remove in a format such as "LTC/BTC".
	PairId               string   `protobuf:"bytes,1,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemovePairRequest) Reset()         { *m = RemovePairRequest{} }
func (m *RemovePairRequest) String() string { return proto.CompactTextString(m) }
func (*RemovePairRequest) ProtoMessage()    {}
func (*RemovePairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{49}
}

func (m *RemovePairRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemovePairRequest.Unmarshal(m, b)
}
func (m *RemovePairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemovePairRequest.Marshal(b, m, deterministic)
}
func (m *RemovePairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePairRequest.Merge(m, src)
}
func (m *RemovePairRequest) XXX_Size() int {
	return xxx_messageInfo_RemovePairRequest.Size(m)
}
func (m *RemovePairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePairRequest proto.InternalMessageInfo

func (m *RemovePairRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type RemovePairResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemovePairResponse) Reset()         { *m = RemovePairResponse{} }
func (m *RemovePairResponse) String() string { return proto.CompactTextString(m) }
func (*RemovePairResponse) ProtoMessage()    {}
func (*RemovePairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{50}
}

func (m *RemovePairResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemovePairResponse.Unmarshal(m, b)
}
func (m *RemovePairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemovePairResponse.Marshal(b, m, deterministic)
}
func (m *RemovePairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePairResponse.Merge(m, src)
}
func (m *RemovePairResponse) XXX_Size() int {
	return xxx_messageInfo_RemovePairResponse.Size(m)
}
func (m *RemovePairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePairResponse proto.InternalMessageInfo

type RestoreNodeRequest struct {
	// The 24 word mnemonic to recover the xud identity key and underlying wallets
	SeedMnemonic []string `protobuf:"bytes,1,rep,name=seed_mnemonic,json=seedMnemonic,proto3" json:"seed_mnemonic,omitempty"`
	// The password in utf-8 with which to encrypt the restored xud node key as well
	// as any restored underlying wallets.
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	// A map between the currency of the LND and its multi channel SCB
	LndBackups map[string][]byte `protobuf:"bytes,3,rep,name=lnd_backups,json=lndBackups,proto3" json:"lnd_backups,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The Raiden database backup
	RaidenDatabase []byte `protobuf:"bytes,4,opt,name=raiden_database,json=raidenDatabase,proto3" json:"raiden_database,omitempty"`
	// Path to where the Raiden database backup should be written
	RaidenDatabasePath string `protobuf:"bytes,5,opt,name=raiden_database_path,json=raidenDatabasePath,proto3" json:"raiden_database_path,omitempty"`
	// The XUD database backup
	XudDatabase          []byte   `protobuf:"bytes,6,opt,name=xud_database,json=xudDatabase,proto3" json:"xud_database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RestoreNodeRequest) Reset()         { *m = RestoreNodeRequest{} }
func (m *RestoreNodeRequest) String() string { return proto.CompactTextString(m) }
func (*RestoreNodeRequest) ProtoMessage()    {}
func (*RestoreNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{51}
}

func (m *RestoreNodeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RestoreNodeRequest.Unmarshal(m, b)
}
func (m *RestoreNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RestoreNodeRequest.Marshal(b, m, deterministic)
}
func (m *RestoreNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreNodeRequest.Merge(m, src)
}
func (m *RestoreNodeRequest) XXX_Size() int {
	return xxx_messageInfo_RestoreNodeRequest.Size(m)
}
func (m *RestoreNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreNodeRequest proto.InternalMessageInfo

func (m *RestoreNodeRequest) GetSeedMnemonic() []string {
	if m != nil {
		return m.SeedMnemonic
	}
	return nil
}

func (m *RestoreNodeRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *RestoreNodeRequest) GetLndBackups() map[string][]byte {
	if m != nil {
		return m.LndBackups
	}
	return nil
}

func (m *RestoreNodeRequest) GetRaidenDatabase() []byte {
	if m != nil {
		return m.RaidenDatabase
	}
	return nil
}

func (m *RestoreNodeRequest) GetRaidenDatabasePath() string {
	if m != nil {
		return m.RaidenDatabasePath
	}
	return ""
}

func (m *RestoreNodeRequest) GetXudDatabase() []byte {
	if m != nil {
		return m.XudDatabase
	}
	return nil
}

type RestoreNodeResponse struct {
	// The list of lnd clients that were initialized.
	RestoredLnds []string `protobuf:"bytes,1,rep,name=restored_lnds,json=restoredLnds,proto3" json:"restored_lnds,omitempty"`
	// Whether raiden was initialized.
	RestoredRaiden       bool     `protobuf:"varint,2,opt,name=restored_raiden,json=restoredRaiden,proto3" json:"restored_raiden,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RestoreNodeResponse) Reset()         { *m = RestoreNodeResponse{} }
func (m *RestoreNodeResponse) String() string { return proto.CompactTextString(m) }
func (*RestoreNodeResponse) ProtoMessage()    {}
func (*RestoreNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{52}
}

func (m *RestoreNodeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RestoreNodeResponse.Unmarshal(m, b)
}
func (m *RestoreNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RestoreNodeResponse.Marshal(b, m, deterministic)
}
func (m *RestoreNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreNodeResponse.Merge(m, src)
}
func (m *RestoreNodeResponse) XXX_Size() int {
	return xxx_messageInfo_RestoreNodeResponse.Size(m)
}
func (m *RestoreNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreNodeResponse proto.InternalMessageInfo

func (m *RestoreNodeResponse) GetRestoredLnds() []string {
	if m != nil {
		return m.RestoredLnds
	}
	return nil
}

func (m *RestoreNodeResponse) GetRestoredRaiden() bool {
	if m != nil {
		return m.RestoredRaiden
	}
	return false
}

type ShutdownRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShutdownRequest) Reset()         { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()    {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{53}
}

func (m *ShutdownRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ShutdownRequest.Unmarshal(m, b)
}
func (m *ShutdownRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ShutdownRequest.Marshal(b, m, deterministic)
}
func (m *ShutdownRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShutdownRequest.Merge(m, src)
}
func (m *ShutdownRequest) XXX_Size() int {
	return xxx_messageInfo_ShutdownRequest.Size(m)
}
func (m *ShutdownRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShutdownRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShutdownRequest proto.InternalMessageInfo

type ShutdownResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShutdownResponse) Reset()         { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()    {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{54}
}

func (m *ShutdownResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ShutdownResponse.Unmarshal(m, b)
}
func (m *ShutdownResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ShutdownResponse.Marshal(b, m, deterministic)
}
func (m *ShutdownResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShutdownResponse.Merge(m, src)
}
func (m *ShutdownResponse) XXX_Size() int {
	return xxx_messageInfo_ShutdownResponse.Size(m)
}
func (m *ShutdownResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShutdownResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShutdownResponse proto.InternalMessageInfo

type SubscribeOrdersRequest struct {
	// Whether to transmit all existing active orders upon establishing the stream.
	Existing             bool     `protobuf:"varint,1,opt,name=existing,proto3" json:"existing,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeOrdersRequest) Reset()         { *m = SubscribeOrdersRequest{} }
func (m *SubscribeOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeOrdersRequest) ProtoMessage()    {}
func (*SubscribeOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{55}
}

func (m *SubscribeOrdersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeOrdersRequest.Unmarshal(m, b)
}
func (m *SubscribeOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeOrdersRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeOrdersRequest.Merge(m, src)
}
func (m *SubscribeOrdersRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeOrdersRequest.Size(m)
}
func (m *SubscribeOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeOrdersRequest proto.InternalMessageInfo

func (m *SubscribeOrdersRequest) GetExisting() bool {
	if m != nil {
		return m.Existing
	}
	return false
}

type SubscribeSwapsRequest struct {
	// Whether to include the results for swaps initiated via the PlaceOrder or ExecuteSwap calls.
	// These swap results are also returned in the responses for the respective calls.
	IncludeTaker         bool     `protobuf:"varint,1,opt,name=include_taker,proto3" json:"include_taker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeSwapsRequest) Reset()         { *m = SubscribeSwapsRequest{} }
func (m *SubscribeSwapsRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeSwapsRequest) ProtoMessage()    {}
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{56}
}

func (m *SubscribeSwapsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeSwapsRequest.Unmarshal(m, b)
}
func (m *SubscribeSwapsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeSwapsRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeSwapsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeSwapsRequest.Merge(m, src)
}
func (m *SubscribeSwapsRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeSwapsRequest.Size(m)
}
func (m *SubscribeSwapsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeSwapsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeSwapsRequest proto.InternalMessageInfo

func (m *SubscribeSwapsRequest) GetIncludeTaker() bool {
	if m != nil {
		return m.IncludeTaker
	}
	return false
}

type SwapFailure struct {
	// The global UUID for the order that failed the swap.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,proto3" json:"order_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The order quantity that was attempted to be swapped.
	Quantity uint64 `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The node pub key of the peer that we attempted to swap with.
	PeerPubKey string `protobuf:"bytes,4,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	// The reason why the swap failed.
	FailureReason        string   `protobuf:"bytes,5,opt,name=failure_reason,proto3" json:"failure_reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapFailure) Reset()         { *m = SwapFailure{} }
func (m *SwapFailure) String() string { return proto.CompactTextString(m) }
func (*SwapFailure) ProtoMessage()    {}
func (*SwapFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{57}
}

func (m *SwapFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapFailure.Unmarshal(m, b)
}
func (m *SwapFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapFailure.Marshal(b, m, deterministic)
}
func (m *SwapFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapFailure.Merge(m, src)
}
func (m *SwapFailure) XXX_Size() int {
	return xxx_messageInfo_SwapFailure.Size(m)
}
func (m *SwapFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapFailure.DiscardUnknown(m)
}

var xxx_messageInfo_SwapFailure proto.InternalMessageInfo

func (m *SwapFailure) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapFailure) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapFailure) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *SwapFailure) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *SwapFailure) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

type SwapSuccess struct {
	// The global UUID for the order that was swapped.
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// The local id for the order that was swapped.
	LocalId string `protobuf:"bytes,2,opt,name=local_id,proto3" json:"local_id,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,3,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	// The order quantity that was swapped.
	Quantity uint64 `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The hex-encoded payment hash for the swap.
	RHash string `protobuf:"bytes,5,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// The amount received denominated in satoshis.
	AmountReceived uint64 `protobuf:"varint,8,opt,name=amount_received,proto3" json:"amount_received,omitempty"`
	// The amount sent denominated in satoshis.
	AmountSent uint64 `protobuf:"varint,9,opt,name=amount_sent,proto3" json:"amount_sent,omitempty"`
	// The node pub key of the peer that executed this order.
	PeerPubKey string `protobuf:"bytes,10,opt,name=peer_pub_key,proto3" json:"peer_pub_key,omitempty"`
	// Our role in the swap, either MAKER or TAKER.
	Role SwapSuccess_Role `protobuf:"varint,11,opt,name=role,proto3,enum=xudrpc.SwapSuccess_Role" json:"role,omitempty"`
	// The ticker symbol of the currency received.
	CurrencyReceived string `protobuf:"bytes,12,opt,name=currency_received,proto3" json:"currency_received,omitempty"`
	// The ticker symbol of the currency sent.
	CurrencySent string `protobuf:"bytes,13,opt,name=currency_sent,proto3" json:"currency_sent,omitempty"`
	// The hex-encoded preimage.
	RPreimage string `protobuf:"bytes,14,opt,name=r_preimage,proto3" json:"r_preimage,omitempty"`
	// The price used for the swap.
	Price                float64  `protobuf:"fixed64,15,opt,name=price,proto3" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapSuccess) Reset()         { *m = SwapSuccess{} }
func (m *SwapSuccess) String() string { return proto.CompactTextString(m) }
func (*SwapSuccess) ProtoMessage()    {}
func (*SwapSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{58}
}

func (m *SwapSuccess) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapSuccess.Unmarshal(m, b)
}
func (m *SwapSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapSuccess.Marshal(b, m, deterministic)
}
func (m *SwapSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapSuccess.Merge(m, src)
}
func (m *SwapSuccess) XXX_Size() int {
	return xxx_messageInfo_SwapSuccess.Size(m)
}
func (m *SwapSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_SwapSuccess proto.InternalMessageInfo

func (m *SwapSuccess) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapSuccess) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *SwapSuccess) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapSuccess) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *SwapSuccess) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *SwapSuccess) GetAmountReceived() uint64 {
	if m != nil {
		return m.AmountReceived
	}
	return 0
}

func (m *SwapSuccess) GetAmountSent() uint64 {
	if m != nil {
		return m.AmountSent
	}
	return 0
}

func (m *SwapSuccess) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *SwapSuccess) GetRole() SwapSuccess_Role {
	if m != nil {
		return m.Role
	}
	return SwapSuccess_TAKER
}

func (m *SwapSuccess) GetCurrencyReceived() string {
	if m != nil {
		return m.CurrencyReceived
	}
	return ""
}

func (m *SwapSuccess) GetCurrencySent() string {
	if m != nil {
		return m.CurrencySent
	}
	return ""
}

func (m *SwapSuccess) GetRPreimage() string {
	if m != nil {
		return m.RPreimage
	}
	return ""
}

func (m *SwapSuccess) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type TradingLimits struct {
	// Max outbound capacity for a distinct channel denominated in satoshis.
	MaxSell uint64 `protobuf:"varint,1,opt,name=MaxSell,json=max_sell,proto3" json:"MaxSell,omitempty"`
	// Max inbound capacity for a distinct channel denominated in satoshis.
	MaxBuy               uint64   `protobuf:"varint,2,opt,name=MaxBuy,json=max_buy,proto3" json:"MaxBuy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TradingLimits) Reset()         { *m = TradingLimits{} }
func (m *TradingLimits) String() string { return proto.CompactTextString(m) }
func (*TradingLimits) ProtoMessage()    {}
func (*TradingLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{59}
}

func (m *TradingLimits) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TradingLimits.Unmarshal(m, b)
}
func (m *TradingLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TradingLimits.Marshal(b, m, deterministic)
}
func (m *TradingLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingLimits.Merge(m, src)
}
func (m *TradingLimits) XXX_Size() int {
	return xxx_messageInfo_TradingLimits.Size(m)
}
func (m *TradingLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingLimits.DiscardUnknown(m)
}

var xxx_messageInfo_TradingLimits proto.InternalMessageInfo

func (m *TradingLimits) GetMaxSell() uint64 {
	if m != nil {
		return m.MaxSell
	}
	return 0
}

func (m *TradingLimits) GetMaxBuy() uint64 {
	if m != nil {
		return m.MaxBuy
	}
	return 0
}

type Trade struct {
	// The maker order involved in this trade.
	MakerOrder *Order `protobuf:"bytes,1,opt,name=maker_order,proto3" json:"maker_order,omitempty"`
	// The taker order involved in this trade.
	TakerOrder *Order `protobuf:"bytes,2,opt,name=taker_order,json=taker_order_id,proto3" json:"taker_order,omitempty"`
	// The payment hash involved in this trade.
	RHash string `protobuf:"bytes,3,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// The quantity transacted in this trade.
	Quantity int64 `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The trading pair for this trade.
	PairId               string   `protobuf:"bytes,5,opt,name=pair_id,proto3" json:"pair_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{60}
}

func (m *Trade) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Trade.Unmarshal(m, b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return xxx_messageInfo_Trade.Size(m)
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetMakerOrder() *Order {
	if m != nil {
		return m.MakerOrder
	}
	return nil
}

func (m *Trade) GetTakerOrder() *Order {
	if m != nil {
		return m.TakerOrder
	}
	return nil
}

func (m *Trade) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *Trade) GetQuantity() int64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Trade) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type TradingLimitsRequest struct {
	// The ticker symbol of the currency to query for, if unspecified then trading limits for all supported
	// currencies are queried.
	Currency             string   `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TradingLimitsRequest) Reset()         { *m = TradingLimitsRequest{} }
func (m *TradingLimitsRequest) String() string { return proto.CompactTextString(m) }
func (*TradingLimitsRequest) ProtoMessage()    {}
func (*TradingLimitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{61}
}

func (m *TradingLimitsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TradingLimitsRequest.Unmarshal(m, b)
}
func (m *TradingLimitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TradingLimitsRequest.Marshal(b, m, deterministic)
}
func (m *TradingLimitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingLimitsRequest.Merge(m, src)
}
func (m *TradingLimitsRequest) XXX_Size() int {
	return xxx_messageInfo_TradingLimitsRequest.Size(m)
}
func (m *TradingLimitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingLimitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TradingLimitsRequest proto.InternalMessageInfo

func (m *TradingLimitsRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type TradingLimitsResponse struct {
	// A map between currency ticker symbols and their trading limits.
	Limits               map[string]*TradingLimits `protobuf:"bytes,1,rep,name=limits,proto3" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TradingLimitsResponse) Reset()         { *m = TradingLimitsResponse{} }
func (m *TradingLimitsResponse) String() string { return proto.CompactTextString(m) }
func (*TradingLimitsResponse) ProtoMessage()    {}
func (*TradingLimitsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{62}
}

func (m *TradingLimitsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TradingLimitsResponse.Unmarshal(m, b)
}
func (m *TradingLimitsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TradingLimitsResponse.Marshal(b, m, deterministic)
}
func (m *TradingLimitsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingLimitsResponse.Merge(m, src)
}
func (m *TradingLimitsResponse) XXX_Size() int {
	return xxx_messageInfo_TradingLimitsResponse.Size(m)
}
func (m *TradingLimitsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingLimitsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TradingLimitsResponse proto.InternalMessageInfo

func (m *TradingLimitsResponse) GetLimits() map[string]*TradingLimits {
	if m != nil {
		return m.Limits
	}
	return nil
}

type UnbanRequest struct {
	// The node pub key of the peer to unban.
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key,proto3" json:"node_pub_key,omitempty"`
	// Whether to attempt to connect to the peer after it is unbanned.
	Reconnect            bool     `protobuf:"varint,2,opt,name=reconnect,proto3" json:"reconnect,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnbanRequest) Reset()         { *m = UnbanRequest{} }
func (m *UnbanRequest) String() string { return proto.CompactTextString(m) }
func (*UnbanRequest) ProtoMessage()    {}
func (*UnbanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{63}
}

func (m *UnbanRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnbanRequest.Unmarshal(m, b)
}
func (m *UnbanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnbanRequest.Marshal(b, m, deterministic)
}
func (m *UnbanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbanRequest.Merge(m, src)
}
func (m *UnbanRequest) XXX_Size() int {
	return xxx_messageInfo_UnbanRequest.Size(m)
}
func (m *UnbanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnbanRequest proto.InternalMessageInfo

func (m *UnbanRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *UnbanRequest) GetReconnect() bool {
	if m != nil {
		return m.Reconnect
	}
	return false
}

type UnbanResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnbanResponse) Reset()         { *m = UnbanResponse{} }
func (m *UnbanResponse) String() string { return proto.CompactTextString(m) }
func (*UnbanResponse) ProtoMessage()    {}
func (*UnbanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{64}
}

func (m *UnbanResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnbanResponse.Unmarshal(m, b)
}
func (m *UnbanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnbanResponse.Marshal(b, m, deterministic)
}
func (m *UnbanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbanResponse.Merge(m, src)
}
func (m *UnbanResponse) XXX_Size() int {
	return xxx_messageInfo_UnbanResponse.Size(m)
}
func (m *UnbanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnbanResponse proto.InternalMessageInfo

type UnlockNodeRequest struct {
	// The password in utf-8 with which to unlock an existing xud node key as
	// well as underlying client wallets such as lnd.
	Password             string   `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockNodeRequest) Reset()         { *m = UnlockNodeRequest{} }
func (m *UnlockNodeRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockNodeRequest) ProtoMessage()    {}
func (*UnlockNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{65}
}

func (m *UnlockNodeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnlockNodeRequest.Unmarshal(m, b)
}
func (m *UnlockNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnlockNodeRequest.Marshal(b, m, deterministic)
}
func (m *UnlockNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockNodeRequest.Merge(m, src)
}
func (m *UnlockNodeRequest) XXX_Size() int {
	return xxx_messageInfo_UnlockNodeRequest.Size(m)
}
func (m *UnlockNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockNodeRequest proto.InternalMessageInfo

func (m *UnlockNodeRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type UnlockNodeResponse struct {
	// The list of lnd clients that were unlocked.
	UnlockedLnds []string `protobuf:"bytes,1,rep,name=unlocked_lnds,json=unlockedLnds,proto3" json:"unlocked_lnds,omitempty"`
	// Whether raiden was unlocked.
	UnlockedRaiden bool `protobuf:"varint,2,opt,name=unlocked_raiden,json=unlockedRaiden,proto3" json:"unlocked_raiden,omitempty"`
	// The list of lnd clients that could not be unlocked.
	LockedLnds           []string `protobuf:"bytes,3,rep,name=locked_lnds,json=lockedLnds,proto3" json:"locked_lnds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockNodeResponse) Reset()         { *m = UnlockNodeResponse{} }
func (m *UnlockNodeResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockNodeResponse) ProtoMessage()    {}
func (*UnlockNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6960a02cc0a63cf6, []int{66}
}

func (m *UnlockNodeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnlockNodeResponse.Unmarshal(m, b)
}
func (m *UnlockNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnlockNodeResponse.Marshal(b, m, deterministic)
}
func (m *UnlockNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockNodeResponse.Merge(m, src)
}
func (m *UnlockNodeResponse) XXX_Size() int {
	return xxx_messageInfo_UnlockNodeResponse.Size(m)
}
func (m *UnlockNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockNodeResponse proto.InternalMessageInfo

func (m *UnlockNodeResponse) GetUnlockedLnds() []string {
	if m != nil {
		return m.UnlockedLnds
	}
	return nil
}

func (m *UnlockNodeResponse) GetUnlockedRaiden() bool {
	if m != nil {
		return m.UnlockedRaiden
	}
	return false
}

func (m *UnlockNodeResponse) GetLockedLnds() []string {
	if m != nil {
		return m.LockedLnds
	}
	return nil
}

func init() {
	proto.RegisterEnum("xudrpc.OrderSide", OrderSide_name, OrderSide_value)
	proto.RegisterEnum("xudrpc.Currency_SwapClient", Currency_SwapClient_name, Currency_SwapClient_value)
	proto.RegisterEnum("xudrpc.ListOrdersRequest_Owner", ListOrdersRequest_Owner_name, ListOrdersRequest_Owner_value)
	proto.RegisterEnum("xudrpc.SwapSuccess_Role", SwapSuccess_Role_name, SwapSuccess_Role_value)
	proto.RegisterType((*AddCurrencyResponse)(nil), "xudrpc.AddCurrencyResponse")
	proto.RegisterType((*AddPairRequest)(nil), "xudrpc.AddPairRequest")
	proto.RegisterType((*AddPairResponse)(nil), "xudrpc.AddPairResponse")
	proto.RegisterType((*Balance)(nil), "xudrpc.Balance")
	proto.RegisterType((*BanRequest)(nil), "xudrpc.BanRequest")
	proto.RegisterType((*BanResponse)(nil), "xudrpc.BanResponse")
	proto.RegisterType((*Chain)(nil), "xudrpc.Chain")
	proto.RegisterType((*Channels)(nil), "xudrpc.Channels")
	proto.RegisterType((*ConnectRequest)(nil), "xudrpc.ConnectRequest")
	proto.RegisterType((*ConnectResponse)(nil), "xudrpc.ConnectResponse")
	proto.RegisterType((*CreateNodeRequest)(nil), "xudrpc.CreateNodeRequest")
	proto.RegisterType((*CreateNodeResponse)(nil), "xudrpc.CreateNodeResponse")
	proto.RegisterType((*Currency)(nil), "xudrpc.Currency")
	proto.RegisterType((*DiscoverNodesRequest)(nil), "xudrpc.DiscoverNodesRequest")
	proto.RegisterType((*DiscoverNodesResponse)(nil), "xudrpc.DiscoverNodesResponse")
	proto.RegisterType((*ExecuteSwapRequest)(nil), "xudrpc.ExecuteSwapRequest")
	proto.RegisterType((*GetBalanceRequest)(nil), "xudrpc.GetBalanceRequest")
	proto.RegisterType((*GetBalanceResponse)(nil), "xudrpc.GetBalanceResponse")
	proto.RegisterMapType((map[string]*Balance)(nil), "xudrpc.GetBalanceResponse.BalancesEntry")
	proto.RegisterType((*GetInfoRequest)(nil), "xudrpc.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "xudrpc.GetInfoResponse")
	proto.RegisterMapType((map[string]*LndInfo)(nil), "xudrpc.GetInfoResponse.LndEntry")
	proto.RegisterType((*GetNodeInfoRequest)(nil), "xudrpc.GetNodeInfoRequest")
	proto.RegisterType((*GetNodeInfoResponse)(nil), "xudrpc.GetNodeInfoResponse")
	proto.RegisterType((*ListCurrenciesRequest)(nil), "xudrpc.ListCurrenciesRequest")
	proto.RegisterType((*ListCurrenciesResponse)(nil), "xudrpc.ListCurrenciesResponse")
	proto.RegisterType((*ListOrdersRequest)(nil), "xudrpc.ListOrdersRequest")
	proto.RegisterType((*ListOrdersResponse)(nil), "xudrpc.ListOrdersResponse")
	proto.RegisterMapType((map[string]*Orders)(nil), "xudrpc.ListOrdersResponse.OrdersEntry")
	proto.RegisterType((*ListPairsRequest)(nil), "xudrpc.ListPairsRequest")
	proto.RegisterType((*ListPairsResponse)(nil), "xudrpc.ListPairsResponse")
	proto.RegisterType((*ListPeersRequest)(nil), "xudrpc.ListPeersRequest")
	proto.RegisterType((*ListPeersResponse)(nil), "xudrpc.ListPeersResponse")
	proto.RegisterType((*ListTradesRequest)(nil), "xudrpc.ListTradesRequest")
	proto.RegisterType((*ListTradesResponse)(nil), "xudrpc.ListTradesResponse")
	proto.RegisterType((*LndInfo)(nil), "xudrpc.LndInfo")
	proto.RegisterType((*OpenChannelRequest)(nil), "xudrpc.OpenChannelRequest")
	proto.RegisterType((*OpenChannelResponse)(nil), "xudrpc.OpenChannelResponse")
	proto.RegisterType((*Order)(nil), "xudrpc.Order")
	proto.RegisterType((*OrderRemoval)(nil), "xudrpc.OrderRemoval")
	proto.RegisterType((*Orders)(nil), "xudrpc.Orders")
	proto.RegisterType((*OrdersCount)(nil), "xudrpc.OrdersCount")
	proto.RegisterType((*OrderUpdate)(nil), "xudrpc.OrderUpdate")
	proto.RegisterType((*Peer)(nil), "xudrpc.Peer")
	proto.RegisterMapType((map[string]string)(nil), "xudrpc.Peer.LndPubKeysEntry")
	proto.RegisterType((*PlaceOrderRequest)(nil), "xudrpc.PlaceOrderRequest")
	proto.RegisterType((*PlaceOrderResponse)(nil), "xudrpc.PlaceOrderResponse")
	proto.RegisterType((*PlaceOrderEvent)(nil), "xudrpc.PlaceOrderEvent")
	proto.RegisterType((*RaidenInfo)(nil), "xudrpc.RaidenInfo")
	proto.RegisterType((*RemoveCurrencyRequest)(nil), "xudrpc.RemoveCurrencyRequest")
	proto.RegisterType((*RemoveCurrencyResponse)(nil), "xudrpc.RemoveCurrencyResponse")
	proto.RegisterType((*RemoveOrderRequest)(nil), "xudrpc.RemoveOrderRequest")
	proto.RegisterType((*RemoveOrderResponse)(nil), "xudrpc.RemoveOrderResponse")
	proto.RegisterType((*RemovePairRequest)(nil), "xudrpc.RemovePairRequest")
	proto.RegisterType((*RemovePairResponse)(nil), "xudrpc.RemovePairResponse")
	proto.RegisterType((*RestoreNodeRequest)(nil), "xudrpc.RestoreNodeRequest")
	proto.RegisterMapType((map[string][]byte)(nil), "xudrpc.RestoreNodeRequest.LndBackupsEntry")
	proto.RegisterType((*RestoreNodeResponse)(nil), "xudrpc.RestoreNodeResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "xudrpc.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "xudrpc.ShutdownResponse")
	proto.RegisterType((*SubscribeOrdersRequest)(nil), "xudrpc.SubscribeOrdersRequest")
	proto.RegisterType((*SubscribeSwapsRequest)(nil), "xudrpc.SubscribeSwapsRequest")
	proto.RegisterType((*SwapFailure)(nil), "xudrpc.SwapFailure")
	proto.RegisterType((*SwapSuccess)(nil), "xudrpc.SwapSuccess")
	proto.RegisterType((*TradingLimits)(nil), "xudrpc.TradingLimits")
	proto.RegisterType((*Trade)(nil), "xudrpc.Trade")
	proto.RegisterType((*TradingLimitsRequest)(nil), "xudrpc.TradingLimitsRequest")
	proto.RegisterType((*TradingLimitsResponse)(nil), "xudrpc.TradingLimitsResponse")
	proto.RegisterMapType((map[string]*TradingLimits)(nil), "xudrpc.TradingLimitsResponse.LimitsEntry")
	proto.RegisterType((*UnbanRequest)(nil), "xudrpc.UnbanRequest")
	proto.RegisterType((*UnbanResponse)(nil), "xudrpc.UnbanResponse")
	proto.RegisterType((*UnlockNodeRequest)(nil), "xudrpc.UnlockNodeRequest")
	proto.RegisterType((*UnlockNodeResponse)(nil), "xudrpc.UnlockNodeResponse")
}

func init() { proto.RegisterFile("xudrpc.proto", fileDescriptor_6960a02cc0a63cf6) }

var fileDescriptor_6960a02cc0a63cf6 = []byte{
	// 3415 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x3a, 0x4d, 0x6f, 0x1c, 0xc7,
	0x95, 0xec, 0xf9, 0xe0, 0x0c, 0xdf, 0x70, 0x3e, 0x58, 0x24, 0xa5, 0xd1, 0x48, 0x96, 0xe5, 0x5e,
	0xd9, 0x2b, 0xcb, 0x32, 0xa5, 0xa5, 0xd7, 0x90, 0x25, 0xaf, 0x8d, 0x15, 0x29, 0xae, 0x25, 0x9b,
	0xfa, 0x40, 0xd3, 0x5a, 0x2b, 0x41, 0xe2, 0x46, 0x4f, 0x77, 0x49, 0xec, 0xa8, 0xa7, 0x7a, 0xdc,
	0x1f, 0xa4, 0x98, 0x53, 0xe0, 0xe4, 0x94, 0x1c, 0x7d, 0x0d, 0x90, 0x9c, 0x72, 0x49, 0xae, 0x41,
	0x80, 0xfc, 0x8d, 0x00, 0x49, 0x0e, 0x01, 0x82, 0x00, 0xb9, 0xe6, 0x3f, 0x04, 0xf5, 0xd5, 0x55,
	0xd5, 0xdd, 0x23, 0xc9, 0x41, 0x6e, 0x5d, 0xaf, 0x5e, 0xbd, 0x57, 0xf5, 0xea, 0xd5, 0xfb, 0x6c,
	0x58, 0x7d, 0x9e, 0x07, 0xc9, 0xdc, 0xdf, 0x9a, 0x27, 0x71, 0x16, 0xa3, 0x65, 0x3e, 0x9a, 0xac,
	0x79, 0x84, 0xc4, 0x99, 0x97, 0x85, 0x31, 0x49, 0xf9, 0x94, 0xbd, 0x09, 0xeb, 0xb7, 0x82, 0x60,
	0x37, 0x4f, 0x12, 0x4c, 0xfc, 0x13, 0x07, 0xa7, 0xf3, 0x98, 0xa4, 0xd8, 0xfe, 0x12, 0x06, 0xb7,
	0x82, 0xe0, 0xa1, 0x17, 0x26, 0x0e, 0xfe, 0x2a, 0xc7, 0x69, 0x86, 0x2e, 0x42, 0x7f, 0xea, 0xa5,
	0xd8, 0xf5, 0x05, 0xea, 0xd8, 0xba, 0x60, 0x5d, 0x5a, 0x71, 0x4c, 0x20, 0x7a, 0x0b, 0x06, 0x5f,
	0xe5, 0x71, 0xa6, 0xa1, 0x35, 0x18, 0x5a, 0x09, 0x6a, 0xaf, 0xc1, 0xb0, 0xa0, 0x2f, 0x58, 0xfe,
	0xae, 0x01, 0x9d, 0x1d, 0x2f, 0xf2, 0x88, 0x8f, 0x29, 0xb3, 0x2c, 0xce, 0xbc, 0xc8, 0x9d, 0x72,
	0x00, 0x63, 0xd6, 0x72, 0x4c, 0x20, 0xba, 0x04, 0x43, 0xff, 0xd0, 0x23, 0x04, 0x2b, 0xbc, 0x06,
	0xc3, 0x2b, 0x83, 0xd1, 0x07, 0x70, 0x7a, 0x8e, 0x49, 0x10, 0x92, 0xa7, 0x6e, 0x79, 0x45, 0x93,
	0xad, 0x58, 0x34, 0x8d, 0x6e, 0xc2, 0x38, 0x24, 0x9e, 0x9f, 0x85, 0x47, 0xb8, 0xb2, 0xb4, 0xc5,
	0x96, 0x2e, 0x9c, 0xa7, 0xc2, 0x38, 0xf6, 0xa2, 0x08, 0x67, 0xc5, 0x8a, 0x36, 0x5b, 0x51, 0x82,
	0xa2, 0x8f, 0x61, 0x92, 0x13, 0x3f, 0x26, 0x4f, 0xc2, 0x64, 0x86, 0x03, 0xb7, 0xb4, 0x66, 0x99,
	0xad, 0x79, 0x01, 0x86, 0x7d, 0x0d, 0x60, 0xc7, 0x23, 0xf2, 0xa2, 0x6c, 0x58, 0x25, 0x71, 0x80,
	0xdd, 0x79, 0x3e, 0x75, 0x9f, 0x61, 0x79, 0x4f, 0x06, 0xcc, 0xee, 0x43, 0x8f, 0xad, 0x10, 0xa2,
	0xbf, 0x0e, 0xed, 0xdd, 0x43, 0x2f, 0x24, 0x68, 0x03, 0xda, 0x3e, 0xfd, 0x10, 0x8b, 0xf8, 0x00,
	0x8d, 0xa1, 0x43, 0x70, 0x76, 0x1c, 0x27, 0xcf, 0xc4, 0x6d, 0xca, 0xa1, 0x3d, 0x87, 0xee, 0x2e,
	0x3f, 0x74, 0x8a, 0x4e, 0xc1, 0x32, 0x97, 0x03, 0x5b, 0xdc, 0x77, 0xc4, 0x08, 0x4d, 0xa0, 0x2b,
	0x25, 0xc4, 0x96, 0xf7, 0x9d, 0x62, 0x4c, 0x29, 0x0b, 0xc1, 0xb3, 0x7b, 0xe8, 0x3b, 0x72, 0x48,
	0xa9, 0xf9, 0x51, 0x9c, 0xe2, 0x80, 0x49, 0xb9, 0xef, 0x88, 0x91, 0x7d, 0x05, 0x06, 0xbb, 0x31,
	0x21, 0xd8, 0xcf, 0xe4, 0x79, 0x27, 0xd0, 0x65, 0x67, 0xcb, 0x93, 0x50, 0x6c, 0xbb, 0x18, 0x53,
	0x35, 0x2b, 0xb0, 0xc5, 0x59, 0xaf, 0xc2, 0xda, 0x6e, 0x82, 0xbd, 0x0c, 0xdf, 0x8f, 0x03, 0xac,
	0xd1, 0x98, 0x7b, 0x69, 0x7a, 0x1c, 0x27, 0x81, 0xa4, 0x21, 0xc7, 0xf6, 0x37, 0x16, 0x20, 0x7d,
	0x05, 0xa7, 0x83, 0xfe, 0x03, 0xfa, 0x29, 0xc6, 0x81, 0x3b, 0x23, 0x78, 0x16, 0x93, 0xd0, 0x1f,
	0x5b, 0x17, 0x9a, 0x54, 0xce, 0x14, 0x78, 0x4f, 0xc0, 0xd0, 0xdb, 0x30, 0x0a, 0x49, 0x98, 0x85,
	0x5e, 0x14, 0xfe, 0x10, 0x07, 0x6e, 0x44, 0x82, 0x74, 0xdc, 0x60, 0x78, 0x43, 0x0d, 0xbe, 0x4f,
	0x82, 0x14, 0xbd, 0x0b, 0x48, 0x47, 0x4d, 0xbc, 0x30, 0xc0, 0x84, 0x49, 0xa5, 0xeb, 0xac, 0x69,
	0x33, 0x0e, 0x9b, 0xb0, 0xff, 0x68, 0x41, 0x57, 0xbe, 0x5a, 0xba, 0xfd, 0xd2, 0xb3, 0x2c, 0xc6,
	0xe8, 0x23, 0xe8, 0xa5, 0xc7, 0xde, 0xdc, 0xf5, 0xa3, 0x10, 0x93, 0x8c, 0xdd, 0xc0, 0x60, 0xfb,
	0xec, 0x96, 0xb0, 0x0f, 0x92, 0xc4, 0xd6, 0xc1, 0xb1, 0x37, 0xdf, 0x65, 0x28, 0x8e, 0x8e, 0xcf,
	0x5f, 0xe2, 0x33, 0x4c, 0x5c, 0x2f, 0x08, 0x12, 0x9c, 0xa6, 0x6c, 0x47, 0x2b, 0x8e, 0x09, 0xa4,
	0x9a, 0x1e, 0x60, 0x3f, 0x9c, 0x79, 0x91, 0x3b, 0x8f, 0x3c, 0x1f, 0xa7, 0xe2, 0xd6, 0x4a, 0x50,
	0xfb, 0x0d, 0x00, 0xc5, 0x08, 0x75, 0xa0, 0xb9, 0x7f, 0xff, 0xf6, 0x68, 0x09, 0x01, 0x2c, 0x3b,
	0xb7, 0xee, 0xde, 0xde, 0xbb, 0x3f, 0xb2, 0xec, 0x9b, 0xb0, 0x71, 0x3b, 0x4c, 0xfd, 0xf8, 0x08,
	0x27, 0x54, 0xde, 0xa9, 0xa6, 0xd6, 0x73, 0x8c, 0x93, 0xb2, 0x5a, 0xeb, 0x30, 0xfb, 0x7d, 0xd8,
	0x2c, 0xad, 0x15, 0x97, 0x75, 0x0e, 0x56, 0x48, 0x3e, 0x73, 0xa9, 0x5e, 0xa4, 0x42, 0x3d, 0x15,
	0xc0, 0xfe, 0xa9, 0x05, 0x68, 0xef, 0x39, 0xf6, 0xf3, 0x0c, 0xd3, 0xdd, 0x69, 0x4a, 0x11, 0x27,
	0x01, 0x4e, 0xdc, 0xb0, 0x50, 0x0a, 0x39, 0x66, 0x8a, 0xeb, 0x85, 0x6c, 0x4a, 0x3c, 0x09, 0x31,
	0xac, 0xec, 0xb3, 0x59, 0xdd, 0x27, 0xa5, 0xfc, 0x55, 0xee, 0x91, 0x2c, 0xcc, 0x4e, 0x84, 0x11,
	0x29, 0xc6, 0x54, 0x3f, 0x3f, 0xc1, 0x99, 0x30, 0x84, 0xda, 0x56, 0x16, 0x5d, 0xb0, 0xfd, 0x2b,
	0x0b, 0x90, 0xbe, 0x42, 0x1c, 0x79, 0x07, 0xba, 0xc2, 0x3e, 0xa4, 0x4c, 0x35, 0x7b, 0xdb, 0x97,
	0xe4, 0xa5, 0x57, 0xb1, 0xb7, 0xc4, 0x38, 0xdd, 0x23, 0x59, 0x72, 0xe2, 0x2c, 0xb3, 0x73, 0xa6,
	0x93, 0x7d, 0xe8, 0x1b, 0x13, 0x68, 0x04, 0x4d, 0x25, 0x7b, 0xfa, 0x89, 0xde, 0x84, 0xf6, 0x91,
	0x17, 0xe5, 0xfc, 0x69, 0xf7, 0xb6, 0x87, 0x92, 0x87, 0x64, 0xc0, 0x67, 0x6f, 0x36, 0x3e, 0xb0,
	0xec, 0x11, 0x0c, 0x3e, 0xc1, 0xd9, 0x5d, 0xf2, 0x24, 0x16, 0xc7, 0xb2, 0xff, 0xd4, 0x84, 0x61,
	0x01, 0x12, 0xfb, 0x1e, 0x43, 0xe7, 0x08, 0x27, 0x69, 0x18, 0x4b, 0x23, 0x24, 0x87, 0x15, 0xc3,
	0xd6, 0xa8, 0x1a, 0x36, 0x84, 0xa0, 0x95, 0x27, 0x21, 0xd5, 0x52, 0xfa, 0xc8, 0xd8, 0xb7, 0xbc,
	0x7c, 0x7a, 0x03, 0x52, 0x2f, 0x15, 0xa0, 0x98, 0xf5, 0xc2, 0x24, 0x65, 0xf6, 0x59, 0xce, 0x52,
	0x00, 0x7a, 0x07, 0x84, 0x2c, 0x98, 0x19, 0xee, 0x6d, 0xaf, 0xcb, 0xf3, 0x3d, 0x60, 0xd0, 0xdd,
	0x38, 0x27, 0x99, 0x14, 0x17, 0xda, 0x86, 0x66, 0x44, 0x82, 0x71, 0x87, 0x49, 0xfb, 0x82, 0x26,
	0x6d, 0xfd, 0x80, 0x5b, 0xfb, 0x24, 0xe0, 0x52, 0xa6, 0xc8, 0xe8, 0x32, 0x2c, 0x8b, 0xa7, 0xde,
	0x65, 0x0c, 0x90, 0x5c, 0xc6, 0xdf, 0x39, 0x5b, 0x29, 0x30, 0xa8, 0x75, 0xf6, 0xa2, 0xd0, 0x4b,
	0xc7, 0x2b, 0xdc, 0x3a, 0xb3, 0x81, 0x6e, 0x9d, 0xc1, 0xb0, 0xce, 0xe8, 0x1a, 0xac, 0x4b, 0xb7,
	0xc6, 0x9e, 0xf4, 0xa1, 0x97, 0x1e, 0xe2, 0x74, 0xdc, 0x63, 0xb2, 0xa9, 0x9b, 0x9a, 0x7c, 0x02,
	0x5d, 0xb9, 0xbd, 0x6f, 0x71, 0xd7, 0xfb, 0x24, 0x60, 0xfb, 0xd4, 0xee, 0xfa, 0x03, 0xa6, 0x93,
	0xf4, 0x11, 0x6a, 0xf7, 0xfd, 0x4a, 0xae, 0xc9, 0x81, 0x75, 0x63, 0x65, 0x61, 0x6e, 0x87, 0x09,
	0x9e, 0xe7, 0x3c, 0x78, 0x39, 0xf0, 0xe3, 0x84, 0xbb, 0x99, 0x35, 0x07, 0x14, 0x98, 0x3a, 0x8d,
	0x29, 0xf5, 0x46, 0xfc, 0x51, 0x76, 0x1d, 0x31, 0xb2, 0x4f, 0xc3, 0xe6, 0x7e, 0x98, 0x66, 0xc2,
	0xd8, 0x85, 0x85, 0x51, 0xb1, 0x3f, 0x85, 0x53, 0xe5, 0x09, 0xc1, 0xef, 0x1a, 0x80, 0x5f, 0x40,
	0xc5, 0x03, 0x1a, 0x95, 0xad, 0xa6, 0xa3, 0xe1, 0xd8, 0xbf, 0xb4, 0x60, 0x8d, 0x12, 0xe3, 0x9a,
	0x21, 0x8f, 0xac, 0x19, 0x0a, 0xcb, 0x34, 0x14, 0xef, 0x43, 0x3b, 0x3e, 0x26, 0x38, 0x11, 0x26,
	0xf9, 0xf5, 0x42, 0x9a, 0x65, 0x1a, 0x5b, 0x0f, 0x28, 0x9a, 0xc3, 0xb1, 0xa9, 0x12, 0x44, 0xe1,
	0x2c, 0xcc, 0x84, 0xc3, 0xe4, 0x03, 0xfb, 0x22, 0xb4, 0x19, 0x16, 0xea, 0x42, 0x6b, 0xe7, 0xc1,
	0xe7, 0x77, 0x46, 0x4b, 0xd4, 0xba, 0x3e, 0xf8, 0xe2, 0xfe, 0xc8, 0xa2, 0xa0, 0x87, 0x7b, 0x7b,
	0xce, 0xa8, 0x61, 0xff, 0xc2, 0x02, 0xa4, 0x93, 0x17, 0x67, 0xfd, 0xb8, 0x50, 0x72, 0x7e, 0xce,
	0xb7, 0xea, 0xb6, 0x22, 0xb4, 0x97, 0x0f, 0x4d, 0x33, 0x71, 0x17, 0x7a, 0x1a, 0xb8, 0x46, 0x71,
	0x2e, 0x9a, 0x8a, 0x33, 0x30, 0x1f, 0x91, 0xae, 0x37, 0x08, 0x46, 0x94, 0x29, 0x0d, 0x0c, 0x8b,
	0x4b, 0x7a, 0x9b, 0xcb, 0x55, 0xc0, 0xc4, 0x9e, 0x37, 0xa0, 0xcd, 0x9f, 0x2c, 0x77, 0xbb, 0x7c,
	0x50, 0x2c, 0xc7, 0x4a, 0x7a, 0xf6, 0x75, 0xb1, 0x1c, 0xeb, 0x47, 0xb6, 0xa1, 0xcd, 0xed, 0x01,
	0x3f, 0xf1, 0xaa, 0xdc, 0x11, 0xc5, 0x72, 0xf8, 0x94, 0xe4, 0xfb, 0x79, 0xe2, 0x69, 0x6e, 0xa8,
	0x10, 0x3f, 0x3d, 0x5e, 0x5b, 0x8a, 0xff, 0x43, 0x2e, 0x57, 0x89, 0x2a, 0x98, 0xbc, 0x09, 0xcb,
	0x19, 0x83, 0x08, 0x2e, 0x7d, 0xc9, 0x85, 0xe1, 0x39, 0x62, 0xd2, 0xfe, 0x8b, 0x05, 0x1d, 0xf1,
	0x84, 0xa8, 0x06, 0xa7, 0x99, 0x97, 0xe5, 0xa9, 0x10, 0x9f, 0x18, 0xa1, 0x2b, 0xd0, 0x15, 0xd1,
	0x65, 0x2a, 0x84, 0xa8, 0x94, 0x51, 0xc0, 0x9d, 0x02, 0x83, 0x32, 0x66, 0x91, 0x1b, 0xb7, 0x83,
	0x1a, 0x63, 0x16, 0xe5, 0x39, 0x62, 0x12, 0x5d, 0x80, 0xde, 0x34, 0x8a, 0xfd, 0x67, 0x87, 0x38,
	0x7c, 0x7a, 0x98, 0x09, 0xd3, 0xa8, 0x83, 0x0a, 0x73, 0xda, 0xd6, 0xcc, 0xa9, 0x66, 0xa0, 0x97,
	0x4d, 0x03, 0x5d, 0xd8, 0xa7, 0x8e, 0x66, 0x9f, 0xec, 0x08, 0xd0, 0x83, 0x39, 0x26, 0x62, 0x9b,
	0x2f, 0x31, 0x05, 0x65, 0x37, 0x59, 0x4a, 0x23, 0x54, 0x58, 0x43, 0xa3, 0xcd, 0x19, 0xb5, 0xbe,
	0xec, 0x1d, 0x34, 0x1d, 0x31, 0xa2, 0xf9, 0x8c, 0xc1, 0x4d, 0x44, 0x7d, 0xbf, 0x6d, 0x40, 0x9b,
	0x69, 0x1b, 0x53, 0x9c, 0x24, 0x14, 0x29, 0x85, 0xe5, 0xf0, 0x81, 0xe1, 0x91, 0x1b, 0xa6, 0x47,
	0xd6, 0x9f, 0x70, 0xd3, 0x7c, 0xc2, 0x03, 0x68, 0x84, 0x3c, 0x40, 0x5d, 0x71, 0x1a, 0x61, 0x80,
	0x2e, 0x96, 0x7c, 0x3f, 0x75, 0x27, 0x2b, 0x77, 0x96, 0x4a, 0xc7, 0x3a, 0x07, 0xdd, 0x28, 0xf6,
	0xbd, 0x88, 0x12, 0x5c, 0x16, 0x18, 0x05, 0x04, 0x9d, 0x07, 0xf0, 0x59, 0xb4, 0x19, 0xb8, 0x5e,
	0xc6, 0x24, 0xd9, 0x72, 0x34, 0x08, 0x7a, 0x13, 0x5a, 0x69, 0x18, 0x60, 0xe6, 0x2e, 0x06, 0xdb,
	0x6b, 0xc6, 0x53, 0x3a, 0x08, 0x03, 0xec, 0xb0, 0x69, 0x2a, 0xdf, 0x30, 0x75, 0xe3, 0x63, 0xe2,
	0xb2, 0x47, 0xca, 0x5c, 0x46, 0xd7, 0x31, 0x60, 0xf4, 0x76, 0x0f, 0xe3, 0x28, 0x60, 0x6e, 0xa3,
	0xe5, 0xb0, 0xef, 0x9d, 0x3e, 0xf4, 0x38, 0x02, 0x73, 0x8f, 0xd4, 0xa8, 0xad, 0x32, 0xd2, 0x0e,
	0x9e, 0xc5, 0x47, 0x5e, 0x64, 0x08, 0xca, 0x5a, 0x2c, 0xa8, 0x52, 0x50, 0xa4, 0x87, 0x52, 0xcd,
	0x52, 0x28, 0x35, 0xd1, 0xc4, 0xc1, 0x45, 0xa9, 0x84, 0x51, 0x3e, 0x45, 0xbb, 0x7a, 0x0a, 0xfb,
	0x10, 0x96, 0xb9, 0x1d, 0x41, 0xef, 0x02, 0x4c, 0xf3, 0x13, 0xd7, 0xb0, 0x65, 0x7d, 0x43, 0x40,
	0x8e, 0x86, 0x80, 0xae, 0x42, 0x2f, 0xc5, 0x51, 0x24, 0xf1, 0x1b, 0x75, 0xf8, 0x3a, 0x86, 0xfd,
	0x9e, 0xb4, 0x73, 0xcc, 0xed, 0x53, 0xf1, 0x51, 0x19, 0x89, 0x78, 0x92, 0x7d, 0x53, 0xdb, 0x17,
	0x1f, 0x13, 0x91, 0xe7, 0xd0, 0x4f, 0xfb, 0x6b, 0x4b, 0xac, 0x7a, 0x34, 0x0f, 0xbc, 0x8c, 0x1a,
	0x85, 0x36, 0x3f, 0x8b, 0xc5, 0x9e, 0xb1, 0xc9, 0xef, 0xce, 0x92, 0xc3, 0x67, 0xd1, 0xff, 0x40,
	0x9f, 0x4b, 0x28, 0xe1, 0x82, 0x17, 0xaf, 0x7e, 0xc3, 0xdc, 0x1e, 0x9f, 0xbb, 0xb3, 0xe4, 0x98,
	0xc8, 0x3b, 0x03, 0x58, 0xe5, 0x80, 0x9c, 0x31, 0xb5, 0xff, 0xd1, 0x80, 0x16, 0x35, 0x6d, 0xf4,
	0x8a, 0x64, 0x20, 0x2f, 0xdc, 0x91, 0x0c, 0xe1, 0x5f, 0x25, 0xba, 0xfa, 0x5f, 0x58, 0x8d, 0x48,
	0x20, 0x87, 0xd2, 0xba, 0x9c, 0xd3, 0x8d, 0x27, 0x0d, 0x06, 0x1e, 0xe6, 0xd3, 0xcf, 0xf0, 0x89,
	0x70, 0x12, 0xc6, 0x0a, 0xca, 0x3f, 0x24, 0xd3, 0x38, 0x27, 0xfc, 0xae, 0xbb, 0x8e, 0x1c, 0x2a,
	0x83, 0xde, 0xd6, 0x0c, 0x3a, 0x35, 0x51, 0xcf, 0xf3, 0xc0, 0x35, 0x0d, 0x8e, 0x0e, 0x42, 0x57,
	0x60, 0x2d, 0xc5, 0x7e, 0x4c, 0x82, 0xd4, 0xf5, 0x79, 0xaa, 0x87, 0x03, 0xf6, 0x6c, 0xfa, 0x4e,
	0x75, 0x82, 0x26, 0x2a, 0x3c, 0x98, 0x2a, 0xf2, 0x99, 0x2e, 0xaf, 0x4f, 0x98, 0xd0, 0xc9, 0x47,
	0x30, 0x2c, 0x1d, 0xa4, 0xc6, 0xad, 0x6d, 0xe8, 0x6e, 0x6d, 0x45, 0x77, 0x63, 0x3f, 0x6a, 0xc0,
	0xda, 0x43, 0x9a, 0xf2, 0x88, 0x6b, 0x2a, 0x7c, 0xc7, 0xbf, 0xcd, 0xf4, 0xe8, 0x2f, 0xaa, 0x55,
	0x7a, 0x51, 0xd2, 0x44, 0xb4, 0x5f, 0x6c, 0x22, 0x2e, 0xc3, 0x28, 0xc1, 0x2c, 0x31, 0x73, 0x0b,
	0x52, 0x5c, 0xc0, 0x15, 0x38, 0x0d, 0x25, 0xc3, 0xd9, 0x0c, 0x07, 0xa1, 0x97, 0x51, 0xa8, 0xeb,
	0xd3, 0xe0, 0x3e, 0x62, 0x72, 0xee, 0x3a, 0x75, 0x53, 0x54, 0x04, 0x48, 0x17, 0x81, 0xf0, 0x89,
	0x37, 0x68, 0x46, 0x9c, 0xe1, 0x84, 0x78, 0x91, 0x3b, 0xf3, 0x32, 0xff, 0x10, 0x2f, 0x78, 0xa9,
	0x15, 0x34, 0xf4, 0x21, 0x0c, 0x58, 0xac, 0x9a, 0xe6, 0xbe, 0x8f, 0xd3, 0x14, 0xcb, 0x27, 0x5b,
	0xc4, 0xe4, 0x34, 0x79, 0x3b, 0xe0, 0x93, 0x4e, 0x09, 0x15, 0x5d, 0xa7, 0xf1, 0xe3, 0xcc, 0x0b,
	0x09, 0x0d, 0x79, 0xf9, 0x03, 0x6c, 0xd6, 0x3c, 0x40, 0xa7, 0x8c, 0x85, 0x6e, 0x40, 0x9f, 0x91,
	0x7a, 0xe2, 0x85, 0x51, 0x9e, 0xb0, 0xcc, 0xb6, 0xc2, 0xf4, 0xff, 0xf8, 0x9c, 0x63, 0x62, 0xda,
	0x3f, 0x69, 0xc0, 0x50, 0x89, 0x60, 0xef, 0x88, 0xe6, 0xbc, 0xd7, 0x61, 0x60, 0x1e, 0x6c, 0x91,
	0x1d, 0x28, 0xa1, 0xa1, 0x1b, 0xb0, 0xaa, 0x1f, 0x49, 0xd8, 0x83, 0xba, 0xb3, 0x53, 0x87, 0xa3,
	0xa3, 0xa2, 0x1b, 0xaf, 0x76, 0xf6, 0x3b, 0x4b, 0x75, 0xa7, 0x5f, 0xd5, 0xcf, 0xc4, 0x54, 0xad,
	0xfe, 0xf0, 0x05, 0x57, 0x81, 0xba, 0xd3, 0x81, 0x36, 0xa6, 0x47, 0xb6, 0x7f, 0x6e, 0x01, 0xa8,
	0x6c, 0x66, 0x61, 0x88, 0xa3, 0x99, 0xa6, 0x86, 0x69, 0x9a, 0xf4, 0xe0, 0xa7, 0xf9, 0xd2, 0xe0,
	0x47, 0x8b, 0x4f, 0x5a, 0x95, 0xf8, 0x84, 0x57, 0xb7, 0xda, 0x5a, 0x75, 0xcb, 0x7e, 0x0f, 0x36,
	0x99, 0x1d, 0xc5, 0xaa, 0x08, 0xfa, 0xf2, 0xa4, 0x7b, 0x0c, 0xa7, 0xca, 0x8b, 0x44, 0xa4, 0xb1,
	0x0f, 0x88, 0xcf, 0x18, 0x4f, 0xff, 0x45, 0xb5, 0x84, 0x17, 0x18, 0x00, 0xfb, 0x7d, 0x58, 0x37,
	0xa8, 0x89, 0x57, 0x74, 0x1e, 0x46, 0x12, 0xc5, 0x8d, 0x89, 0xcb, 0xbc, 0xb8, 0xa5, 0xbc, 0xb8,
	0xfd, 0x2e, 0xac, 0xf1, 0x65, 0x7a, 0x05, 0x77, 0x61, 0x2a, 0x62, 0x6f, 0xc8, 0x3d, 0x1b, 0x05,
	0xd9, 0xbf, 0x36, 0x28, 0x38, 0xcd, 0xe2, 0xc4, 0xa8, 0x95, 0xbd, 0x52, 0xe1, 0x4b, 0x2f, 0xa8,
	0x35, 0xcc, 0x82, 0x1a, 0xfa, 0x0c, 0x7a, 0xd4, 0x27, 0x4c, 0x3d, 0xff, 0x59, 0x3e, 0x97, 0x4e,
	0xe4, 0x72, 0x91, 0xf7, 0x56, 0x38, 0x52, 0x97, 0xb2, 0xc3, 0x91, 0xb9, 0x4b, 0x81, 0xa8, 0x00,
	0xa0, 0xff, 0x84, 0xa1, 0x30, 0xdd, 0x81, 0x97, 0x79, 0x53, 0x2f, 0xe5, 0x3a, 0xba, 0x2a, 0x2d,
	0xfa, 0x6d, 0x01, 0x45, 0xd7, 0x60, 0xa3, 0x84, 0xe8, 0xce, 0xbd, 0xec, 0x50, 0xe8, 0x02, 0x32,
	0xb1, 0x1f, 0x7a, 0xd9, 0x21, 0x7a, 0x83, 0x55, 0xd1, 0x15, 0xdd, 0x65, 0x46, 0x97, 0x3a, 0x1f,
	0x89, 0x26, 0xdc, 0x84, 0xbe, 0xb9, 0x97, 0xb9, 0x89, 0x55, 0xdd, 0x4d, 0xf8, 0xf4, 0x76, 0xb5,
	0xe3, 0xaa, 0xd2, 0x62, 0xc2, 0xc1, 0xa2, 0x64, 0x28, 0x24, 0x2c, 0x81, 0xac, 0x5e, 0x48, 0x0f,
	0x2e, 0x91, 0x44, 0x05, 0x81, 0x27, 0xbd, 0x03, 0x09, 0x16, 0x95, 0xc2, 0x35, 0x18, 0x1e, 0x1c,
	0xe6, 0x59, 0x10, 0x1f, 0xcb, 0x12, 0x31, 0x4d, 0x93, 0x14, 0x48, 0xdc, 0xf6, 0x7f, 0xc3, 0xa9,
	0x83, 0x7c, 0x9a, 0xfa, 0x49, 0x38, 0xc5, 0x66, 0x0a, 0x3b, 0x81, 0x2e, 0x7e, 0x1e, 0xa6, 0x59,
	0x48, 0x9e, 0xb2, 0x63, 0x75, 0x9d, 0x62, 0x6c, 0x7f, 0x04, 0x9b, 0xc5, 0x2a, 0x6a, 0x0c, 0x52,
	0xad, 0x5d, 0x10, 0x12, 0x3f, 0xca, 0x03, 0xec, 0x66, 0xde, 0x33, 0x11, 0xee, 0x74, 0x1d, 0x13,
	0x68, 0xff, 0xda, 0x82, 0x9e, 0x66, 0x43, 0xfe, 0xc5, 0x92, 0x9b, 0xfe, 0x80, 0x9a, 0x25, 0x0f,
	0x5a, 0x2e, 0xc7, 0xb5, 0x6a, 0xf2, 0x8c, 0xb7, 0x60, 0x20, 0x8c, 0x96, 0x9b, 0x60, 0x2f, 0x8d,
	0xa5, 0x81, 0x28, 0x41, 0xed, 0x3f, 0x37, 0xf9, 0x6e, 0x85, 0x9d, 0x45, 0x67, 0x2a, 0xbb, 0xed,
	0xb0, 0xf1, 0x5d, 0x33, 0xa8, 0x6d, 0x94, 0x82, 0xda, 0x17, 0x3a, 0xf5, 0x45, 0x75, 0x41, 0x6a,
	0x36, 0x13, 0x56, 0xa6, 0x11, 0x9b, 0x13, 0x23, 0x74, 0x09, 0x86, 0x3c, 0xf5, 0x71, 0x13, 0xec,
	0xe3, 0xf0, 0x08, 0x07, 0x2c, 0xa4, 0x69, 0x39, 0x65, 0x30, 0x8d, 0xa5, 0x04, 0x28, 0xc5, 0x24,
	0x63, 0x19, 0x41, 0xcb, 0xd1, 0x41, 0x15, 0x61, 0x41, 0x8d, 0xb0, 0xae, 0x40, 0x2b, 0x89, 0x23,
	0x3c, 0xee, 0xb1, 0xe0, 0x62, 0x5c, 0xe3, 0x7f, 0xb6, 0x9c, 0x38, 0xc2, 0x0e, 0xc3, 0xa2, 0xd1,
	0x99, 0xb4, 0x99, 0x6a, 0x7f, 0xab, 0x8c, 0x6c, 0x75, 0x82, 0x2a, 0x4d, 0x01, 0x64, 0x7b, 0xec,
	0xf3, 0x62, 0xb3, 0x01, 0xa4, 0x19, 0x52, 0xe2, 0xce, 0x13, 0x1c, 0xce, 0xbc, 0xa7, 0x78, 0x3c,
	0x60, 0x28, 0x1a, 0x44, 0x85, 0x59, 0x43, 0x2d, 0xcc, 0xb2, 0xcf, 0x41, 0x8b, 0xee, 0x0b, 0xad,
	0x40, 0xfb, 0xf3, 0x5b, 0x9f, 0xed, 0x39, 0xa3, 0x25, 0xfa, 0x79, 0x8f, 0x7d, 0x5a, 0xf6, 0x2e,
	0xf4, 0x69, 0x52, 0x1e, 0x92, 0xa7, 0xfb, 0x34, 0xa1, 0xa7, 0x77, 0xdb, 0xb9, 0xe7, 0x3d, 0x3f,
	0xc0, 0x51, 0x24, 0xd3, 0x9c, 0x99, 0xf7, 0xdc, 0xa5, 0xd9, 0x00, 0x3a, 0x0d, 0xcb, 0xf7, 0xbc,
	0xe7, 0x3b, 0xb9, 0xb4, 0xd6, 0x1d, 0x3a, 0x33, 0xcd, 0x4f, 0xec, 0xdf, 0x5b, 0xd0, 0x66, 0xa9,
	0x3d, 0x4d, 0x2d, 0x66, 0x54, 0xc1, 0xdd, 0xc5, 0xa1, 0xbe, 0xa3, 0x63, 0xa0, 0x6d, 0xe8, 0x65,
	0xda, 0x82, 0x46, 0xdd, 0x82, 0x81, 0x86, 0x41, 0xb5, 0x45, 0x69, 0x44, 0xd3, 0xd0, 0x88, 0xb2,
	0x16, 0x35, 0xeb, 0x03, 0xca, 0xb6, 0xe9, 0x03, 0xb6, 0x61, 0xc3, 0x90, 0xc0, 0xab, 0x78, 0xc1,
	0xdf, 0x58, 0xb0, 0x59, 0x5a, 0x24, 0x4c, 0xd8, 0x2d, 0x58, 0x66, 0x95, 0x11, 0x19, 0xdc, 0xbd,
	0xad, 0x97, 0x3e, 0x2a, 0xe8, 0x5b, 0x7c, 0x28, 0xaa, 0x4a, 0x7c, 0xe1, 0xe4, 0x21, 0xf4, 0x34,
	0x70, 0x8d, 0x5d, 0x7d, 0xc7, 0xac, 0x2a, 0x6d, 0xd6, 0xb3, 0xd0, 0xcc, 0xed, 0x43, 0x58, 0x7d,
	0x44, 0xa6, 0xdf, 0xaa, 0x53, 0x86, 0xce, 0xc1, 0x4a, 0x82, 0x45, 0xfe, 0x20, 0x0c, 0xac, 0x02,
	0xd8, 0x43, 0xe8, 0x0b, 0x8a, 0xaa, 0xbb, 0xf4, 0x88, 0x44, 0xb1, 0xff, 0xec, 0x55, 0xbb, 0x4b,
	0x3f, 0xb6, 0x00, 0xe9, 0x2b, 0x94, 0x0b, 0xc8, 0x19, 0xb4, 0xe4, 0x02, 0x24, 0x50, 0xba, 0x80,
	0x02, 0xc9, 0x74, 0x01, 0x12, 0xcc, 0x5d, 0x00, 0x7a, 0x1d, 0x7a, 0x3a, 0x2d, 0x5e, 0x1c, 0x07,
	0x45, 0xe9, 0xf2, 0x79, 0x58, 0x29, 0xb2, 0x03, 0xd4, 0x81, 0xe6, 0xce, 0xa3, 0xef, 0x8c, 0x96,
	0x50, 0x17, 0x5a, 0x07, 0x7b, 0xfb, 0xfb, 0x23, 0x6b, 0xfb, 0x6f, 0x16, 0x74, 0x1e, 0xe7, 0xc1,
	0x5d, 0x12, 0x66, 0x68, 0x0f, 0x40, 0xb5, 0xc3, 0xd0, 0x99, 0x22, 0x12, 0x2b, 0x37, 0xd5, 0x26,
	0x93, 0xba, 0x29, 0x21, 0xa7, 0x25, 0x74, 0x07, 0x7a, 0x9a, 0xef, 0x43, 0x93, 0xc5, 0xfe, 0x7f,
	0x72, 0xb6, 0x76, 0xae, 0xa0, 0xb4, 0x07, 0xa0, 0x24, 0xa8, 0x36, 0x54, 0xb9, 0x07, 0xb5, 0xa1,
	0xaa, 0xc0, 0xed, 0xa5, 0xed, 0x9f, 0xad, 0x43, 0xf3, 0x71, 0x1e, 0xa0, 0xc7, 0xd0, 0xd3, 0x3a,
	0xe2, 0xa8, 0x52, 0xf4, 0x55, 0xdb, 0xa9, 0x6b, 0x9c, 0x4f, 0xbe, 0xfe, 0xc3, 0xdf, 0xbf, 0x69,
	0x6c, 0xd8, 0xc3, 0xab, 0x47, 0xff, 0x75, 0xd5, 0x0b, 0x02, 0xf9, 0x56, 0x6e, 0x5a, 0x97, 0x91,
	0x03, 0x1d, 0xd1, 0xf4, 0x46, 0xa7, 0x34, 0x1a, 0x5a, 0x8c, 0x36, 0x39, 0x5d, 0x81, 0x0b, 0xba,
	0xa7, 0x18, 0xdd, 0x91, 0xdd, 0x13, 0x74, 0xe9, 0xb3, 0xa5, 0x34, 0x77, 0xa0, 0xb9, 0xe3, 0x11,
	0x84, 0x54, 0xdf, 0x45, 0xaa, 0xf7, 0x64, 0xdd, 0x80, 0x09, 0x3a, 0x88, 0xd1, 0x59, 0xb5, 0x3b,
	0x94, 0xce, 0xd4, 0x23, 0x62, 0x5f, 0xa2, 0x4b, 0xaa, 0xf6, 0x65, 0x36, 0x59, 0xd5, 0xbe, 0xca,
	0xed, 0x54, 0x63, 0x5f, 0xe2, 0x59, 0x50, 0x9a, 0x3f, 0x80, 0xbe, 0xd1, 0x8a, 0x43, 0x45, 0x95,
	0xa0, 0xae, 0xbb, 0x37, 0x79, 0x6d, 0xc1, 0xac, 0xe0, 0x72, 0x8e, 0x71, 0x39, 0x65, 0xaf, 0x51,
	0x2e, 0x81, 0x40, 0x61, 0xcd, 0x3b, 0xca, 0xeb, 0x31, 0x80, 0x6a, 0x69, 0x29, 0x05, 0xa8, 0xb4,
	0xd1, 0x94, 0x02, 0x54, 0x3b, 0x60, 0xf6, 0x3a, 0x63, 0xd1, 0x47, 0x3d, 0x2e, 0x18, 0x4e, 0x6b,
	0x1f, 0x3a, 0xa2, 0x7d, 0xa3, 0x24, 0x63, 0xf6, 0xb0, 0x94, 0x64, 0x4a, 0x7d, 0x1e, 0x7b, 0xc4,
	0x08, 0x02, 0xea, 0x52, 0x82, 0x21, 0x25, 0xf1, 0x3d, 0xe8, 0x69, 0xad, 0x0d, 0xa4, 0xef, 0xa6,
	0xd4, 0x29, 0x51, 0x3a, 0x56, 0xd3, 0x0b, 0xb1, 0x37, 0x18, 0xe5, 0x01, 0x5a, 0xa5, 0x94, 0xa9,
	0x14, 0x18, 0xf5, 0x2f, 0x00, 0x54, 0xbd, 0x5e, 0x49, 0xa1, 0xd2, 0x4e, 0x50, 0x52, 0xa8, 0x96,
	0xf7, 0xa5, 0x7a, 0x20, 0xa0, 0xa4, 0x45, 0x9d, 0xec, 0x29, 0x0c, 0xcc, 0x26, 0x09, 0x7a, 0x4d,
	0xa7, 0x50, 0xe9, 0xaa, 0x4c, 0xce, 0x2f, 0x9a, 0x36, 0x75, 0x06, 0x0d, 0x98, 0xce, 0x28, 0xb2,
	0x07, 0xb0, 0x52, 0x14, 0xfa, 0xd1, 0x58, 0x27, 0xa2, 0xf7, 0x03, 0x26, 0x67, 0x6a, 0x66, 0x04,
	0xe5, 0x35, 0x46, 0xb9, 0x87, 0x56, 0x28, 0x65, 0x5e, 0x41, 0x92, 0x44, 0x59, 0xb3, 0xcf, 0x24,
	0xaa, 0x75, 0x09, 0x4a, 0x44, 0xf5, 0x5e, 0x41, 0x89, 0x28, 0xa3, 0xf3, 0x25, 0x97, 0x35, 0xaf,
	0xf7, 0x9b, 0xb2, 0x36, 0xda, 0x05, 0xa6, 0xac, 0xcd, 0xf6, 0x80, 0x7d, 0x86, 0xd1, 0x5d, 0xb7,
	0x99, 0x18, 0xa2, 0x30, 0xcd, 0x78, 0x3f, 0x80, 0x6a, 0xb4, 0x0b, 0x3d, 0xad, 0x8a, 0xad, 0x34,
	0xa5, 0x5a, 0x48, 0x57, 0x9a, 0x52, 0x57, 0xf6, 0x3e, 0xcd, 0x58, 0xac, 0x71, 0x6b, 0x14, 0xcf,
	0x31, 0x11, 0x59, 0x32, 0xfa, 0x3e, 0x80, 0xaa, 0x4c, 0xa8, 0x03, 0x54, 0x6a, 0x56, 0x4a, 0xbd,
	0x4b, 0x85, 0x0c, 0x73, 0xf7, 0xac, 0x5a, 0xc4, 0xd4, 0xe5, 0xa6, 0x75, 0xf9, 0x9a, 0x85, 0x9e,
	0xc0, 0x40, 0xe1, 0x1f, 0x9c, 0x10, 0xff, 0x45, 0x2c, 0x26, 0x75, 0x53, 0xe2, 0x00, 0xaf, 0x31,
	0x2e, 0xa7, 0x6d, 0x64, 0x72, 0x49, 0x4f, 0x88, 0x4f, 0xe5, 0xf4, 0x5d, 0xe8, 0x69, 0x8d, 0x7b,
	0x25, 0xa7, 0x6a, 0x37, 0x7f, 0x52, 0x57, 0x29, 0x31, 0xad, 0x35, 0xe6, 0x8b, 0xd2, 0x63, 0x6f,
	0x4e, 0x69, 0x13, 0x18, 0x98, 0x29, 0xbe, 0x52, 0xfb, 0xda, 0x7a, 0x81, 0x52, 0xfb, 0x05, 0x95,
	0x01, 0xe3, 0x2c, 0xac, 0x52, 0x8b, 0x75, 0xef, 0x30, 0xa5, 0x0e, 0xb1, 0x48, 0xf5, 0x75, 0x87,
	0x58, 0xae, 0x26, 0xe8, 0x0e, 0xb1, 0x52, 0x1b, 0x30, 0xcf, 0xc4, 0xd9, 0xc8, 0x9b, 0xa1, 0x7a,
	0xab, 0x12, 0x7d, 0x75, 0x27, 0x95, 0x5a, 0xc1, 0x64, 0x52, 0x37, 0x55, 0xa7, 0xb7, 0x9c, 0x81,
	0xf4, 0x46, 0xff, 0x0f, 0x5d, 0x99, 0x58, 0xa2, 0x42, 0x73, 0x4a, 0xd9, 0xe7, 0x64, 0x5c, 0x9d,
	0x28, 0xa9, 0x2b, 0x33, 0x6c, 0xa9, 0x98, 0xa5, 0x74, 0x31, 0x0c, 0x4b, 0xc9, 0x29, 0x2a, 0xa4,
	0x5d, 0x9f, 0xb5, 0x4e, 0xcc, 0x4e, 0x3d, 0x2f, 0xbe, 0xdb, 0x67, 0x19, 0x83, 0x4d, 0xb4, 0xce,
	0x18, 0xc8, 0x85, 0x5c, 0xa5, 0xae, 0x59, 0x68, 0x0a, 0x03, 0x33, 0x9b, 0x55, 0x57, 0x5e, 0x9b,
	0xe5, 0xbe, 0x50, 0xa9, 0x10, 0x32, 0x98, 0x50, 0xb5, 0xa2, 0x3c, 0xe6, 0xa5, 0x8c, 0x59, 0xa4,
	0xbe, 0xdf, 0x8e, 0x95, 0x58, 0x64, 0xbf, 0xc1, 0x58, 0x9d, 0x45, 0x67, 0x2a, 0xac, 0x64, 0x11,
	0xf2, 0x9a, 0x85, 0x9e, 0x96, 0x73, 0x9b, 0x73, 0x0b, 0x82, 0xf1, 0x92, 0x2b, 0xae, 0x0d, 0xd5,
	0xe5, 0xed, 0x23, 0xe6, 0x8a, 0x33, 0x8e, 0xc2, 0x23, 0x76, 0xf4, 0x29, 0xb4, 0x59, 0x34, 0x8c,
	0x36, 0x54, 0xa0, 0xa5, 0xc2, 0xed, 0xc9, 0x66, 0x09, 0x6a, 0x7a, 0x33, 0x9b, 0x99, 0xd7, 0x9c,
	0xf0, 0x98, 0x64, 0xba, 0xcc, 0x7e, 0x4f, 0x7c, 0xef, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc3,
	0x2b, 0x00, 0x2b, 0xc9, 0x28, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// XudInitClient is the client API for XudInit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type XudInitClient interface {
	// Creates an xud identity node key and underlying wallets. The node key and
	// wallets are derived from a single seed and encrypted using a single
	// password provided as a parameter to the call.
	// shell: xucli create
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error)
	// Restores an xud instance and underlying wallets from a seed.
	// shell: xucli restore [backup_directory] [raiden_database_path]
	RestoreNode(ctx context.Context, in *RestoreNodeRequest, opts ...grpc.CallOption) (*RestoreNodeResponse, error)
	// Unlocks and decrypts the xud node key and any underlying wallets.
	// shell: xucli unlock
	UnlockNode(ctx context.Context, in *UnlockNodeRequest, opts ...grpc.CallOption) (*UnlockNodeResponse, error)
}

type xudInitClient struct {
	cc *grpc.ClientConn
}

func NewXudInitClient(cc *grpc.ClientConn) XudInitClient {
	return &xudInitClient{cc}
}

func (c *xudInitClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error) {
	out := new(CreateNodeResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.XudInit/CreateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudInitClient) RestoreNode(ctx context.Context, in *RestoreNodeRequest, opts ...grpc.CallOption) (*RestoreNodeResponse, error) {
	out := new(RestoreNodeResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.XudInit/RestoreNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudInitClient) UnlockNode(ctx context.Context, in *UnlockNodeRequest, opts ...grpc.CallOption) (*UnlockNodeResponse, error) {
	out := new(UnlockNodeResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.XudInit/UnlockNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// XudInitServer is the server API for XudInit service.
type XudInitServer interface {
	// Creates an xud identity node key and underlying wallets. The node key and
	// wallets are derived from a single seed and encrypted using a single
	// password provided as a parameter to the call.
	// shell: xucli create
	CreateNode(context.Context, *CreateNodeRequest) (*CreateNodeResponse, error)
	// Restores an xud instance and underlying wallets from a seed.
	// shell: xucli restore [backup_directory] [raiden_database_path]
	RestoreNode(context.Context, *RestoreNodeRequest) (*RestoreNodeResponse, error)
	// Unlocks and decrypts the xud node key and any underlying wallets.
	// shell: xucli unlock
	UnlockNode(context.Context, *UnlockNodeRequest) (*UnlockNodeResponse, error)
}

func RegisterXudInitServer(s *grpc.Server, srv XudInitServer) {
	s.RegisterService(&_XudInit_serviceDesc, srv)
}

func _XudInit_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/CreateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).CreateNode(ctx, req.(*CreateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XudInit_RestoreNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).RestoreNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/RestoreNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).RestoreNode(ctx, req.(*RestoreNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XudInit_UnlockNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudInitServer).UnlockNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.XudInit/UnlockNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudInitServer).UnlockNode(ctx, req.(*UnlockNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _XudInit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.XudInit",
	HandlerType: (*XudInitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNode",
			Handler:    _XudInit_CreateNode_Handler,
		},
		{
			MethodName: "RestoreNode",
			Handler:    _XudInit_RestoreNode_Handler,
		},
		{
			MethodName: "UnlockNode",
			Handler:    _XudInit_UnlockNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "xudrpc.proto",
}

// XudClient is the client API for Xud service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type XudClient interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	// shell: xucli addcurrency <currency> <swap_client> [decimal_places] [token_address]
	AddCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	// shell: xucli addpair <base_currency> <quote_currency>
	AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	// shell: xucli ban <node_key>
	Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	// shell: xucli connect <node_uri>
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// Discover nodes from a specific peer and apply new connections
	DiscoverNodes(ctx context.Context, in *DiscoverNodesRequest, opts ...grpc.CallOption) (*DiscoverNodesResponse, error)
	// Gets the total balance available across all payment channels and wallets for one or all currencies.
	// shell: xucli getbalance [currency]
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	// Gets general information about this node.
	// shell: xucli getinfo
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// Gets general information about a node.
	// shell: xucli getnodeinfo <node_key>
	GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	// shell: xucli listorders [pair_id] [include_own_orders] [limit]
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	// shell: xucli listcurrencies
	ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	// shell: xucli listpairs
	ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	// shell: xucli listpeers
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	// Gets a list of completed trades.
	// shell: xucli listtrades [limit]
	ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error)
	// Opens a payment channel to a peer with the given node pub key for the specified amount and currency.
	// shell: xucli openchannel <node_key> <currency> <amount>
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error)
	// The synchronous, non-streaming version of PlaceOrder.
	// shell: xucli buy <quantity> <pair_id> <price> [order_id] [stream]
	// shell: xucli sell <quantity> <pair_id> <price> [order_id] [stream]
	PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Executes a swap on a maker peer order.
	ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*SwapSuccess, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	// shell: xucli removecurrency <currency>
	RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	// shell: xucli removeorder <order_id> [quantity]
	RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	// shell: xucli removepair <pair_id>
	RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error)
	// Begin gracefully shutting down xud.
	// shell: xucli shutdown
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Subscribes to orders being added to and removed from the order book. This call allows the client
	// to maintain an up-to-date view of the order book. For example, an exchange that wants to show
	// its users a real time view of the orders available to them would subscribe to this streaming
	// call to be alerted as new orders are added and expired orders are removed.
	SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeOrdersClient, error)
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error)
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error)
	// Gets the trading limits for one or all currencies.
	// shell: xucli tradinglimits [currency]
	TradingLimits(ctx context.Context, in *TradingLimitsRequest, opts ...grpc.CallOption) (*TradingLimitsResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	// shell: xucli unban <node_key> [reconnect]
	Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error)
}

type xudClient struct {
	cc *grpc.ClientConn
}

func NewXudClient(cc *grpc.ClientConn) XudClient {
	return &xudClient{cc}
}

func (c *xudClient) AddCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*AddCurrencyResponse, error) {
	out := new(AddCurrencyResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/AddCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) AddPair(ctx context.Context, in *AddPairRequest, opts ...grpc.CallOption) (*AddPairResponse, error) {
	out := new(AddPairResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/AddPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Ban(ctx context.Context, in *BanRequest, opts ...grpc.CallOption) (*BanResponse, error) {
	out := new(BanResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Ban", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) DiscoverNodes(ctx context.Context, in *DiscoverNodesRequest, opts ...grpc.CallOption) (*DiscoverNodesResponse, error) {
	out := new(DiscoverNodesResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/DiscoverNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/GetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error) {
	out := new(GetNodeInfoResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListCurrencies(ctx context.Context, in *ListCurrenciesRequest, opts ...grpc.CallOption) (*ListCurrenciesResponse, error) {
	out := new(ListCurrenciesResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListCurrencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPairs(ctx context.Context, in *ListPairsRequest, opts ...grpc.CallOption) (*ListPairsResponse, error) {
	out := new(ListPairsResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListPairs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListTrades(ctx context.Context, in *ListTradesRequest, opts ...grpc.CallOption) (*ListTradesResponse, error) {
	out := new(ListTradesResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ListTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelResponse, error) {
	out := new(OpenChannelResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/OpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (Xud_PlaceOrderClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[0], "/xudrpc.Xud/PlaceOrder", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudPlaceOrderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_PlaceOrderClient interface {
	Recv() (*PlaceOrderEvent, error)
	grpc.ClientStream
}

type xudPlaceOrderClient struct {
	grpc.ClientStream
}

func (x *xudPlaceOrderClient) Recv() (*PlaceOrderEvent, error) {
	m := new(PlaceOrderEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) PlaceOrderSync(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/PlaceOrderSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*SwapSuccess, error) {
	out := new(SwapSuccess)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/ExecuteSwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveCurrency(ctx context.Context, in *RemoveCurrencyRequest, opts ...grpc.CallOption) (*RemoveCurrencyResponse, error) {
	out := new(RemoveCurrencyResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/RemoveCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemoveOrder(ctx context.Context, in *RemoveOrderRequest, opts ...grpc.CallOption) (*RemoveOrderResponse, error) {
	out := new(RemoveOrderResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/RemoveOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) RemovePair(ctx context.Context, in *RemovePairRequest, opts ...grpc.CallOption) (*RemovePairResponse, error) {
	out := new(RemovePairResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/RemovePair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribeOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[1], "/xudrpc.Xud/SubscribeOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeOrdersClient interface {
	Recv() (*OrderUpdate, error)
	grpc.ClientStream
}

type xudSubscribeOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeOrdersClient) Recv() (*OrderUpdate, error) {
	m := new(OrderUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[2], "/xudrpc.Xud/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapsClient interface {
	Recv() (*SwapSuccess, error)
	grpc.ClientStream
}

type xudSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapsClient) Recv() (*SwapSuccess, error) {
	m := new(SwapSuccess)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwapFailures(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapFailuresClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Xud_serviceDesc.Streams[3], "/xudrpc.Xud/SubscribeSwapFailures", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapFailuresClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapFailuresClient interface {
	Recv() (*SwapFailure, error)
	grpc.ClientStream
}

type xudSubscribeSwapFailuresClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapFailuresClient) Recv() (*SwapFailure, error) {
	m := new(SwapFailure)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) TradingLimits(ctx context.Context, in *TradingLimitsRequest, opts ...grpc.CallOption) (*TradingLimitsResponse, error) {
	out := new(TradingLimitsResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/TradingLimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Unban(ctx context.Context, in *UnbanRequest, opts ...grpc.CallOption) (*UnbanResponse, error) {
	out := new(UnbanResponse)
	err := c.cc.Invoke(ctx, "/xudrpc.Xud/Unban", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// XudServer is the server API for Xud service.
type XudServer interface {
	// Adds a currency to the list of supported currencies. Once added, the currency may be used for
	// new trading pairs.
	// shell: xucli addcurrency <currency> <swap_client> [decimal_places] [token_address]
	AddCurrency(context.Context, *Currency) (*AddCurrencyResponse, error)
	// Adds a trading pair to the list of supported trading pairs. The newly supported pair is
	// advertised to peers so they may begin sending orders for it.
	// shell: xucli addpair <base_currency> <quote_currency>
	AddPair(context.Context, *AddPairRequest) (*AddPairResponse, error)
	// Bans a node and immediately disconnects from it. This can be used to prevent any connections
	// to a specific node.
	// shell: xucli ban <node_key>
	Ban(context.Context, *BanRequest) (*BanResponse, error)
	// Attempts to connect to a node. Once connected, the node is added to the list of peers and
	// becomes available for swaps and trading. A handshake exchanges information about the peer's
	// supported trading and swap clients. Orders will be shared with the peer upon connection and
	// upon new order placements.
	// shell: xucli connect <node_uri>
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// Discover nodes from a specific peer and apply new connections
	DiscoverNodes(context.Context, *DiscoverNodesRequest) (*DiscoverNodesResponse, error)
	// Gets the total balance available across all payment channels and wallets for one or all currencies.
	// shell: xucli getbalance [currency]
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	// Gets general information about this node.
	// shell: xucli getinfo
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// Gets general information about a node.
	// shell: xucli getnodeinfo <node_key>
	GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error)
	// Gets orders from the order book. This call returns the state of the order book at a given point
	// in time, although it is not guaranteed to still be vaild by the time a response is received
	// and processed by a client. It accepts an optional trading pair id parameter. If specified, only
	// orders for that particular trading pair are returned. Otherwise, all orders are returned. Orders
	// are separated into buys and sells for each trading pair, but unsorted.
	// shell: xucli listorders [pair_id] [include_own_orders] [limit]
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	// Gets a list of this node's supported currencies.
	// shell: xucli listcurrencies
	ListCurrencies(context.Context, *ListCurrenciesRequest) (*ListCurrenciesResponse, error)
	// Gets a list of this nodes suported trading pairs.
	// shell: xucli listpairs
	ListPairs(context.Context, *ListPairsRequest) (*ListPairsResponse, error)
	// Gets a list of connected peers.
	// shell: xucli listpeers
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	// Gets a list of completed trades.
	// shell: xucli listtrades [limit]
	ListTrades(context.Context, *ListTradesRequest) (*ListTradesResponse, error)
	// Opens a payment channel to a peer with the given node pub key for the specified amount and currency.
	// shell: xucli openchannel <node_key> <currency> <amount>
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelResponse, error)
	// Adds an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(*PlaceOrderRequest, Xud_PlaceOrderServer) error
	// The synchronous, non-streaming version of PlaceOrder.
	// shell: xucli buy <quantity> <pair_id> <price> [order_id] [stream]
	// shell: xucli sell <quantity> <pair_id> <price> [order_id] [stream]
	PlaceOrderSync(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Executes a swap on a maker peer order.
	ExecuteSwap(context.Context, *ExecuteSwapRequest) (*SwapSuccess, error)
	// Removes a currency from the list of supported currencies. Only currencies that are not in use
	// for any currently supported trading pairs may be removed. Once removed, the currency can no
	// longer be used for any supported trading pairs.
	// shell: xucli removecurrency <currency>
	RemoveCurrency(context.Context, *RemoveCurrencyRequest) (*RemoveCurrencyResponse, error)
	// Removes an order from the order book by its local id. This should be called when an order is
	// canceled or filled outside of xud. Removed orders become immediately unavailable for swaps,
	// and peers are notified that the order is no longer valid. Any portion of the order that is
	// on hold due to ongoing swaps will not be removed until after the swap attempts complete.
	// shell: xucli removeorder <order_id> [quantity]
	RemoveOrder(context.Context, *RemoveOrderRequest) (*RemoveOrderResponse, error)
	// Removes a trading pair from the list of currently supported trading pair. This call will
	// effectively cancel any standing orders for that trading pair. Peers are informed when a pair
	// is no longer supported so that they will know to stop sending orders for it.
	// shell: xucli removepair <pair_id>
	RemovePair(context.Context, *RemovePairRequest) (*RemovePairResponse, error)
	// Begin gracefully shutting down xud.
	// shell: xucli shutdown
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Subscribes to orders being added to and removed from the order book. This call allows the client
	// to maintain an up-to-date view of the order book. For example, an exchange that wants to show
	// its users a real time view of the orders available to them would subscribe to this streaming
	// call to be alerted as new orders are added and expired orders are removed.
	SubscribeOrders(*SubscribeOrdersRequest, Xud_SubscribeOrdersServer) error
	// Subscribes to completed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when its orders are filled by a peer. It can be used
	// for tracking order executions, updating balances, and informing a trader when one of their orders
	// is settled through the Exchange Union network.
	SubscribeSwaps(*SubscribeSwapsRequest, Xud_SubscribeSwapsServer) error
	// Subscribes to failed swaps. By default, only swaps that are initiated by a remote peer are
	// transmitted unless a flag is set to include swaps initiated by the local node. This call allows
	// the client to get real-time notifications when swap attempts are failing. It can be used for
	// status monitoring, debugging, and testing purposes.
	SubscribeSwapFailures(*SubscribeSwapsRequest, Xud_SubscribeSwapFailuresServer) error
	// Gets the trading limits for one or all currencies.
	// shell: xucli tradinglimits [currency]
	TradingLimits(context.Context, *TradingLimitsRequest) (*TradingLimitsResponse, error)
	// Removes a ban from a node manually and, optionally, attempts to connect to it.
	// shell: xucli unban <node_key> [reconnect]
	Unban(context.Context, *UnbanRequest) (*UnbanResponse, error)
}

func RegisterXudServer(s *grpc.Server, srv XudServer) {
	s.RegisterService(&_Xud_serviceDesc, srv)
}

func _Xud_AddCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Currency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddCurrency(ctx, req.(*Currency))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_AddPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).AddPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/AddPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).AddPair(ctx, req.(*AddPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Ban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Ban(ctx, req.(*BanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_DiscoverNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).DiscoverNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/DiscoverNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).DiscoverNodes(ctx, req.(*DiscoverNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetNodeInfo(ctx, req.(*GetNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCurrenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListCurrencies(ctx, req.(*ListCurrenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPairs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPairs(ctx, req.(*ListPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTradesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListTrades(ctx, req.(*ListTradesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_PlaceOrder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlaceOrderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).PlaceOrder(m, &xudPlaceOrderServer{stream})
}

type Xud_PlaceOrderServer interface {
	Send(*PlaceOrderEvent) error
	grpc.ServerStream
}

type xudPlaceOrderServer struct {
	grpc.ServerStream
}

func (x *xudPlaceOrderServer) Send(m *PlaceOrderEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_PlaceOrderSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).PlaceOrderSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/PlaceOrderSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).PlaceOrderSync(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ExecuteSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ExecuteSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ExecuteSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ExecuteSwap(ctx, req.(*ExecuteSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveCurrency(ctx, req.(*RemoveCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemoveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemoveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemoveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemoveOrder(ctx, req.(*RemoveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_RemovePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).RemovePair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/RemovePair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).RemovePair(ctx, req.(*RemovePairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_SubscribeOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeOrders(m, &xudSubscribeOrdersServer{stream})
}

type Xud_SubscribeOrdersServer interface {
	Send(*OrderUpdate) error
	grpc.ServerStream
}

type xudSubscribeOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeOrdersServer) Send(m *OrderUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwaps(m, &xudSubscribeSwapsServer{stream})
}

type Xud_SubscribeSwapsServer interface {
	Send(*SwapSuccess) error
	grpc.ServerStream
}

type xudSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapsServer) Send(m *SwapSuccess) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwapFailures_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwapFailures(m, &xudSubscribeSwapFailuresServer{stream})
}

type Xud_SubscribeSwapFailuresServer interface {
	Send(*SwapFailure) error
	grpc.ServerStream
}

type xudSubscribeSwapFailuresServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapFailuresServer) Send(m *SwapFailure) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_TradingLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradingLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).TradingLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/TradingLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).TradingLimits(ctx, req.(*TradingLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Unban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Unban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Unban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Unban(ctx, req.(*UnbanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Xud_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.Xud",
	HandlerType: (*XudServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCurrency",
			Handler:    _Xud_AddCurrency_Handler,
		},
		{
			MethodName: "AddPair",
			Handler:    _Xud_AddPair_Handler,
		},
		{
			MethodName: "Ban",
			Handler:    _Xud_Ban_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Xud_Connect_Handler,
		},
		{
			MethodName: "DiscoverNodes",
			Handler:    _Xud_DiscoverNodes_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _Xud_GetBalance_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Xud_GetInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Xud_GetNodeInfo_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Xud_ListOrders_Handler,
		},
		{
			MethodName: "ListCurrencies",
			Handler:    _Xud_ListCurrencies_Handler,
		},
		{
			MethodName: "ListPairs",
			Handler:    _Xud_ListPairs_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Xud_ListPeers_Handler,
		},
		{
			MethodName: "ListTrades",
			Handler:    _Xud_ListTrades_Handler,
		},
		{
			MethodName: "OpenChannel",
			Handler:    _Xud_OpenChannel_Handler,
		},
		{
			MethodName: "PlaceOrderSync",
			Handler:    _Xud_PlaceOrderSync_Handler,
		},
		{
			MethodName: "ExecuteSwap",
			Handler:    _Xud_ExecuteSwap_Handler,
		},
		{
			MethodName: "RemoveCurrency",
			Handler:    _Xud_RemoveCurrency_Handler,
		},
		{
			MethodName: "RemoveOrder",
			Handler:    _Xud_RemoveOrder_Handler,
		},
		{
			MethodName: "RemovePair",
			Handler:    _Xud_RemovePair_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Xud_Shutdown_Handler,
		},
		{
			MethodName: "TradingLimits",
			Handler:    _Xud_TradingLimits_Handler,
		},
		{
			MethodName: "Unban",
			Handler:    _Xud_Unban_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PlaceOrder",
			Handler:       _Xud_PlaceOrder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeOrders",
			Handler:       _Xud_SubscribeOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Xud_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwapFailures",
			Handler:       _Xud_SubscribeSwapFailures_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "xudrpc.proto",
}
