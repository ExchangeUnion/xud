import { Server, ServerCredentials } from '@grpc/grpc-js';
import assert from 'assert';
import { promises as fs } from 'fs';
import { md, pki } from 'node-forge';
import { hostname } from 'os';
import Logger from '../Logger';
import * as xudGrpc from '../proto/xudrpc_grpc_pb';
import errors from './errors';
import GrpcInitService from './GrpcInitService';
import GrpcService from './GrpcService';
import { ServerProxy, serverProxy } from './serverProxy';

class GrpcServer {
  public grpcService = new GrpcService();
  public grpcInitService = new GrpcInitService();
  private server: ServerProxy;

  constructor(private logger: Logger) {
    this.server = serverProxy(new Server());

    this.grpcInitService = new GrpcInitService();
    this.grpcService = new GrpcService();
    // @ts-ignore
    this.server.addService(xudGrpc['xudrpc.XudInit'], this.grpcInitService);
    // @ts-ignore
    this.server.addService(xudGrpc['xudrpc.Xud'], this.grpcService);

    this.server.use(async (ctx: any, next: any) => {
      logger.trace(`received call ${ctx.service.path}`);

      await next();

      const status = ctx.status || ctx.call.status;
      if (!status) {
        logger.trace(`unknown status for call ${ctx.service.path}`);
      } else if (status.code !== 0) {
        if (typeof status.details === 'object') {
          logger.error(`call ${ctx.service.path} errored with code ${status.details.code}: ${status.details.message}`);
        } else if (typeof status.details === 'string') {
          logger.error(`call ${ctx.service.path} errored with code ${status.code}: ${status.details}`);
        } else {
          logger.error(`call ${ctx.service.path} errored with code ${status.code}`);
        }
      } else {
        logger.trace(`call ${ctx.service.path} succeeded`);
      }
    });
  }

  /**
   * Start the server and begin listening on the provided port
   * @returns true if the server started listening successfully, false otherwise
   */
  public listen = async (port: number, host: string, tlsCertPath: string, tlsKeyPath: string): Promise<void> => {
    assert(Number.isInteger(port) && port > 1023 && port < 65536, 'port must be an integer between 1024 and 65535');

    let certificate: Buffer;
    let privateKey: Buffer;

    try {
      [certificate, privateKey] = await Promise.all([fs.readFile(tlsCertPath), fs.readFile(tlsKeyPath)]);
    } catch (err) {
      this.logger.info('Could not load gRPC TLS certificate. Generating new one');
      const { tlsCert, tlsKey } = await this.generateCertificate(tlsCertPath, tlsKeyPath);
      this.logger.info('gRPC TLS certificate created');

      certificate = Buffer.from(tlsCert);
      privateKey = Buffer.from(tlsKey);
    }

    // tslint:disable-next-line:no-null-keyword
    const credentials = ServerCredentials.createSsl(
      null,
      [
        {
          cert_chain: certificate,
          private_key: privateKey,
        },
      ],
      false,
    );

    return new Promise<void>((resolve, reject) => {
      this.server.bindAsync(`${host}:${port}`, credentials, (err) => {
        if (err) {
          this.logger.error(err.message);
          reject(errors.COULD_NOT_BIND(port.toString()));
        }
        this.server.start();
        this.logger.info(`gRPC server listening on ${host}:${port}`);
        resolve();
      });
    });
  };

  /**
   * Stop listening for requests
   */
  public close = (): Promise<void> => {
    if (this.grpcService) {
      this.grpcService.closeStreams();
    }
    return new Promise((resolve) => {
      this.server.tryShutdown(() => {
        this.logger.info('gRPC server completed shutdown');
        resolve();
      });
    });
  };

  /**
   * Generate a new certificate and save it to the disk
   * @returns the cerificate and its private key
   */
  private generateCertificate = async (
    tlsCertPath: string,
    tlsKeyPath: string,
  ): Promise<{ tlsCert: string; tlsKey: string }> => {
    const keys = pki.rsa.generateKeyPair(2048);
    const cert = pki.createCertificate();

    cert.publicKey = keys.publicKey;
    cert.serialNumber = String(Math.floor(Math.random() * 2048) + 1);

    // TODO: handle expired certificates
    const date = new Date();
    cert.validity.notBefore = date;
    cert.validity.notAfter = new Date(date.getFullYear() + 5, date.getMonth(), date.getDay());

    const attributes = [
      {
        name: 'organizationName',
        value: 'XUD autogenerated certificate',
      },
      {
        name: 'commonName',
        value: hostname(),
      },
    ];

    cert.setSubject(attributes);
    cert.setIssuer(attributes);

    // TODO: add tlsextradomain and tlsextraip options
    cert.setExtensions([
      {
        name: 'subjectAltName',
        altNames: [
          {
            type: 2,
            value: 'localhost',
          },
          {
            type: 7,
            ip: '127.0.0.1',
          },
        ],
      },
    ]);

    cert.sign(keys.privateKey, md.sha256.create());

    const certificate = pki.certificateToPem(cert);
    const privateKey = pki.privateKeyToPem(keys.privateKey);

    await Promise.all([fs.writeFile(tlsCertPath, certificate), fs.writeFile(tlsKeyPath, privateKey)]);
    return {
      tlsCert: certificate,
      tlsKey: privateKey,
    };
  };
}

export default GrpcServer;
